// Package checkbox provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/deepmap/oapi-codegen version v1.12.4 DO NOT EDIT.
package checkbox

import (
	"bytes"
	"compress/gzip"
	"context"
	"encoding/base64"
	"encoding/json"
	"fmt"
	"io"
	"net/http"
	"net/url"
	"path"
	"strings"
	"time"

	"github.com/deepmap/oapi-codegen/pkg/runtime"
	openapi_types "github.com/deepmap/oapi-codegen/pkg/types"
	"github.com/getkin/kin-openapi/openapi3"
	"github.com/labstack/echo/v4"
)

const (
	CashierJWTtokenScopes = "CashierJWTtoken.Scopes"
)

// Defines values for AddressTypeEnum.
const (
	Flat   AddressTypeEnum = "flat"
	House  AddressTypeEnum = "house"
	Office AddressTypeEnum = "office"
)

// Defines values for CurrencyExchangeType.
const (
	BUY     CurrencyExchangeType = "BUY"
	CONVERT CurrencyExchangeType = "CONVERT"
	SELL    CurrencyExchangeType = "SELL"
)

// Defines values for CustomOrderStatus.
const (
	CustomOrderStatusAPPROVED         CustomOrderStatus = "APPROVED"
	CustomOrderStatusCANCELED         CustomOrderStatus = "CANCELED"
	CustomOrderStatusDELIVERED        CustomOrderStatus = "DELIVERED"
	CustomOrderStatusDELIVERING       CustomOrderStatus = "DELIVERING"
	CustomOrderStatusDONE             CustomOrderStatus = "DONE"
	CustomOrderStatusINWORK           CustomOrderStatus = "IN_WORK"
	CustomOrderStatusNEW              CustomOrderStatus = "NEW"
	CustomOrderStatusPREPARING        CustomOrderStatus = "PREPARING"
	CustomOrderStatusTEST             CustomOrderStatus = "TEST"
	CustomOrderStatusTRANSFERREDTOWMS CustomOrderStatus = "TRANSFERRED_TO_WMS"
)

// Defines values for DiscountMode.
const (
	PERCENT DiscountMode = "PERCENT"
	VALUE   DiscountMode = "VALUE"
)

// Defines values for DiscountType.
const (
	DISCOUNT    DiscountType = "DISCOUNT"
	EXTRACHARGE DiscountType = "EXTRA_CHARGE"
)

// Defines values for GoodsIntegrationOrdering.
const (
	Asc  GoodsIntegrationOrdering = "asc"
	Desc GoodsIntegrationOrdering = "desc"
)

// Defines values for OrderPaymentEnum.
const (
	CARDAFTERASSEMBLING OrderPaymentEnum = "CARD_AFTER_ASSEMBLING"
	CASHLESSONDELIVERY  OrderPaymentEnum = "CASHLESS_ON_DELIVERY"
	CASHONDELIVERY      OrderPaymentEnum = "CASH_ON_DELIVERY"
)

// Defines values for OrderStatus.
const (
	CANCELLED OrderStatus = "CANCELLED"
	PENDING   OrderStatus = "PENDING"
	SAVING    OrderStatus = "SAVING"
	SUCCESS   OrderStatus = "SUCCESS"
)

// Defines values for PaymentType.
const (
	CARD     PaymentType = "CARD"
	CASH     PaymentType = "CASH"
	CASHLESS PaymentType = "CASHLESS"
)

// Defines values for ReportStatus.
const (
	ReportStatusDONE    ReportStatus = "DONE"
	ReportStatusERROR   ReportStatus = "ERROR"
	ReportStatusPENDING ReportStatus = "PENDING"
)

// Defines values for ReportType.
const (
	GOODS         ReportType = "GOODS"
	RECEIPTS      ReportType = "RECEIPTS"
	SHIFTSTATUSES ReportType = "SHIFT_STATUSES"
	ZREPORTS      ReportType = "Z_REPORTS"
)

// Defines values for ServiceOperationType.
const (
	ADVANCE       ServiceOperationType = "ADVANCE"
	COLLECTION    ServiceOperationType = "COLLECTION"
	REINFORCEMENT ServiceOperationType = "REINFORCEMENT"
)

// AddressModel defines model for AddressModel.
type AddressModel struct {
	// AddressType An enumeration.
	AddressType     AddressTypeEnum `json:"address_type"`
	ApartmentNumber *string         `json:"apartment_number,omitempty"`
	Elevator        *bool           `json:"elevator,omitempty"`
	Entrance        *int            `json:"entrance,omitempty"`
	Floor           *int            `json:"floor,omitempty"`
	Intercom        *bool           `json:"intercom,omitempty"`
	Street          string          `json:"street"`
}

// AddressTypeEnum An enumeration.
type AddressTypeEnum string

// BalanceModel defines model for BalanceModel.
type BalanceModel struct {
	Balance        int        `json:"balance"`
	CardReturns    int        `json:"card_returns"`
	CardSales      int        `json:"card_sales"`
	CashReturns    int        `json:"cash_returns"`
	CashSales      int        `json:"cash_sales"`
	DiscountsSum   *int       `json:"discounts_sum,omitempty"`
	ExtraChargeSum *int       `json:"extra_charge_sum,omitempty"`
	Initial        int        `json:"initial"`
	ServiceIn      int        `json:"service_in"`
	ServiceOut     int        `json:"service_out"`
	UpdatedAt      *time.Time `json:"updated_at,omitempty"`
}

// BodyImportGoodsFromFileApiV1GoodsImportUploadPost defines model for Body_import_goods_from_file_api_v1_goods_import_upload_post.
type BodyImportGoodsFromFileApiV1GoodsImportUploadPost struct {
	File openapi_types.File `json:"file"`
}

// BranchModel defines model for BranchModel.
type BranchModel struct {
	Address      string             `json:"address"`
	CreatedAt    time.Time          `json:"created_at"`
	Id           openapi_types.UUID `json:"id"`
	Name         string             `json:"name"`
	Organization OrganizationModel  `json:"organization"`
	UpdatedAt    *time.Time         `json:"updated_at,omitempty"`
}

// CalculatedDiscountPayload defines model for CalculatedDiscountPayload.
type CalculatedDiscountPayload struct {
	Mode     DiscountMode                        `json:"mode"`
	Name     *string                             `json:"name,omitempty"`
	Sum      float32                             `json:"sum"`
	TaxCode  *CalculatedDiscountPayload_TaxCode  `json:"tax_code,omitempty"`
	TaxCodes *CalculatedDiscountPayload_TaxCodes `json:"tax_codes,omitempty"`
	Type     DiscountType                        `json:"type"`
	Value    float32                             `json:"value"`
}

// CalculatedDiscountPayloadTaxCode0 defines model for .
type CalculatedDiscountPayloadTaxCode0 = int

// CalculatedDiscountPayloadTaxCode1 defines model for .
type CalculatedDiscountPayloadTaxCode1 = string

// CalculatedDiscountPayload_TaxCode defines model for CalculatedDiscountPayload.TaxCode.
type CalculatedDiscountPayload_TaxCode struct {
	union json.RawMessage
}

// CalculatedDiscountPayloadTaxCodes0 defines model for .
type CalculatedDiscountPayloadTaxCodes0 = []int

// CalculatedDiscountPayloadTaxCodes1 defines model for .
type CalculatedDiscountPayloadTaxCodes1 = []string

// CalculatedDiscountPayload_TaxCodes defines model for CalculatedDiscountPayload.TaxCodes.
type CalculatedDiscountPayload_TaxCodes struct {
	union json.RawMessage
}

// CalculatedGoodDetailsPayload defines model for CalculatedGoodDetailsPayload.
type CalculatedGoodDetailsPayload struct {
	Barcode        *string   `json:"barcode,omitempty"`
	Code           string    `json:"code"`
	ExciseBarcode  *string   `json:"excise_barcode,omitempty"`
	ExciseBarcodes *[]string `json:"excise_barcodes,omitempty"`
	Footer         *string   `json:"footer,omitempty"`
	Header         *string   `json:"header,omitempty"`
	Name           string    `json:"name"`
	Price          int       `json:"price"`
	Uktzed         *string   `json:"uktzed,omitempty"`
}

// CalculatedGoodItemPayload defines model for CalculatedGoodItemPayload.
type CalculatedGoodItemPayload struct {
	Discounts        *[]CalculatedDiscountPayload `json:"discounts,omitempty"`
	Good             CalculatedGoodDetailsPayload `json:"good"`
	GoodId           *openapi_types.UUID          `json:"good_id,omitempty"`
	IsReturn         *bool                        `json:"is_return,omitempty"`
	IsWinningsPayout *bool                        `json:"is_winnings_payout,omitempty"`
	Quantity         int                          `json:"quantity"`
	Sum              int                          `json:"sum"`
	Taxes            []CalculatedGoodTaxPayload   `json:"taxes"`
}

// CalculatedGoodTaxPayload defines model for CalculatedGoodTaxPayload.
type CalculatedGoodTaxPayload struct {
	Code       int       `json:"code"`
	CreatedAt  time.Time `json:"created_at"`
	ExtraRate  *float32  `json:"extra_rate,omitempty"`
	ExtraValue float32   `json:"extra_value"`
	Included   bool      `json:"included"`
	Label      string    `json:"label"`
	Rate       float32   `json:"rate"`
	Symbol     string    `json:"symbol"`
	Value      float32   `json:"value"`
}

// CalculatedReceiptSellPayload defines model for CalculatedReceiptSellPayload.
type CalculatedReceiptSellPayload struct {
	Barcode         *string                                                               `json:"barcode,omitempty"`
	CashierName     *string                                                               `json:"cashier_name,omitempty"`
	Context         *map[string]CalculatedReceiptSellPayload_Context_AdditionalProperties `json:"context,omitempty"`
	Custom          *ReceiptConfigPayload                                                 `json:"custom,omitempty"`
	Delivery        *DeliveryPayload                                                      `json:"delivery,omitempty"`
	Departament     *string                                                               `json:"departament,omitempty"`
	Discounts       *[]CalculatedDiscountPayload                                          `json:"discounts,omitempty"`
	FiscalCode      string                                                                `json:"fiscal_code"`
	FiscalDate      time.Time                                                             `json:"fiscal_date"`
	Footer          *string                                                               `json:"footer,omitempty"`
	Goods           []CalculatedGoodItemPayload                                           `json:"goods"`
	Header          *string                                                               `json:"header,omitempty"`
	Id              *openapi_types.UUID                                                   `json:"id,omitempty"`
	IsSell          *bool                                                                 `json:"is_sell,omitempty"`
	Payments        []CalculatedReceiptSellPayload_Payments_Item                          `json:"payments"`
	RoundSum        *float32                                                              `json:"round_sum,omitempty"`
	Taxes           []CalculatedReceiptTaxPayload                                         `json:"taxes"`
	TechnicalReturn *bool                                                                 `json:"technical_return,omitempty"`
	TotalPayment    float32                                                               `json:"total_payment"`
	TotalRest       float32                                                               `json:"total_rest"`
	TotalSum        float32                                                               `json:"total_sum"`
}

// CalculatedReceiptSellPayloadContext0 defines model for .
type CalculatedReceiptSellPayloadContext0 = string

// CalculatedReceiptSellPayloadContext1 defines model for .
type CalculatedReceiptSellPayloadContext1 = int

// CalculatedReceiptSellPayloadContext2 defines model for .
type CalculatedReceiptSellPayloadContext2 = float32

// CalculatedReceiptSellPayloadContext3 defines model for .
type CalculatedReceiptSellPayloadContext3 = bool

// CalculatedReceiptSellPayload_Context_AdditionalProperties defines model for CalculatedReceiptSellPayload.context.AdditionalProperties.
type CalculatedReceiptSellPayload_Context_AdditionalProperties struct {
	union json.RawMessage
}

// CalculatedReceiptSellPayload_Payments_Item defines model for CalculatedReceiptSellPayload.payments.Item.
type CalculatedReceiptSellPayload_Payments_Item struct {
	union json.RawMessage
}

// CalculatedReceiptTaxPayload defines model for CalculatedReceiptTaxPayload.
type CalculatedReceiptTaxPayload struct {
	Code            int                 `json:"code"`
	CreatedAt       time.Time           `json:"created_at"`
	ExtraRate       *float32            `json:"extra_rate,omitempty"`
	ExtraValue      float32             `json:"extra_value"`
	Id              *openapi_types.UUID `json:"id,omitempty"`
	Included        bool                `json:"included"`
	Label           string              `json:"label"`
	NoVat           *bool               `json:"no_vat,omitempty"`
	Rate            float32             `json:"rate"`
	ReturnsTurnover *float32            `json:"returns_turnover,omitempty"`
	SalesTurnover   *float32            `json:"sales_turnover,omitempty"`
	Symbol          string              `json:"symbol"`
	Value           float32             `json:"value"`
}

// CardPaymentPayload defines model for CardPaymentPayload.
type CardPaymentPayload struct {
	AcquirerAndSeller *string      `json:"acquirer_and_seller,omitempty"`
	Acquiring         *string      `json:"acquiring,omitempty"`
	AuthCode          *string      `json:"auth_code,omitempty"`
	BankName          *string      `json:"bank_name,omitempty"`
	CardMask          *string      `json:"card_mask,omitempty"`
	Code              *int         `json:"code,omitempty"`
	Commission        *int         `json:"commission,omitempty"`
	Label             *string      `json:"label,omitempty"`
	OwnerName         *string      `json:"owner_name,omitempty"`
	PawnshopIsReturn  *bool        `json:"pawnshop_is_return,omitempty"`
	PaymentSystem     *string      `json:"payment_system,omitempty"`
	ReceiptNo         *string      `json:"receipt_no,omitempty"`
	Rrn               *string      `json:"rrn,omitempty"`
	SignatureRequired *bool        `json:"signature_required,omitempty"`
	Terminal          *string      `json:"terminal,omitempty"`
	Type              *PaymentType `json:"type,omitempty"`
	Value             int          `json:"value"`
}

// CashPaymentPayload defines model for CashPaymentPayload.
type CashPaymentPayload struct {
	Label            *string      `json:"label,omitempty"`
	PawnshopIsReturn *bool        `json:"pawnshop_is_return,omitempty"`
	Type             *PaymentType `json:"type,omitempty"`
	Value            int          `json:"value"`
}

// CashRegisterDeviceModel defines model for CashRegisterDeviceModel.
type CashRegisterDeviceModel struct {
	Address          string              `json:"address"`
	CreatedAt        time.Time           `json:"created_at"`
	DocumentsState   DocumentsStateModel `json:"documents_state"`
	EmergencyDate    *time.Time          `json:"emergency_date,omitempty"`
	EmergencyDetails *string             `json:"emergency_details,omitempty"`
	FiscalNumber     string              `json:"fiscal_number"`
	HasShift         bool                `json:"has_shift"`
	Id               openapi_types.UUID  `json:"id"`
	Number           *string             `json:"number,omitempty"`
	OfflineMode      bool                `json:"offline_mode"`
	StayOffline      bool                `json:"stay_offline"`
	Title            string              `json:"title"`
	UpdatedAt        *time.Time          `json:"updated_at,omitempty"`
}

// CashRegisterModel defines model for CashRegisterModel.
type CashRegisterModel struct {
	Active       bool               `json:"active"`
	CreatedAt    time.Time          `json:"created_at"`
	FiscalNumber string             `json:"fiscal_number"`
	Id           openapi_types.UUID `json:"id"`
	Number       *string            `json:"number,omitempty"`
	UpdatedAt    *time.Time         `json:"updated_at,omitempty"`
}

// CashRegisterOfflineTime defines model for CashRegisterOfflineTime.
type CashRegisterOfflineTime struct {
	Sessions *[]CashRegisterOfflineTimeSession `json:"sessions,omitempty"`
	Status   *CashRegisterOfflineTimeStatus    `json:"status,omitempty"`
}

// CashRegisterOfflineTimeSession defines model for CashRegisterOfflineTimeSession.
type CashRegisterOfflineTimeSession struct {
	Duration *int       `json:"duration,omitempty"`
	End      *time.Time `json:"end,omitempty"`
	Start    *time.Time `json:"start,omitempty"`
}

// CashRegisterOfflineTimeStatus defines model for CashRegisterOfflineTimeStatus.
type CashRegisterOfflineTimeStatus struct {
	Current *int `json:"current,omitempty"`
	Total   *int `json:"total,omitempty"`
}

// CashWithdrawalReceiptPayload defines model for CashWithdrawalReceiptPayload.
type CashWithdrawalReceiptPayload struct {
	Barcode     *string                                                               `json:"barcode,omitempty"`
	CashierName *string                                                               `json:"cashier_name,omitempty"`
	Context     *map[string]CashWithdrawalReceiptPayload_Context_AdditionalProperties `json:"context,omitempty"`
	Delivery    *DeliveryPayload                                                      `json:"delivery,omitempty"`
	Departament *string                                                               `json:"departament,omitempty"`
	FiscalCode  *string                                                               `json:"fiscal_code,omitempty"`
	FiscalDate  *time.Time                                                            `json:"fiscal_date,omitempty"`
	Footer      *string                                                               `json:"footer,omitempty"`
	Header      *string                                                               `json:"header,omitempty"`
	Id          *openapi_types.UUID                                                   `json:"id,omitempty"`
	Payment     CardPaymentPayload                                                    `json:"payment"`

	// PreviousReceiptId id попереднього фіскального чеку (використовується опціонально для контролю послідовності)
	PreviousReceiptId *openapi_types.UUID `json:"previous_receipt_id,omitempty"`
}

// CashWithdrawalReceiptPayloadContext0 defines model for .
type CashWithdrawalReceiptPayloadContext0 = string

// CashWithdrawalReceiptPayloadContext1 defines model for .
type CashWithdrawalReceiptPayloadContext1 = int

// CashWithdrawalReceiptPayloadContext2 defines model for .
type CashWithdrawalReceiptPayloadContext2 = float32

// CashWithdrawalReceiptPayloadContext3 defines model for .
type CashWithdrawalReceiptPayloadContext3 = bool

// CashWithdrawalReceiptPayload_Context_AdditionalProperties defines model for CashWithdrawalReceiptPayload.context.AdditionalProperties.
type CashWithdrawalReceiptPayload_Context_AdditionalProperties struct {
	union json.RawMessage
}

// CashierAccessTokenResponseModel defines model for CashierAccessTokenResponseModel.
type CashierAccessTokenResponseModel struct {
	AccessToken string  `json:"access_token"`
	TokenType   *string `json:"token_type,omitempty"`
	Type        *string `json:"type,omitempty"`
}

// CashierModel defines model for CashierModel.
type CashierModel struct {
	Blocked        *string                  `json:"blocked,omitempty"`
	CertificateEnd *time.Time               `json:"certificate_end,omitempty"`
	CreatedAt      time.Time                `json:"created_at"`
	FullName       string                   `json:"full_name"`
	Id             openapi_types.UUID       `json:"id"`
	KeyId          string                   `json:"key_id"`
	Nin            string                   `json:"nin"`
	Permissions    *CashierPermissionsModel `json:"permissions,omitempty"`

	// SignatureType An enumeration.
	SignatureType SignatureType `json:"signature_type"`
	UpdatedAt     *time.Time    `json:"updated_at,omitempty"`
}

// CashierPermissionsModel defines model for CashierPermissionsModel.
type CashierPermissionsModel struct {
	Orders *bool `json:"orders,omitempty"`
}

// CashierSignIn defines model for CashierSignIn.
type CashierSignIn struct {
	Login    string `json:"login"`
	Password string `json:"password"`
}

// CashierSignInPinCode defines model for CashierSignInPinCode.
type CashierSignInPinCode struct {
	PinCode string `json:"pin_code"`
}

// CashierSignatureStatus defines model for CashierSignatureStatus.
type CashierSignatureStatus struct {
	Online               bool `json:"online"`
	ShiftOpenPossibility bool `json:"shift_open_possibility"`

	// Type An enumeration.
	Type SignatureType `json:"type"`
}

// CheckStatusResponseSchema defines model for CheckStatusResponseSchema.
type CheckStatusResponseSchema struct {
	ChunksCount *int                   `json:"chunks_count,omitempty"`
	Errors      *[]OperationErrorModel `json:"errors,omitempty"`
	Status      string                 `json:"status"`
	TaskId      openapi_types.UUID     `json:"task_id"`
}

// CloseShiftPayload defines model for CloseShiftPayload.
type CloseShiftPayload struct {
	FiscalCode          *string        `json:"fiscal_code,omitempty"`
	FiscalDate          *time.Time     `json:"fiscal_date,omitempty"`
	Report              *ReportPayload `json:"report,omitempty"`
	SkipClientNameCheck *bool          `json:"skip_client_name_check,omitempty"`
}

// CreateOrderModel defines model for CreateOrderModel.
type CreateOrderModel struct {
	CashierId *string `json:"cashier_id,omitempty"`

	// CustomStatus An enumeration.
	CustomStatus    *CustomOrderStatus         `json:"custom_status,omitempty"`
	DeliveryDetails *OrderDeliveryDetailsModel `json:"delivery_details,omitempty"`
	Id              *openapi_types.UUID        `json:"id,omitempty"`
	NotFiscalize    *bool                      `json:"not_fiscalize,omitempty"`
	OrderId         *string                    `json:"order_id,omitempty"`

	// PaymentMethod An enumeration.
	PaymentMethod *OrderPaymentEnum `json:"payment_method,omitempty"`
	ReceiptDraft  OrderReceiptModel `json:"receipt_draft"`
	StockCode     *string           `json:"stock_code,omitempty"`
}

// CreateShiftPayload defines model for CreateShiftPayload.
type CreateShiftPayload struct {
	FiscalCode *string             `json:"fiscal_code,omitempty"`
	FiscalDate *time.Time          `json:"fiscal_date,omitempty"`
	Id         *openapi_types.UUID `json:"id,omitempty"`
}

// CurrencyExchangePayload defines model for CurrencyExchangePayload.
type CurrencyExchangePayload struct {
	Buy        *CurrencyPayload    `json:"buy,omitempty"`
	ClientInfo *string             `json:"client_info,omitempty"`
	Commission *float32            `json:"commission,omitempty"`
	Delivery   *DeliveryPayload    `json:"delivery,omitempty"`
	FiscalCode *string             `json:"fiscal_code,omitempty"`
	FiscalDate *time.Time          `json:"fiscal_date,omitempty"`
	Footer     *string             `json:"footer,omitempty"`
	Header     *string             `json:"header,omitempty"`
	Id         *openapi_types.UUID `json:"id,omitempty"`
	Reversal   *bool               `json:"reversal,omitempty"`
	Sell       *CurrencyPayload    `json:"sell,omitempty"`

	// Type An enumeration.
	Type CurrencyExchangeType `json:"type"`
}

// CurrencyExchangeSchema defines model for CurrencyExchangeSchema.
type CurrencyExchangeSchema struct {
	Buy        *CurrencySchema `json:"buy,omitempty"`
	ClientInfo *string         `json:"client_info,omitempty"`
	Commission *float32        `json:"commission,omitempty"`
	Cross      *float32        `json:"cross,omitempty"`
	Reversal   *bool           `json:"reversal,omitempty"`
	Sell       *CurrencySchema `json:"sell,omitempty"`

	// Type An enumeration.
	Type CurrencyExchangeType `json:"type"`
}

// CurrencyExchangeType An enumeration.
type CurrencyExchangeType string

// CurrencyPayload defines model for CurrencyPayload.
type CurrencyPayload struct {
	Currency string   `json:"currency"`
	Value    *float32 `json:"value,omitempty"`
}

// CurrencyRateModel defines model for CurrencyRateModel.
type CurrencyRateModel struct {
	Active     bool       `json:"active"`
	Buy        float32    `json:"buy"`
	BuySum     *int       `json:"buy_sum,omitempty"`
	Code       string     `json:"code"`
	CreatedAt  time.Time  `json:"created_at"`
	Name       string     `json:"name"`
	Regulator  float32    `json:"regulator"`
	Sell       float32    `json:"sell"`
	SellSum    *int       `json:"sell_sum,omitempty"`
	SymbolCode string     `json:"symbol_code"`
	UpdatedAt  *time.Time `json:"updated_at,omitempty"`
}

// CurrencyRatePayload defines model for CurrencyRatePayload.
type CurrencyRatePayload struct {
	Buy        float32    `json:"buy"`
	Code       string     `json:"code"`
	CreatedAt  *time.Time `json:"created_at,omitempty"`
	Name       *string    `json:"name,omitempty"`
	Regulator  float32    `json:"regulator"`
	Sell       float32    `json:"sell"`
	SymbolCode *string    `json:"symbol_code,omitempty"`
}

// CurrencySchema defines model for CurrencySchema.
type CurrencySchema struct {
	Currency string            `json:"currency"`
	Rate     CurrencyRateModel `json:"rate"`
	Value    *float32          `json:"value,omitempty"`
}

// CustomOrderStatus An enumeration.
type CustomOrderStatus string

// DeleteIntegrationSchema defines model for DeleteIntegrationSchema.
type DeleteIntegrationSchema struct {
	Ok bool `json:"ok"`
}

// DeleteWebhookSchema defines model for DeleteWebhookSchema.
type DeleteWebhookSchema struct {
	Ok bool `json:"ok"`
}

// DeliveryPayload defines model for DeliveryPayload.
type DeliveryPayload struct {
	Email  *openapi_types.Email   `json:"email,omitempty"`
	Emails *[]openapi_types.Email `json:"emails,omitempty"`
	Phone  *string                `json:"phone,omitempty"`
}

// DetailedCashRegisterModel defines model for DetailedCashRegisterModel.
type DetailedCashRegisterModel struct {
	Active       bool                   `json:"active"`
	Address      *string                `json:"address,omitempty"`
	Branch       *BranchModel           `json:"branch,omitempty"`
	CreatedAt    time.Time              `json:"created_at"`
	FiscalNumber string                 `json:"fiscal_number"`
	Id           openapi_types.UUID     `json:"id"`
	Number       *string                `json:"number,omitempty"`
	OfflineMode  *bool                  `json:"offline_mode,omitempty"`
	Shift        *ShiftWithCashierModel `json:"shift,omitempty"`
	StayOffline  *bool                  `json:"stay_offline,omitempty"`
	UpdatedAt    *time.Time             `json:"updated_at,omitempty"`
}

// DetailedCashierModel defines model for DetailedCashierModel.
type DetailedCashierModel struct {
	Blocked        *string                  `json:"blocked,omitempty"`
	CertificateEnd *time.Time               `json:"certificate_end,omitempty"`
	CreatedAt      time.Time                `json:"created_at"`
	FullName       string                   `json:"full_name"`
	Id             openapi_types.UUID       `json:"id"`
	KeyId          string                   `json:"key_id"`
	Nin            string                   `json:"nin"`
	Organization   OrganizationModel        `json:"organization"`
	Permissions    *CashierPermissionsModel `json:"permissions,omitempty"`

	// SignatureType An enumeration.
	SignatureType SignatureType `json:"signature_type"`
	UpdatedAt     *time.Time    `json:"updated_at,omitempty"`
}

// DetailedOfflineFiscalCodeModel defines model for DetailedOfflineFiscalCodeModel.
type DetailedOfflineFiscalCodeModel struct {
	CashRegisterId openapi_types.UUID `json:"cash_register_id"`
	CreatedAt      time.Time          `json:"created_at"`
	FiscalCode     string             `json:"fiscal_code"`
	SerialId       int                `json:"serial_id"`
}

// DiscountMode An enumeration.
type DiscountMode string

// DiscountModel defines model for DiscountModel.
type DiscountModel struct {
	Mode     DiscountMode            `json:"mode"`
	Name     *string                 `json:"name,omitempty"`
	Sum      int                     `json:"sum"`
	TaxCode  *DiscountModel_TaxCode  `json:"tax_code,omitempty"`
	TaxCodes *DiscountModel_TaxCodes `json:"tax_codes,omitempty"`
	Type     DiscountType            `json:"type"`
	Value    float32                 `json:"value"`
}

// DiscountModelTaxCode0 defines model for .
type DiscountModelTaxCode0 = int

// DiscountModelTaxCode1 defines model for .
type DiscountModelTaxCode1 = string

// DiscountModel_TaxCode defines model for DiscountModel.TaxCode.
type DiscountModel_TaxCode struct {
	union json.RawMessage
}

// DiscountModelTaxCodes0 defines model for .
type DiscountModelTaxCodes0 = []int

// DiscountModelTaxCodes1 defines model for .
type DiscountModelTaxCodes1 = []string

// DiscountModel_TaxCodes defines model for DiscountModel.TaxCodes.
type DiscountModel_TaxCodes struct {
	union json.RawMessage
}

// DiscountPayload defines model for DiscountPayload.
type DiscountPayload struct {
	Mode     DiscountMode              `json:"mode"`
	Name     *string                   `json:"name,omitempty"`
	TaxCode  *DiscountPayload_TaxCode  `json:"tax_code,omitempty"`
	TaxCodes *DiscountPayload_TaxCodes `json:"tax_codes,omitempty"`
	Type     DiscountType              `json:"type"`
	Value    float32                   `json:"value"`
}

// DiscountPayloadTaxCode0 defines model for .
type DiscountPayloadTaxCode0 = int

// DiscountPayloadTaxCode1 defines model for .
type DiscountPayloadTaxCode1 = string

// DiscountPayload_TaxCode defines model for DiscountPayload.TaxCode.
type DiscountPayload_TaxCode struct {
	union json.RawMessage
}

// DiscountPayloadTaxCodes0 defines model for .
type DiscountPayloadTaxCodes0 = []int

// DiscountPayloadTaxCodes1 defines model for .
type DiscountPayloadTaxCodes1 = []string

// DiscountPayload_TaxCodes defines model for DiscountPayload.TaxCodes.
type DiscountPayload_TaxCodes struct {
	union json.RawMessage
}

// DiscountType An enumeration.
type DiscountType string

// DocumentsStateModel defines model for DocumentsStateModel.
type DocumentsStateModel struct {
	LastReceiptCode int `json:"last_receipt_code"`
	LastReportCode  int `json:"last_report_code"`
	LastZReportCode int `json:"last_z_report_code"`
}

// ExportExtensionType An enumeration.
type ExportExtensionType = interface{}

// ExtendedReportFiltersPayload defines model for ExtendedReportFiltersPayload.
type ExtendedReportFiltersPayload struct {
	BranchId       *[]openapi_types.UUID `json:"branch_id,omitempty"`
	CashRegisterId *[]openapi_types.UUID `json:"cash_register_id,omitempty"`
	FromDate       time.Time             `json:"from_date"`
	ToDate         time.Time             `json:"to_date"`
}

// GoOfflinePayload defines model for GoOfflinePayload.
type GoOfflinePayload struct {
	FiscalCode    *string    `json:"fiscal_code,omitempty"`
	GoOfflineDate *time.Time `json:"go_offline_date,omitempty"`
}

// GoodDetailsPayload defines model for GoodDetailsPayload.
type GoodDetailsPayload struct {
	Barcode        *string                 `json:"barcode,omitempty"`
	Code           string                  `json:"code"`
	ExciseBarcode  *string                 `json:"excise_barcode,omitempty"`
	ExciseBarcodes *[]string               `json:"excise_barcodes,omitempty"`
	Footer         *string                 `json:"footer,omitempty"`
	Header         *string                 `json:"header,omitempty"`
	Name           string                  `json:"name"`
	Price          int                     `json:"price"`
	Tax            *GoodDetailsPayload_Tax `json:"tax,omitempty"`
	Uktzed         *string                 `json:"uktzed,omitempty"`
}

// GoodDetailsPayloadTax0 defines model for .
type GoodDetailsPayloadTax0 = []int

// GoodDetailsPayloadTax1 defines model for .
type GoodDetailsPayloadTax1 = []string

// GoodDetailsPayload_Tax defines model for GoodDetailsPayload.Tax.
type GoodDetailsPayload_Tax struct {
	union json.RawMessage
}

// GoodItemModel defines model for GoodItemModel.
type GoodItemModel struct {
	Discounts *[]DiscountModel                 `json:"discounts,omitempty"`
	Good      SrsoSchemaReceiptSchemaGoodModel `json:"good"`
	GoodId    *openapi_types.UUID              `json:"good_id,omitempty"`
	IsReturn  bool                             `json:"is_return"`
	Quantity  int                              `json:"quantity"`
	Sum       int                              `json:"sum"`
	Taxes     []GoodTax                        `json:"taxes"`
}

// GoodItemPayload defines model for GoodItemPayload.
type GoodItemPayload struct {
	Discounts *[]DiscountPayload `json:"discounts,omitempty"`

	// Good Інформація про товар
	Good             GoodDetailsPayload  `json:"good"`
	GoodId           *openapi_types.UUID `json:"good_id,omitempty"`
	IsReturn         *bool               `json:"is_return,omitempty"`
	IsWinningsPayout *bool               `json:"is_winnings_payout,omitempty"`
	Quantity         int                 `json:"quantity"`
}

// GoodModelBase defines model for GoodModelBase.
type GoodModelBase struct {
	Barcode   *string            `json:"barcode,omitempty"`
	Code      string             `json:"code"`
	CreatedAt time.Time          `json:"created_at"`
	Id        openapi_types.UUID `json:"id"`
	Name      string             `json:"name"`
	Price     int                `json:"price"`
	Taxes     []TaxModel         `json:"taxes"`
	Uktzed    *string            `json:"uktzed,omitempty"`
	UpdatedAt *time.Time         `json:"updated_at,omitempty"`
}

// GoodTax defines model for GoodTax.
type GoodTax struct {
	AdvancedCode *string            `json:"advanced_code,omitempty"`
	Code         int                `json:"code"`
	CreatedAt    time.Time          `json:"created_at"`
	ExtraRate    *int               `json:"extra_rate,omitempty"`
	ExtraValue   int                `json:"extra_value"`
	Id           openapi_types.UUID `json:"id"`
	Included     bool               `json:"included"`
	Label        string             `json:"label"`
	NoVat        *bool              `json:"no_vat,omitempty"`
	Rate         int                `json:"rate"`
	Symbol       string             `json:"symbol"`
	UpdatedAt    *time.Time         `json:"updated_at,omitempty"`
	Value        int                `json:"value"`
}

// GoodsIntegrationOrdering An enumeration.
type GoodsIntegrationOrdering string

// HTTPError defines model for HTTPError.
type HTTPError struct {
	// Message Detailed error message
	Message string `json:"message"`
}

// HTTPValidationError defines model for HTTPValidationError.
type HTTPValidationError struct {
	Detail *[]ValidationError `json:"detail,omitempty"`

	// Message Detailed error message
	Message string `json:"message"`
}

// IntegrationEditOrderReceiptSchema defines model for IntegrationEditOrderReceiptSchema.
type IntegrationEditOrderReceiptSchema struct {
	AdditionalGoods *[]OrderGoodItemModel                              `json:"additional_goods,omitempty"`
	Barcode         *string                                            `json:"barcode,omitempty"`
	CashierName     *string                                            `json:"cashier_name,omitempty"`
	Delivery        *DeliveryPayload                                   `json:"delivery,omitempty"`
	Departament     *string                                            `json:"departament,omitempty"`
	Discounts       *[]DiscountPayload                                 `json:"discounts,omitempty"`
	Footer          *string                                            `json:"footer,omitempty"`
	Goods           []OrderGoodItemModel                               `json:"goods"`
	Header          *string                                            `json:"header,omitempty"`
	Id              openapi_types.UUID                                 `json:"id"`
	OrderId         string                                             `json:"order_id"`
	Payments        *[]IntegrationEditOrderReceiptSchema_Payments_Item `json:"payments,omitempty"`
	Type            *ReceiptType                                       `json:"type,omitempty"`
}

// IntegrationEditOrderReceiptSchema_Payments_Item defines model for IntegrationEditOrderReceiptSchema.payments.Item.
type IntegrationEditOrderReceiptSchema_Payments_Item struct {
	union json.RawMessage
}

// IntegrationInfoResponseSchema defines model for IntegrationInfoResponseSchema.
type IntegrationInfoResponseSchema struct {
	CreatedAt        time.Time  `json:"created_at"`
	Key              string     `json:"key"`
	LastErrorDate    *time.Time `json:"last_error_date,omitempty"`
	LastErrorMessage *string    `json:"last_error_message,omitempty"`
	UpdatedAt        *time.Time `json:"updated_at,omitempty"`
	Url              string     `json:"url"`
}

// IntegrationInfoSchema defines model for IntegrationInfoSchema.
type IntegrationInfoSchema struct {
	CreatedAt        time.Time  `json:"created_at"`
	LastErrorDate    *time.Time `json:"last_error_date,omitempty"`
	LastErrorMessage *string    `json:"last_error_message,omitempty"`
	UpdatedAt        *time.Time `json:"updated_at,omitempty"`
	Url              string     `json:"url"`
}

// NotificationPayload defines model for NotificationPayload.
type NotificationPayload struct {
	Ok bool `json:"ok"`
}

// ObsoleteCardPaymentPayload defines model for ObsoleteCardPaymentPayload.
type ObsoleteCardPaymentPayload struct {
	AcquirerAndSeller *string      `json:"acquirer_and_seller,omitempty"`
	Acquiring         *string      `json:"acquiring,omitempty"`
	AuthCode          *string      `json:"auth_code,omitempty"`
	BankName          *string      `json:"bank_name,omitempty"`
	CardMask          *string      `json:"card_mask,omitempty"`
	Code              *int         `json:"code,omitempty"`
	Commission        *int         `json:"commission,omitempty"`
	Label             *string      `json:"label,omitempty"`
	OwnerName         *string      `json:"owner_name,omitempty"`
	PawnshopIsReturn  *bool        `json:"pawnshop_is_return,omitempty"`
	PaymentSystem     *string      `json:"payment_system,omitempty"`
	ReceiptNo         *string      `json:"receipt_no,omitempty"`
	Rrn               *string      `json:"rrn,omitempty"`
	SignatureRequired *bool        `json:"signature_required,omitempty"`
	Terminal          *string      `json:"terminal,omitempty"`
	Type              *PaymentType `json:"type,omitempty"`
	Value             int          `json:"value"`
}

// OfflineCodesCountSchema defines model for OfflineCodesCountSchema.
type OfflineCodesCountSchema struct {
	// Available Доступна кількість
	Available *int `json:"available,omitempty"`

	// Default Кількість кодів що запитується автоматично сервером CheckBox
	Default *int `json:"default,omitempty"`

	// Minimal Мінімальна кількість кодів при досягненні якої виконується отримання нових кодів
	Minimal *int `json:"minimal,omitempty"`

	// Used Кількість кодів, що відмічені використаними. Лічильник зкидається при отриманні нових кодів.
	Used *int `json:"used,omitempty"`
}

// OfflineReceiptSellPayload defines model for OfflineReceiptSellPayload.
type OfflineReceiptSellPayload struct {
	Barcode     *string                                                            `json:"barcode,omitempty"`
	CashierName *string                                                            `json:"cashier_name,omitempty"`
	Context     *map[string]OfflineReceiptSellPayload_Context_AdditionalProperties `json:"context,omitempty"`
	Custom      *ReceiptConfigPayload                                              `json:"custom,omitempty"`
	Delivery    *DeliveryPayload                                                   `json:"delivery,omitempty"`
	Departament *string                                                            `json:"departament,omitempty"`
	Discounts   *[]DiscountPayload                                                 `json:"discounts,omitempty"`
	FiscalCode  string                                                             `json:"fiscal_code"`
	FiscalDate  time.Time                                                          `json:"fiscal_date"`
	Footer      *string                                                            `json:"footer,omitempty"`
	Goods       []GoodItemPayload                                                  `json:"goods"`
	Header      *string                                                            `json:"header,omitempty"`
	Id          *openapi_types.UUID                                                `json:"id,omitempty"`
	IsPawnshop  *bool                                                              `json:"is_pawnshop,omitempty"`
	OrderId     *openapi_types.UUID                                                `json:"order_id,omitempty"`
	Payments    *[]OfflineReceiptSellPayload_Payments_Item                         `json:"payments,omitempty"`

	// PreviousReceiptId id попереднього фіскального чеку (використовується опціонально для контролю послідовності)
	PreviousReceiptId *openapi_types.UUID `json:"previous_receipt_id,omitempty"`
	RelatedReceiptId  *openapi_types.UUID `json:"related_receipt_id,omitempty"`
	Rounding          *bool               `json:"rounding,omitempty"`
	TechnicalReturn   *bool               `json:"technical_return,omitempty"`
}

// OfflineReceiptSellPayloadContext0 defines model for .
type OfflineReceiptSellPayloadContext0 = string

// OfflineReceiptSellPayloadContext1 defines model for .
type OfflineReceiptSellPayloadContext1 = int

// OfflineReceiptSellPayloadContext2 defines model for .
type OfflineReceiptSellPayloadContext2 = float32

// OfflineReceiptSellPayloadContext3 defines model for .
type OfflineReceiptSellPayloadContext3 = bool

// OfflineReceiptSellPayload_Context_AdditionalProperties defines model for OfflineReceiptSellPayload.context.AdditionalProperties.
type OfflineReceiptSellPayload_Context_AdditionalProperties struct {
	union json.RawMessage
}

// OfflineReceiptSellPayload_Payments_Item defines model for OfflineReceiptSellPayload.payments.Item.
type OfflineReceiptSellPayload_Payments_Item struct {
	union json.RawMessage
}

// OperationBaseResponseSchema defines model for OperationBaseResponseSchema.
type OperationBaseResponseSchema struct {
	ChunksCount *int               `json:"chunks_count,omitempty"`
	Status      string             `json:"status"`
	TaskId      openapi_types.UUID `json:"task_id"`
}

// OperationErrorModel defines model for OperationErrorModel.
type OperationErrorModel struct {
	Address string `json:"address"`
	Error   string `json:"error"`
}

// OrderDeliveryDetailsModel defines model for OrderDeliveryDetailsModel.
type OrderDeliveryDetailsModel struct {
	Address           AddressModel `json:"address"`
	BoxId             int          `json:"box_id"`
	ClientComment     string       `json:"client_comment"`
	ClientName        string       `json:"client_name"`
	ClientPhoneNumber string       `json:"client_phone_number"`
	DeliveryTime      time.Time    `json:"delivery_time"`
	ThermalDependence bool         `json:"thermal_dependence"`
}

// OrderGoodDetailsModel defines model for OrderGoodDetailsModel.
type OrderGoodDetailsModel struct {
	Barcode        *string                    `json:"barcode,omitempty"`
	Code           string                     `json:"code"`
	ExciseBarcode  *string                    `json:"excise_barcode,omitempty"`
	ExciseBarcodes *[]string                  `json:"excise_barcodes,omitempty"`
	Footer         *string                    `json:"footer,omitempty"`
	Header         *string                    `json:"header,omitempty"`
	Name           string                     `json:"name"`
	Price          int                        `json:"price"`
	Tax            *OrderGoodDetailsModel_Tax `json:"tax,omitempty"`
	Uktzed         *string                    `json:"uktzed,omitempty"`
}

// OrderGoodDetailsModelTax0 defines model for .
type OrderGoodDetailsModelTax0 = []int

// OrderGoodDetailsModelTax1 defines model for .
type OrderGoodDetailsModelTax1 = []string

// OrderGoodDetailsModel_Tax defines model for OrderGoodDetailsModel.Tax.
type OrderGoodDetailsModel_Tax struct {
	union json.RawMessage
}

// OrderGoodItemModel defines model for OrderGoodItemModel.
type OrderGoodItemModel struct {
	Discounts *[]DiscountPayload `json:"discounts,omitempty"`

	// Good Інформація про товар
	Good     *OrderGoodDetailsModel `json:"good,omitempty"`
	GoodId   *openapi_types.UUID    `json:"good_id,omitempty"`
	IsReturn *bool                  `json:"is_return,omitempty"`
	Quantity int                    `json:"quantity"`
}

// OrderModel defines model for OrderModel.
type OrderModel struct {
	CreatedAt time.Time `json:"created_at"`

	// CustomStatus An enumeration.
	CustomStatus    *CustomOrderStatus         `json:"custom_status,omitempty"`
	DeliveryDetails *OrderDeliveryDetailsModel `json:"delivery_details,omitempty"`
	Id              openapi_types.UUID         `json:"id"`
	IsPaid          bool                       `json:"is_paid"`
	NotFiscalize    *bool                      `json:"not_fiscalize,omitempty"`
	OrderId         *string                    `json:"order_id,omitempty"`

	// PaymentMethod An enumeration.
	PaymentMethod *OrderPaymentEnum `json:"payment_method,omitempty"`
	ReceiptDraft  OrderReceiptModel `json:"receipt_draft"`

	// Status An enumeration.
	Status    OrderStatus `json:"status"`
	StockCode *string     `json:"stock_code,omitempty"`
	UpdatedAt *time.Time  `json:"updated_at,omitempty"`
}

// OrderPaymentEnum An enumeration.
type OrderPaymentEnum string

// OrderReceiptModel defines model for OrderReceiptModel.
type OrderReceiptModel struct {
	AdditionalGoods *[]OrderGoodItemModel              `json:"additional_goods,omitempty"`
	Barcode         *string                            `json:"barcode,omitempty"`
	CashierName     *string                            `json:"cashier_name,omitempty"`
	Delivery        *DeliveryPayload                   `json:"delivery,omitempty"`
	Departament     *string                            `json:"departament,omitempty"`
	Discounts       *[]DiscountPayload                 `json:"discounts,omitempty"`
	Footer          *string                            `json:"footer,omitempty"`
	Goods           []OrderGoodItemModel               `json:"goods"`
	Header          *string                            `json:"header,omitempty"`
	Payments        *[]OrderReceiptModel_Payments_Item `json:"payments,omitempty"`
	Type            *ReceiptType                       `json:"type,omitempty"`
}

// OrderReceiptModel_Payments_Item defines model for OrderReceiptModel.payments.Item.
type OrderReceiptModel_Payments_Item struct {
	union json.RawMessage
}

// OrderStatus An enumeration.
type OrderStatus string

// OrderUpdateSchema defines model for OrderUpdateSchema.
type OrderUpdateSchema struct {
	Order OrderModel `json:"order"`
}

// OrganizationBillingSchema Response model for sms-billing endpoint
type OrganizationBillingSchema struct {
	Balance        *int `json:"balance,omitempty"`
	BillingEnabled bool `json:"billing_enabled"`
	CanSendSms     bool `json:"can_send_sms"`
}

// OrganizationModel defines model for OrganizationModel.
type OrganizationModel struct {
	CanSendSms                *bool               `json:"can_send_sms,omitempty"`
	ConcordLogin              *string             `json:"concord_login,omitempty"`
	ConcordUid                *string             `json:"concord_uid,omitempty"`
	CreatedAt                 time.Time           `json:"created_at"`
	Edrpou                    string              `json:"edrpou"`
	Id                        openapi_types.UUID  `json:"id"`
	ReceiptsRatelimitCount    *int                `json:"receipts_ratelimit_count,omitempty"`
	ReceiptsRatelimitInterval *int                `json:"receipts_ratelimit_interval,omitempty"`
	SubscriptionExp           *openapi_types.Date `json:"subscription_exp,omitempty"`
	TaxNumber                 string              `json:"tax_number"`
	Title                     string              `json:"title"`
	UpdatedAt                 *time.Time          `json:"updated_at,omitempty"`
}

// OrganizationReceiptConfigSchema defines model for OrganizationReceiptConfigSchema.
type OrganizationReceiptConfigSchema struct {
	EmailSubject        *string                `json:"email_subject,omitempty"`
	HtmlBodyStyle       *string                `json:"html_body_style,omitempty"`
	HtmlGlobalFooter    *string                `json:"html_global_footer,omitempty"`
	HtmlGlobalHeader    *string                `json:"html_global_header,omitempty"`
	HtmlLightBlockStyle *string                `json:"html_light_block_style,omitempty"`
	HtmlReceiptStyle    *string                `json:"html_receipt_style,omitempty"`
	HtmlRulerStyle      *string                `json:"html_ruler_style,omitempty"`
	HtmlTitle           *string                `json:"html_title,omitempty"`
	Organization        ShortOrganizationModel `json:"organization"`
	TextGlobalFooter    *string                `json:"text_global_footer,omitempty"`
	TextGlobalHeader    *string                `json:"text_global_header,omitempty"`
}

// PaginatedResultDetailedCashRegisterModel Пагінований результат
type PaginatedResultDetailedCashRegisterModel struct {
	Meta    PaginationMeta              `json:"meta"`
	Results []DetailedCashRegisterModel `json:"results"`
}

// PaginatedResultGoodModel Пагінований результат
type PaginatedResultGoodModel struct {
	Meta    PaginationMeta                  `json:"meta"`
	Results []SrsoSchemaGoodSchemaGoodModel `json:"results"`
}

// PaginatedResultOrderModel Пагінований результат
type PaginatedResultOrderModel struct {
	Meta    PaginationMeta `json:"meta"`
	Results []OrderModel   `json:"results"`
}

// PaginatedResultReceiptModel Пагінований результат
type PaginatedResultReceiptModel struct {
	Meta    PaginationMeta `json:"meta"`
	Results []ReceiptModel `json:"results"`
}

// PaginatedResultReportModel Пагінований результат
type PaginatedResultReportModel struct {
	Meta    PaginationMeta `json:"meta"`
	Results []ReportModel  `json:"results"`
}

// PaginatedResultShiftWithCashRegisterModel Пагінований результат
type PaginatedResultShiftWithCashRegisterModel struct {
	Meta    PaginationMeta               `json:"meta"`
	Results []ShiftWithCashRegisterModel `json:"results"`
}

// PaginatedResultShortTransaction Пагінований результат
type PaginatedResultShortTransaction struct {
	Meta    PaginationMeta     `json:"meta"`
	Results []ShortTransaction `json:"results"`
}

// PaginationMeta defines model for PaginationMeta.
type PaginationMeta struct {
	Limit  int `json:"limit"`
	Offset int `json:"offset"`
}

// PaymentType An enumeration.
type PaymentType string

// PublicReportTaskSchema defines model for PublicReportTaskSchema.
type PublicReportTaskSchema struct {
	CreatedAt      time.Time          `json:"created_at"`
	Id             openapi_types.UUID `json:"id"`
	OrganizationId openapi_types.UUID `json:"organization_id"`

	// Status An enumeration.
	Status ReportStatus `json:"status"`

	// Type An enumeration.
	Type      ReportType `json:"type"`
	UpdatedAt *time.Time `json:"updated_at,omitempty"`
}

// ReceiptConfigPayload defines model for ReceiptConfigPayload.
type ReceiptConfigPayload struct {
	HtmlBodyStyle       *string `json:"html_body_style,omitempty"`
	HtmlGlobalFooter    *string `json:"html_global_footer,omitempty"`
	HtmlGlobalHeader    *string `json:"html_global_header,omitempty"`
	HtmlLightBlockStyle *string `json:"html_light_block_style,omitempty"`
	HtmlReceiptStyle    *string `json:"html_receipt_style,omitempty"`
	HtmlRulerStyle      *string `json:"html_ruler_style,omitempty"`
	TextGlobalFooter    *string `json:"text_global_footer,omitempty"`
	TextGlobalHeader    *string `json:"text_global_header,omitempty"`
}

// ReceiptDeliverySmsPayload defines model for ReceiptDeliverySmsPayload.
type ReceiptDeliverySmsPayload struct {
	Phone string `json:"phone"`
}

// ReceiptModel defines model for ReceiptModel.
type ReceiptModel struct {
	Barcode          *string                         `json:"barcode,omitempty"`
	ControlNumber    *string                         `json:"control_number,omitempty"`
	CreatedAt        time.Time                       `json:"created_at"`
	CurrencyExchange *CurrencyExchangeSchema         `json:"currency_exchange,omitempty"`
	Custom           *ReceiptConfigPayload           `json:"custom,omitempty"`
	DeliveredAt      *time.Time                      `json:"delivered_at,omitempty"`
	Discounts        *[]DiscountModel                `json:"discounts,omitempty"`
	FiscalCode       *string                         `json:"fiscal_code,omitempty"`
	FiscalDate       *time.Time                      `json:"fiscal_date,omitempty"`
	Footer           *string                         `json:"footer,omitempty"`
	Goods            []GoodItemModel                 `json:"goods"`
	Header           *string                         `json:"header,omitempty"`
	Id               openapi_types.UUID              `json:"id"`
	IsCreatedOffline *bool                           `json:"is_created_offline,omitempty"`
	IsSentDps        *bool                           `json:"is_sent_dps,omitempty"`
	OrderId          *openapi_types.UUID             `json:"order_id,omitempty"`
	Payments         []ReceiptModel_Payments_Item    `json:"payments"`
	RelatedReceiptId *openapi_types.UUID             `json:"related_receipt_id,omitempty"`
	RoundSum         *int                            `json:"round_sum,omitempty"`
	SentDpsAt        *time.Time                      `json:"sent_dps_at,omitempty"`
	Serial           int                             `json:"serial"`
	Shift            ShiftWithCashierAndCashRegister `json:"shift"`

	// Status An enumeration.
	Status          ReceiptStatus `json:"status"`
	TaxUrl          *string       `json:"tax_url,omitempty"`
	Taxes           []GoodTax     `json:"taxes"`
	TechnicalReturn *bool         `json:"technical_return,omitempty"`
	TotalPayment    int           `json:"total_payment"`

	// TotalRest Застаріле поле, використовуйте 'total_rest'
	TotalRest int `json:"total_rest"`

	// TotalSum Застаріле поле, використовуйте 'total_sum'
	TotalSum    int               `json:"total_sum"`
	Transaction *ShortTransaction `json:"transaction,omitempty"`

	// Type An enumeration.
	Type      ReceiptType `json:"type"`
	UpdatedAt *time.Time  `json:"updated_at,omitempty"`
}

// ReceiptModel_Payments_Item defines model for ReceiptModel.payments.Item.
type ReceiptModel_Payments_Item struct {
	union json.RawMessage
}

// ReceiptSellPayload defines model for ReceiptSellPayload.
type ReceiptSellPayload struct {
	Barcode     *string                                                     `json:"barcode,omitempty"`
	CashierName *string                                                     `json:"cashier_name,omitempty"`
	Context     *map[string]ReceiptSellPayload_Context_AdditionalProperties `json:"context,omitempty"`
	Custom      *ReceiptConfigPayload                                       `json:"custom,omitempty"`
	Delivery    *DeliveryPayload                                            `json:"delivery,omitempty"`
	Departament *string                                                     `json:"departament,omitempty"`
	Discounts   *[]DiscountPayload                                          `json:"discounts,omitempty"`
	Footer      *string                                                     `json:"footer,omitempty"`
	Goods       []GoodItemPayload                                           `json:"goods"`
	Header      *string                                                     `json:"header,omitempty"`
	Id          *openapi_types.UUID                                         `json:"id,omitempty"`
	IsPawnshop  *bool                                                       `json:"is_pawnshop,omitempty"`
	OrderId     *openapi_types.UUID                                         `json:"order_id,omitempty"`
	Payments    *[]ReceiptSellPayload_Payments_Item                         `json:"payments,omitempty"`

	// PreviousReceiptId id попереднього фіскального чеку (використовується опціонально для контролю послідовності)
	PreviousReceiptId *openapi_types.UUID `json:"previous_receipt_id,omitempty"`
	RelatedReceiptId  *openapi_types.UUID `json:"related_receipt_id,omitempty"`
	Rounding          *bool               `json:"rounding,omitempty"`
	TechnicalReturn   *bool               `json:"technical_return,omitempty"`
}

// ReceiptSellPayloadContext0 defines model for .
type ReceiptSellPayloadContext0 = string

// ReceiptSellPayloadContext1 defines model for .
type ReceiptSellPayloadContext1 = int

// ReceiptSellPayloadContext2 defines model for .
type ReceiptSellPayloadContext2 = float32

// ReceiptSellPayloadContext3 defines model for .
type ReceiptSellPayloadContext3 = bool

// ReceiptSellPayload_Context_AdditionalProperties defines model for ReceiptSellPayload.context.AdditionalProperties.
type ReceiptSellPayload_Context_AdditionalProperties struct {
	union json.RawMessage
}

// ReceiptSellPayload_Payments_Item defines model for ReceiptSellPayload.payments.Item.
type ReceiptSellPayload_Payments_Item struct {
	union json.RawMessage
}

// ReceiptServicePayload defines model for ReceiptServicePayload.
type ReceiptServicePayload struct {
	Context    *map[string]ReceiptServicePayload_Context_AdditionalProperties `json:"context,omitempty"`
	Custom     *ReceiptConfigPayload                                          `json:"custom,omitempty"`
	FiscalCode *string                                                        `json:"fiscal_code,omitempty"`
	FiscalDate *time.Time                                                     `json:"fiscal_date,omitempty"`
	Id         *openapi_types.UUID                                            `json:"id,omitempty"`
	Payment    ReceiptServicePayload_Payment                                  `json:"payment"`
}

// ReceiptServicePayloadContext0 defines model for .
type ReceiptServicePayloadContext0 = string

// ReceiptServicePayloadContext1 defines model for .
type ReceiptServicePayloadContext1 = int

// ReceiptServicePayloadContext2 defines model for .
type ReceiptServicePayloadContext2 = float32

// ReceiptServicePayloadContext3 defines model for .
type ReceiptServicePayloadContext3 = bool

// ReceiptServicePayload_Context_AdditionalProperties defines model for ReceiptServicePayload.context.AdditionalProperties.
type ReceiptServicePayload_Context_AdditionalProperties struct {
	union json.RawMessage
}

// ReceiptServicePayload_Payment defines model for ReceiptServicePayload.Payment.
type ReceiptServicePayload_Payment struct {
	union json.RawMessage
}

// ReceiptStatus An enumeration.
type ReceiptStatus = interface{}

// ReceiptType An enumeration.
type ReceiptType = interface{}

// ReceiptUpdateSchema defines model for ReceiptUpdateSchema.
type ReceiptUpdateSchema struct {
	Receipt ShortReceiptModel `json:"receipt"`
}

// ReportModel defines model for ReportModel.
type ReportModel struct {
	Balance                     int                   `json:"balance"`
	CashWithdrawalReceiptsCount int                   `json:"cash_withdrawal_receipts_count"`
	CreatedAt                   time.Time             `json:"created_at"`
	DiscountsSum                *int                  `json:"discounts_sum,omitempty"`
	ExtraChargeSum              *int                  `json:"extra_charge_sum,omitempty"`
	Id                          openapi_types.UUID    `json:"id"`
	Initial                     int                   `json:"initial"`
	IsZReport                   bool                  `json:"is_z_report"`
	Payments                    []ReportPaymentsModel `json:"payments"`
	ReturnReceiptsCount         int                   `json:"return_receipts_count"`
	SellReceiptsCount           int                   `json:"sell_receipts_count"`
	Serial                      int                   `json:"serial"`
	Taxes                       []ReportTaxesModel    `json:"taxes"`
	TransfersCount              int                   `json:"transfers_count"`
	TransfersSum                int                   `json:"transfers_sum"`
	UpdatedAt                   *time.Time            `json:"updated_at,omitempty"`
}

// ReportPayload defines model for ReportPayload.
type ReportPayload struct {
	Balance                     int                     `json:"balance"`
	CashWithdrawalReceiptsCount *int                    `json:"cash_withdrawal_receipts_count,omitempty"`
	CreatedAt                   *time.Time              `json:"created_at,omitempty"`
	DiscountsSum                *int                    `json:"discounts_sum,omitempty"`
	ExtraChargeSum              *int                    `json:"extra_charge_sum,omitempty"`
	Id                          *openapi_types.UUID     `json:"id,omitempty"`
	Initial                     int                     `json:"initial"`
	LastReceiptId               *openapi_types.UUID     `json:"last_receipt_id,omitempty"`
	Payments                    []ReportPaymentsPayload `json:"payments"`
	ReturnReceiptsCount         int                     `json:"return_receipts_count"`
	ReturnsRoundDown            *int                    `json:"returns_round_down,omitempty"`
	ReturnsRoundUp              *int                    `json:"returns_round_up,omitempty"`
	SalesRoundDown              *int                    `json:"sales_round_down,omitempty"`
	SalesRoundUp                *int                    `json:"sales_round_up,omitempty"`
	SellReceiptsCount           int                     `json:"sell_receipts_count"`
	Serial                      *int                    `json:"serial,omitempty"`
	Taxes                       []ReportTaxesPayload    `json:"taxes"`
}

// ReportPaymentsModel defines model for ReportPaymentsModel.
type ReportPaymentsModel struct {
	CashWithdrawal           int                `json:"cash_withdrawal"`
	CashWithdrawalCommission int                `json:"cash_withdrawal_commission"`
	Code                     *int               `json:"code,omitempty"`
	Id                       openapi_types.UUID `json:"id"`
	Label                    string             `json:"label"`
	ReturnSum                int                `json:"return_sum"`
	SellSum                  int                `json:"sell_sum"`
	ServiceIn                int                `json:"service_in"`
	ServiceOut               int                `json:"service_out"`

	// Type An enumeration.
	Type PaymentType `json:"type"`
}

// ReportPaymentsPayload defines model for ReportPaymentsPayload.
type ReportPaymentsPayload struct {
	CashWithdrawal           *int        `json:"cash_withdrawal,omitempty"`
	CashWithdrawalCommission *int        `json:"cash_withdrawal_commission,omitempty"`
	Code                     *int        `json:"code,omitempty"`
	Label                    string      `json:"label"`
	ReturnSum                int         `json:"return_sum"`
	SellSum                  int         `json:"sell_sum"`
	ServiceIn                int         `json:"service_in"`
	ServiceOut               int         `json:"service_out"`
	Type                     PaymentType `json:"type"`
}

// ReportStatus An enumeration.
type ReportStatus string

// ReportTaxesModel defines model for ReportTaxesModel.
type ReportTaxesModel struct {
	AdvancedCode    *string            `json:"advanced_code,omitempty"`
	Code            int                `json:"code"`
	CreatedAt       time.Time          `json:"created_at"`
	Id              openapi_types.UUID `json:"id"`
	Label           string             `json:"label"`
	NoVat           *bool              `json:"no_vat,omitempty"`
	Rate            float32            `json:"rate"`
	ReturnSum       int                `json:"return_sum"`
	ReturnsTurnover int                `json:"returns_turnover"`
	SalesTurnover   int                `json:"sales_turnover"`
	SellSum         int                `json:"sell_sum"`
	SetupDate       time.Time          `json:"setup_date"`
	Symbol          string             `json:"symbol"`
}

// ReportTaxesPayload defines model for ReportTaxesPayload.
type ReportTaxesPayload struct {
	AdvancedCode    *string   `json:"advanced_code,omitempty"`
	Code            int       `json:"code"`
	ExtraRate       float32   `json:"extra_rate"`
	Included        *bool     `json:"included,omitempty"`
	Label           string    `json:"label"`
	NoVat           *bool     `json:"no_vat,omitempty"`
	Rate            float32   `json:"rate"`
	ReturnSum       float32   `json:"return_sum"`
	ReturnsTurnover float32   `json:"returns_turnover"`
	SalesTurnover   float32   `json:"sales_turnover"`
	SellSum         float32   `json:"sell_sum"`
	SetupDate       time.Time `json:"setup_date"`
	Symbol          string    `json:"symbol"`
}

// ReportType An enumeration.
type ReportType string

// ServiceCurrencyItemPayload defines model for ServiceCurrencyItemPayload.
type ServiceCurrencyItemPayload struct {
	Currency string  `json:"currency"`
	Value    float32 `json:"value"`
}

// ServiceCurrencyPayload defines model for ServiceCurrencyPayload.
type ServiceCurrencyPayload struct {
	Currencies []ServiceCurrencyItemPayload `json:"currencies"`
	Id         *openapi_types.UUID          `json:"id,omitempty"`

	// Type An enumeration.
	Type ServiceOperationType `json:"type"`
}

// ServiceOperationType An enumeration.
type ServiceOperationType string

// ServiceReceiptUpdateSchema defines model for ServiceReceiptUpdateSchema.
type ServiceReceiptUpdateSchema struct {
	ServiceReceipt ShortReceiptModel `json:"service_receipt"`
}

// SetIntegrationPayload defines model for SetIntegrationPayload.
type SetIntegrationPayload struct {
	Url string `json:"url"`
}

// SetWebhookPayload defines model for SetWebhookPayload.
type SetWebhookPayload struct {
	Url string `json:"url"`
}

// SetupRatesPayload defines model for SetupRatesPayload.
type SetupRatesPayload struct {
	Rates []CurrencyRatePayload `json:"rates"`
}

// ShiftModel defines model for ShiftModel.
type ShiftModel struct {
	Balance               *BalanceModel      `json:"balance,omitempty"`
	ClosedAt              *time.Time         `json:"closed_at,omitempty"`
	ClosingTransaction    *ShortTransaction  `json:"closing_transaction,omitempty"`
	CreatedAt             time.Time          `json:"created_at"`
	EmergencyClose        *bool              `json:"emergency_close,omitempty"`
	EmergencyCloseDetails *string            `json:"emergency_close_details,omitempty"`
	Id                    openapi_types.UUID `json:"id"`
	InitialTransaction    *ShortTransaction  `json:"initial_transaction,omitempty"`
	OpenedAt              *time.Time         `json:"opened_at,omitempty"`
	Serial                int                `json:"serial"`

	// Status An enumeration.
	Status    ShiftStatus     `json:"status"`
	Taxes     []ShiftTaxModel `json:"taxes"`
	UpdatedAt *time.Time      `json:"updated_at,omitempty"`
	ZReport   *ReportModel    `json:"z_report,omitempty"`
}

// ShiftStatus An enumeration.
type ShiftStatus = interface{}

// ShiftTaxModel defines model for ShiftTaxModel.
type ShiftTaxModel struct {
	AdvancedCode    *string            `json:"advanced_code,omitempty"`
	Code            int                `json:"code"`
	CreatedAt       time.Time          `json:"created_at"`
	ExtraRate       *int               `json:"extra_rate,omitempty"`
	Id              openapi_types.UUID `json:"id"`
	Included        bool               `json:"included"`
	Label           string             `json:"label"`
	NoVat           *bool              `json:"no_vat,omitempty"`
	Rate            int                `json:"rate"`
	Returns         int                `json:"returns"`
	ReturnsTurnover int                `json:"returns_turnover"`
	Sales           int                `json:"sales"`
	SalesTurnover   int                `json:"sales_turnover"`
	Symbol          string             `json:"symbol"`
	UpdatedAt       *time.Time         `json:"updated_at,omitempty"`
}

// ShiftUpdateSchema defines model for ShiftUpdateSchema.
type ShiftUpdateSchema struct {
	Shift ShiftModel `json:"shift"`
}

// ShiftWithCashRegisterModel defines model for ShiftWithCashRegisterModel.
type ShiftWithCashRegisterModel struct {
	Balance               *BalanceModel      `json:"balance,omitempty"`
	CashRegister          CashRegisterModel  `json:"cash_register"`
	ClosedAt              *time.Time         `json:"closed_at,omitempty"`
	ClosingTransaction    *ShortTransaction  `json:"closing_transaction,omitempty"`
	CreatedAt             time.Time          `json:"created_at"`
	EmergencyClose        *bool              `json:"emergency_close,omitempty"`
	EmergencyCloseDetails *string            `json:"emergency_close_details,omitempty"`
	Id                    openapi_types.UUID `json:"id"`
	InitialTransaction    *ShortTransaction  `json:"initial_transaction,omitempty"`
	OpenedAt              *time.Time         `json:"opened_at,omitempty"`
	Serial                int                `json:"serial"`

	// Status An enumeration.
	Status    ShiftStatus     `json:"status"`
	Taxes     []ShiftTaxModel `json:"taxes"`
	UpdatedAt *time.Time      `json:"updated_at,omitempty"`
	ZReport   *ReportModel    `json:"z_report,omitempty"`
}

// ShiftWithCashierAndCashRegister defines model for ShiftWithCashierAndCashRegister.
type ShiftWithCashierAndCashRegister struct {
	Balance               *BalanceModel      `json:"balance,omitempty"`
	CashRegister          CashRegisterModel  `json:"cash_register"`
	Cashier               CashierModel       `json:"cashier"`
	ClosedAt              *time.Time         `json:"closed_at,omitempty"`
	ClosingTransaction    *ShortTransaction  `json:"closing_transaction,omitempty"`
	CreatedAt             time.Time          `json:"created_at"`
	EmergencyClose        *bool              `json:"emergency_close,omitempty"`
	EmergencyCloseDetails *string            `json:"emergency_close_details,omitempty"`
	Id                    openapi_types.UUID `json:"id"`
	InitialTransaction    *ShortTransaction  `json:"initial_transaction,omitempty"`
	OpenedAt              *time.Time         `json:"opened_at,omitempty"`
	Serial                int                `json:"serial"`

	// Status An enumeration.
	Status    ShiftStatus     `json:"status"`
	Taxes     []ShiftTaxModel `json:"taxes"`
	UpdatedAt *time.Time      `json:"updated_at,omitempty"`
	ZReport   *ReportModel    `json:"z_report,omitempty"`
}

// ShiftWithCashierModel defines model for ShiftWithCashierModel.
type ShiftWithCashierModel struct {
	Balance               *BalanceModel      `json:"balance,omitempty"`
	Cashier               CashierModel       `json:"cashier"`
	ClosedAt              *time.Time         `json:"closed_at,omitempty"`
	ClosingTransaction    *ShortTransaction  `json:"closing_transaction,omitempty"`
	CreatedAt             time.Time          `json:"created_at"`
	EmergencyClose        *bool              `json:"emergency_close,omitempty"`
	EmergencyCloseDetails *string            `json:"emergency_close_details,omitempty"`
	Id                    openapi_types.UUID `json:"id"`
	InitialTransaction    *ShortTransaction  `json:"initial_transaction,omitempty"`
	OpenedAt              *time.Time         `json:"opened_at,omitempty"`
	Serial                int                `json:"serial"`

	// Status An enumeration.
	Status    ShiftStatus     `json:"status"`
	Taxes     []ShiftTaxModel `json:"taxes"`
	UpdatedAt *time.Time      `json:"updated_at,omitempty"`
	ZReport   *ReportModel    `json:"z_report,omitempty"`
}

// ShortCloseShiftPayload defines model for ShortCloseShiftPayload.
type ShortCloseShiftPayload struct {
	Report              *ReportPayload `json:"report,omitempty"`
	SkipClientNameCheck *bool          `json:"skip_client_name_check,omitempty"`
}

// ShortOrganizationModel defines model for ShortOrganizationModel.
type ShortOrganizationModel struct {
	Edrpou    string             `json:"edrpou"`
	Id        openapi_types.UUID `json:"id"`
	TaxNumber string             `json:"tax_number"`
	Title     string             `json:"title"`
}

// ShortReceiptModel defines model for ShortReceiptModel.
type ShortReceiptModel struct {
	Barcode          *string                           `json:"barcode,omitempty"`
	CreatedAt        time.Time                         `json:"created_at"`
	CurrencyExchange *CurrencyExchangeSchema           `json:"currency_exchange,omitempty"`
	Custom           *ReceiptConfigPayload             `json:"custom,omitempty"`
	DeliveredAt      *time.Time                        `json:"delivered_at,omitempty"`
	Discounts        *[]DiscountModel                  `json:"discounts,omitempty"`
	FiscalCode       *string                           `json:"fiscal_code,omitempty"`
	FiscalDate       *time.Time                        `json:"fiscal_date,omitempty"`
	Footer           *string                           `json:"footer,omitempty"`
	Goods            []GoodItemModel                   `json:"goods"`
	Header           *string                           `json:"header,omitempty"`
	Id               openapi_types.UUID                `json:"id"`
	IsCreatedOffline *bool                             `json:"is_created_offline,omitempty"`
	IsSentDps        *bool                             `json:"is_sent_dps,omitempty"`
	OrderId          *openapi_types.UUID               `json:"order_id,omitempty"`
	Payments         []ShortReceiptModel_Payments_Item `json:"payments"`
	RelatedReceiptId *openapi_types.UUID               `json:"related_receipt_id,omitempty"`
	RoundSum         *int                              `json:"round_sum,omitempty"`
	SentDpsAt        *time.Time                        `json:"sent_dps_at,omitempty"`
	Serial           int                               `json:"serial"`

	// Status An enumeration.
	Status          ReceiptStatus `json:"status"`
	TaxUrl          *string       `json:"tax_url,omitempty"`
	Taxes           []GoodTax     `json:"taxes"`
	TechnicalReturn *bool         `json:"technical_return,omitempty"`
	TotalPayment    int           `json:"total_payment"`

	// TotalRest Застаріле поле, використовуйте 'total_rest'
	TotalRest int `json:"total_rest"`

	// TotalSum Застаріле поле, використовуйте 'total_sum'
	TotalSum    int               `json:"total_sum"`
	Transaction *ShortTransaction `json:"transaction,omitempty"`

	// Type An enumeration.
	Type      ReceiptType `json:"type"`
	UpdatedAt *time.Time  `json:"updated_at,omitempty"`
}

// ShortReceiptModel_Payments_Item defines model for ShortReceiptModel.payments.Item.
type ShortReceiptModel_Payments_Item struct {
	union json.RawMessage
}

// ShortTransaction defines model for ShortTransaction.
type ShortTransaction struct {
	CreatedAt            *time.Time         `json:"created_at,omitempty"`
	Id                   openapi_types.UUID `json:"id"`
	OfflineId            *string            `json:"offline_id,omitempty"`
	PreviousHash         *string            `json:"previous_hash,omitempty"`
	RequestReceivedAt    *time.Time         `json:"request_received_at,omitempty"`
	RequestSignedAt      *time.Time         `json:"request_signed_at,omitempty"`
	ResponseErrorMessage *string            `json:"response_error_message,omitempty"`
	ResponseId           *string            `json:"response_id,omitempty"`
	ResponseStatus       *string            `json:"response_status,omitempty"`
	Serial               int                `json:"serial"`

	// Status An enumeration.
	Status TransactionStatus `json:"status"`

	// Type An enumeration.
	Type      TransactionType `json:"type"`
	UpdatedAt *time.Time      `json:"updated_at,omitempty"`
}

// SignatureType An enumeration.
type SignatureType = interface{}

// TaxModel defines model for TaxModel.
type TaxModel struct {
	AdvancedCode *string            `json:"advanced_code,omitempty"`
	Code         int                `json:"code"`
	CreatedAt    time.Time          `json:"created_at"`
	ExtraRate    *int               `json:"extra_rate,omitempty"`
	Id           openapi_types.UUID `json:"id"`
	Included     bool               `json:"included"`
	Label        string             `json:"label"`
	NoVat        *bool              `json:"no_vat,omitempty"`
	Rate         int                `json:"rate"`
	Symbol       string             `json:"symbol"`
	UpdatedAt    *time.Time         `json:"updated_at,omitempty"`
}

// TransactionModel defines model for TransactionModel.
type TransactionModel struct {
	CreatedAt             *time.Time         `json:"created_at,omitempty"`
	Id                    openapi_types.UUID `json:"id"`
	OfflineId             *string            `json:"offline_id,omitempty"`
	PreviousHash          *string            `json:"previous_hash,omitempty"`
	RequestData           *[]byte            `json:"request_data,omitempty"`
	RequestReceivedAt     *time.Time         `json:"request_received_at,omitempty"`
	RequestSignature      *[]byte            `json:"request_signature,omitempty"`
	RequestSignedAt       *time.Time         `json:"request_signed_at,omitempty"`
	ResponseData          *[]byte            `json:"response_data,omitempty"`
	ResponseDataSignature *[]byte            `json:"response_data_signature,omitempty"`
	ResponseErrorMessage  *string            `json:"response_error_message,omitempty"`
	ResponseId            *string            `json:"response_id,omitempty"`
	ResponseIdSignature   *[]byte            `json:"response_id_signature,omitempty"`
	ResponseStatus        *string            `json:"response_status,omitempty"`
	Serial                int                `json:"serial"`

	// Status An enumeration.
	Status TransactionStatus `json:"status"`

	// Type An enumeration.
	Type      TransactionType `json:"type"`
	UpdatedAt *time.Time      `json:"updated_at,omitempty"`
}

// TransactionStatus An enumeration.
type TransactionStatus = interface{}

// TransactionType An enumeration.
type TransactionType = interface{}

// UpdateTransactionPayload defines model for UpdateTransactionPayload.
type UpdateTransactionPayload struct {
	RequestSignature []byte `json:"request_signature"`
}

// ValidationError defines model for ValidationError.
type ValidationError struct {
	Loc  []string `json:"loc"`
	Msg  string   `json:"msg"`
	Type string   `json:"type"`
}

// WebhookInfoResponseSchema defines model for WebhookInfoResponseSchema.
type WebhookInfoResponseSchema struct {
	CreatedAt        time.Time  `json:"created_at"`
	Key              string     `json:"key"`
	LastErrorDate    *time.Time `json:"last_error_date,omitempty"`
	LastErrorMessage *string    `json:"last_error_message,omitempty"`
	UpdatedAt        *time.Time `json:"updated_at,omitempty"`
	Url              string     `json:"url"`
}

// WebhookInfoSchema defines model for WebhookInfoSchema.
type WebhookInfoSchema struct {
	CreatedAt        time.Time  `json:"created_at"`
	LastErrorDate    *time.Time `json:"last_error_date,omitempty"`
	LastErrorMessage *string    `json:"last_error_message,omitempty"`
	UpdatedAt        *time.Time `json:"updated_at,omitempty"`
	Url              string     `json:"url"`
}

// SrsoSchemaGoodSchemaGoodModel defines model for srso__schema__good__schema__GoodModel.
type SrsoSchemaGoodSchemaGoodModel struct {
	Barcode      *string            `json:"barcode,omitempty"`
	Code         string             `json:"code"`
	CreatedAt    time.Time          `json:"created_at"`
	Id           openapi_types.UUID `json:"id"`
	Name         string             `json:"name"`
	Price        int                `json:"price"`
	RelatedGoods *[]GoodModelBase   `json:"related_goods,omitempty"`
	Taxes        []TaxModel         `json:"taxes"`
	Uktzed       *string            `json:"uktzed,omitempty"`
	UpdatedAt    *time.Time         `json:"updated_at,omitempty"`
}

// SrsoSchemaReceiptSchemaGoodModel defines model for srso__schema__receipt__schema__GoodModel.
type SrsoSchemaReceiptSchemaGoodModel struct {
	Barcode        *string   `json:"barcode,omitempty"`
	Code           string    `json:"code"`
	ExciseBarcodes *[]string `json:"excise_barcodes,omitempty"`
	Footer         *string   `json:"footer,omitempty"`
	Header         *string   `json:"header,omitempty"`
	Name           string    `json:"name"`
	Price          int       `json:"price"`
	Uktzed         *string   `json:"uktzed,omitempty"`
}

// GetCashRegistersApiV1CashRegistersGetParams defines parameters for GetCashRegistersApiV1CashRegistersGet.
type GetCashRegistersApiV1CashRegistersGetParams struct {
	InUse  *bool `form:"in_use,omitempty" json:"in_use,omitempty"`
	Limit  *int  `form:"limit,omitempty" json:"limit,omitempty"`
	Offset *int  `form:"offset,omitempty" json:"offset,omitempty"`

	// XClientName Наза клієнту або сервісу що інтегрується з API, наприклад 'My Custom SDK'
	XClientName *string `json:"X-Client-Name,omitempty"`

	// XClientVersion Номер версії клінту що інтегрується з API, наприклад 'v1.2.5'
	XClientVersion *string `json:"X-Client-Version,omitempty"`

	// XAccessKey Ключ доступу інтеграції (тільки для авторизованих API інтеграцій)
	XAccessKey *string `json:"X-Access-Key,omitempty"`
}

// AskOfflineCodesApiV1CashRegistersAskOfflineCodesGetParams defines parameters for AskOfflineCodesApiV1CashRegistersAskOfflineCodesGet.
type AskOfflineCodesApiV1CashRegistersAskOfflineCodesGetParams struct {
	// Count Number of codes to get
	Count *int  `form:"count,omitempty" json:"count,omitempty"`
	Sync  *bool `form:"sync,omitempty" json:"sync,omitempty"`

	// XClientName Наза клієнту або сервісу що інтегрується з API, наприклад 'My Custom SDK'
	XClientName *string `json:"X-Client-Name,omitempty"`

	// XClientVersion Номер версії клінту що інтегрується з API, наприклад 'v1.2.5'
	XClientVersion *string `json:"X-Client-Version,omitempty"`

	// XAccessKey Ключ доступу інтеграції (тільки для авторизованих API інтеграцій)
	XAccessKey *string `json:"X-Access-Key,omitempty"`

	// XDeviceID ID RRO Agent або мобільного пристрою каси (Для блокування дублікатів)
	XDeviceID   *string `json:"X-Device-ID,omitempty"`
	XLicenseKey string  `json:"X-License-Key"`
}

// GetOfflineCodesApiV1CashRegistersGetOfflineCodesGetParams defines parameters for GetOfflineCodesApiV1CashRegistersGetOfflineCodesGet.
type GetOfflineCodesApiV1CashRegistersGetOfflineCodesGetParams struct {
	// Count Maximal number of codes to get
	Count *int `form:"count,omitempty" json:"count,omitempty"`

	// XClientName Наза клієнту або сервісу що інтегрується з API, наприклад 'My Custom SDK'
	XClientName *string `json:"X-Client-Name,omitempty"`

	// XClientVersion Номер версії клінту що інтегрується з API, наприклад 'v1.2.5'
	XClientVersion *string `json:"X-Client-Version,omitempty"`

	// XAccessKey Ключ доступу інтеграції (тільки для авторизованих API інтеграцій)
	XAccessKey  *string `json:"X-Access-Key,omitempty"`
	XLicenseKey *string `json:"X-License-Key,omitempty"`
}

// GetOfflineCodesCountApiV1CashRegistersGetOfflineCodesCountGetParams defines parameters for GetOfflineCodesCountApiV1CashRegistersGetOfflineCodesCountGet.
type GetOfflineCodesCountApiV1CashRegistersGetOfflineCodesCountGetParams struct {
	// XClientName Наза клієнту або сервісу що інтегрується з API, наприклад 'My Custom SDK'
	XClientName *string `json:"X-Client-Name,omitempty"`

	// XClientVersion Номер версії клінту що інтегрується з API, наприклад 'v1.2.5'
	XClientVersion *string `json:"X-Client-Version,omitempty"`

	// XAccessKey Ключ доступу інтеграції (тільки для авторизованих API інтеграцій)
	XAccessKey  *string `json:"X-Access-Key,omitempty"`
	XLicenseKey string  `json:"X-License-Key"`
}

// GetOfflineTimeApiV1CashRegistersGetOfflineTimeGetParams defines parameters for GetOfflineTimeApiV1CashRegistersGetOfflineTimeGet.
type GetOfflineTimeApiV1CashRegistersGetOfflineTimeGetParams struct {
	// FromDate Час офлайн починаючи від дати
	FromDate *time.Time `form:"from_date,omitempty" json:"from_date,omitempty"`

	// ToDate Час офлайн закінчуючи до дати
	ToDate *time.Time `form:"to_date,omitempty" json:"to_date,omitempty"`

	// XClientName Наза клієнту або сервісу що інтегрується з API, наприклад 'My Custom SDK'
	XClientName *string `json:"X-Client-Name,omitempty"`

	// XClientVersion Номер версії клінту що інтегрується з API, наприклад 'v1.2.5'
	XClientVersion *string `json:"X-Client-Version,omitempty"`

	// XAccessKey Ключ доступу інтеграції (тільки для авторизованих API інтеграцій)
	XAccessKey  *string `json:"X-Access-Key,omitempty"`
	XLicenseKey string  `json:"X-License-Key"`
}

// GoOfflineActionApiV1CashRegistersGoOfflinePostParams defines parameters for GoOfflineActionApiV1CashRegistersGoOfflinePost.
type GoOfflineActionApiV1CashRegistersGoOfflinePostParams struct {
	// XClientName Наза клієнту або сервісу що інтегрується з API, наприклад 'My Custom SDK'
	XClientName *string `json:"X-Client-Name,omitempty"`

	// XClientVersion Номер версії клінту що інтегрується з API, наприклад 'v1.2.5'
	XClientVersion *string `json:"X-Client-Version,omitempty"`

	// XAccessKey Ключ доступу інтеграції (тільки для авторизованих API інтеграцій)
	XAccessKey *string `json:"X-Access-Key,omitempty"`

	// XDeviceID ID RRO Agent або мобільного пристрою каси (Для блокування дублікатів)
	XDeviceID   *string `json:"X-Device-ID,omitempty"`
	XLicenseKey *string `json:"X-License-Key,omitempty"`
}

// GoOnlineActionApiV1CashRegistersGoOnlinePostParams defines parameters for GoOnlineActionApiV1CashRegistersGoOnlinePost.
type GoOnlineActionApiV1CashRegistersGoOnlinePostParams struct {
	// XClientName Наза клієнту або сервісу що інтегрується з API, наприклад 'My Custom SDK'
	XClientName *string `json:"X-Client-Name,omitempty"`

	// XClientVersion Номер версії клінту що інтегрується з API, наприклад 'v1.2.5'
	XClientVersion *string `json:"X-Client-Version,omitempty"`

	// XAccessKey Ключ доступу інтеграції (тільки для авторизованих API інтеграцій)
	XAccessKey *string `json:"X-Access-Key,omitempty"`

	// XDeviceID ID RRO Agent або мобільного пристрою каси (Для блокування дублікатів)
	XDeviceID   *string `json:"X-Device-ID,omitempty"`
	XLicenseKey *string `json:"X-License-Key,omitempty"`
}

// GetCashRegisterInfoApiV1CashRegistersInfoGetParams defines parameters for GetCashRegisterInfoApiV1CashRegistersInfoGet.
type GetCashRegisterInfoApiV1CashRegistersInfoGetParams struct {
	// XClientName Наза клієнту або сервісу що інтегрується з API, наприклад 'My Custom SDK'
	XClientName *string `json:"X-Client-Name,omitempty"`

	// XClientVersion Номер версії клінту що інтегрується з API, наприклад 'v1.2.5'
	XClientVersion *string `json:"X-Client-Version,omitempty"`

	// XAccessKey Ключ доступу інтеграції (тільки для авторизованих API інтеграцій)
	XAccessKey  *string `json:"X-Access-Key,omitempty"`
	XLicenseKey string  `json:"X-License-Key"`
}

// PingTaxServiceActionApiV1CashRegistersPingTaxServicePostParams defines parameters for PingTaxServiceActionApiV1CashRegistersPingTaxServicePost.
type PingTaxServiceActionApiV1CashRegistersPingTaxServicePostParams struct {
	// XClientName Наза клієнту або сервісу що інтегрується з API, наприклад 'My Custom SDK'
	XClientName *string `json:"X-Client-Name,omitempty"`

	// XClientVersion Номер версії клінту що інтегрується з API, наприклад 'v1.2.5'
	XClientVersion *string `json:"X-Client-Version,omitempty"`

	// XAccessKey Ключ доступу інтеграції (тільки для авторизованих API інтеграцій)
	XAccessKey  *string `json:"X-Access-Key,omitempty"`
	XLicenseKey string  `json:"X-License-Key"`
}

// GetCashRegisterApiV1CashRegistersCashRegisterIdGetParams defines parameters for GetCashRegisterApiV1CashRegistersCashRegisterIdGet.
type GetCashRegisterApiV1CashRegistersCashRegisterIdGetParams struct {
	// XClientName Наза клієнту або сервісу що інтегрується з API, наприклад 'My Custom SDK'
	XClientName *string `json:"X-Client-Name,omitempty"`

	// XClientVersion Номер версії клінту що інтегрується з API, наприклад 'v1.2.5'
	XClientVersion *string `json:"X-Client-Version,omitempty"`

	// XAccessKey Ключ доступу інтеграції (тільки для авторизованих API інтеграцій)
	XAccessKey *string `json:"X-Access-Key,omitempty"`
}

// CheckSignatureApiV1CashierCheckSignatureGetParams defines parameters for CheckSignatureApiV1CashierCheckSignatureGet.
type CheckSignatureApiV1CashierCheckSignatureGetParams struct {
	// XClientName Наза клієнту або сервісу що інтегрується з API, наприклад 'My Custom SDK'
	XClientName *string `json:"X-Client-Name,omitempty"`

	// XClientVersion Номер версії клінту що інтегрується з API, наприклад 'v1.2.5'
	XClientVersion *string `json:"X-Client-Version,omitempty"`

	// XAccessKey Ключ доступу інтеграції (тільки для авторизованих API інтеграцій)
	XAccessKey *string `json:"X-Access-Key,omitempty"`
}

// GetCashierProfileApiV1CashierMeGetParams defines parameters for GetCashierProfileApiV1CashierMeGet.
type GetCashierProfileApiV1CashierMeGetParams struct {
	// XClientName Наза клієнту або сервісу що інтегрується з API, наприклад 'My Custom SDK'
	XClientName *string `json:"X-Client-Name,omitempty"`

	// XClientVersion Номер версії клінту що інтегрується з API, наприклад 'v1.2.5'
	XClientVersion *string `json:"X-Client-Version,omitempty"`

	// XAccessKey Ключ доступу інтеграції (тільки для авторизованих API інтеграцій)
	XAccessKey *string `json:"X-Access-Key,omitempty"`

	// XDeviceID ID RRO Agent або мобільного пристрою каси (Для блокування дублікатів)
	XDeviceID *string `json:"X-Device-ID,omitempty"`
}

// GetCashierShiftApiV1CashierShiftGetParams defines parameters for GetCashierShiftApiV1CashierShiftGet.
type GetCashierShiftApiV1CashierShiftGetParams struct {
	// XClientName Наза клієнту або сервісу що інтегрується з API, наприклад 'My Custom SDK'
	XClientName *string `json:"X-Client-Name,omitempty"`

	// XClientVersion Номер версії клінту що інтегрується з API, наприклад 'v1.2.5'
	XClientVersion *string `json:"X-Client-Version,omitempty"`

	// XAccessKey Ключ доступу інтеграції (тільки для авторизованих API інтеграцій)
	XAccessKey *string `json:"X-Access-Key,omitempty"`

	// XDeviceID ID RRO Agent або мобільного пристрою каси (Для блокування дублікатів)
	XDeviceID *string `json:"X-Device-ID,omitempty"`
}

// SignInCashierApiV1CashierSigninPostParams defines parameters for SignInCashierApiV1CashierSigninPost.
type SignInCashierApiV1CashierSigninPostParams struct {
	// XClientName Наза клієнту або сервісу що інтегрується з API, наприклад 'My Custom SDK'
	XClientName *string `json:"X-Client-Name,omitempty"`

	// XClientVersion Номер версії клінту що інтегрується з API, наприклад 'v1.2.5'
	XClientVersion *string `json:"X-Client-Version,omitempty"`

	// XAccessKey Ключ доступу інтеграції (тільки для авторизованих API інтеграцій)
	XAccessKey *string `json:"X-Access-Key,omitempty"`

	// XDeviceID ID RRO Agent або мобільного пристрою каси (Для блокування дублікатів)
	XDeviceID *string `json:"X-Device-ID,omitempty"`
}

// SignInCashierViaPinCodeApiV1CashierSigninPinCodePostParams defines parameters for SignInCashierViaPinCodeApiV1CashierSigninPinCodePost.
type SignInCashierViaPinCodeApiV1CashierSigninPinCodePostParams struct {
	// XClientName Наза клієнту або сервісу що інтегрується з API, наприклад 'My Custom SDK'
	XClientName *string `json:"X-Client-Name,omitempty"`

	// XClientVersion Номер версії клінту що інтегрується з API, наприклад 'v1.2.5'
	XClientVersion *string `json:"X-Client-Version,omitempty"`

	// XAccessKey Ключ доступу інтеграції (тільки для авторизованих API інтеграцій)
	XAccessKey  *string `json:"X-Access-Key,omitempty"`
	XLicenseKey string  `json:"X-License-Key"`

	// XDeviceID ID RRO Agent або мобільного пристрою каси (Для блокування дублікатів)
	XDeviceID *string `json:"X-Device-ID,omitempty"`
}

// SignOutCashierApiV1CashierSignoutPostParams defines parameters for SignOutCashierApiV1CashierSignoutPost.
type SignOutCashierApiV1CashierSignoutPostParams struct {
	// XClientName Наза клієнту або сервісу що інтегрується з API, наприклад 'My Custom SDK'
	XClientName *string `json:"X-Client-Name,omitempty"`

	// XClientVersion Номер версії клінту що інтегрується з API, наприклад 'v1.2.5'
	XClientVersion *string `json:"X-Client-Version,omitempty"`

	// XAccessKey Ключ доступу інтеграції (тільки для авторизованих API інтеграцій)
	XAccessKey *string `json:"X-Access-Key,omitempty"`

	// XDeviceID ID RRO Agent або мобільного пристрою каси (Для блокування дублікатів)
	XDeviceID *string `json:"X-Device-ID,omitempty"`
}

// GetCurrencyRatesApiV1CurrencyRateGetParams defines parameters for GetCurrencyRatesApiV1CurrencyRateGet.
type GetCurrencyRatesApiV1CurrencyRateGetParams struct {
	Active *bool `form:"active,omitempty" json:"active,omitempty"`

	// XClientName Наза клієнту або сервісу що інтегрується з API, наприклад 'My Custom SDK'
	XClientName *string `json:"X-Client-Name,omitempty"`

	// XClientVersion Номер версії клінту що інтегрується з API, наприклад 'v1.2.5'
	XClientVersion *string `json:"X-Client-Version,omitempty"`

	// XAccessKey Ключ доступу інтеграції (тільки для авторизованих API інтеграцій)
	XAccessKey *string `json:"X-Access-Key,omitempty"`
}

// SetupCurrencyRatesApiV1CurrencyRateSetupPostParams defines parameters for SetupCurrencyRatesApiV1CurrencyRateSetupPost.
type SetupCurrencyRatesApiV1CurrencyRateSetupPostParams struct {
	// XClientName Наза клієнту або сервісу що інтегрується з API, наприклад 'My Custom SDK'
	XClientName *string `json:"X-Client-Name,omitempty"`

	// XClientVersion Номер версії клінту що інтегрується з API, наприклад 'v1.2.5'
	XClientVersion *string `json:"X-Client-Version,omitempty"`

	// XAccessKey Ключ доступу інтеграції (тільки для авторизованих API інтеграцій)
	XAccessKey *string `json:"X-Access-Key,omitempty"`
}

// GetCurrencyRateApiV1CurrencyRateCurrencyCodeGetParams defines parameters for GetCurrencyRateApiV1CurrencyRateCurrencyCodeGet.
type GetCurrencyRateApiV1CurrencyRateCurrencyCodeGetParams struct {
	// XClientName Наза клієнту або сервісу що інтегрується з API, наприклад 'My Custom SDK'
	XClientName *string `json:"X-Client-Name,omitempty"`

	// XClientVersion Номер версії клінту що інтегрується з API, наприклад 'v1.2.5'
	XClientVersion *string `json:"X-Client-Version,omitempty"`

	// XAccessKey Ключ доступу інтеграції (тільки для авторизованих API інтеграцій)
	XAccessKey *string `json:"X-Access-Key,omitempty"`
}

// GoodsReportApiV1ExtendedReportsGoodsPostParams defines parameters for GoodsReportApiV1ExtendedReportsGoodsPost.
type GoodsReportApiV1ExtendedReportsGoodsPostParams struct {
	// XClientName Наза клієнту або сервісу що інтегрується з API, наприклад 'My Custom SDK'
	XClientName *string `json:"X-Client-Name,omitempty"`

	// XClientVersion Номер версії клінту що інтегрується з API, наприклад 'v1.2.5'
	XClientVersion *string `json:"X-Client-Version,omitempty"`

	// XAccessKey Ключ доступу інтеграції (тільки для авторизованих API інтеграцій)
	XAccessKey *string `json:"X-Access-Key,omitempty"`
}

// GetReportTaskByIdApiV1ExtendedReportsReportTaskIdGetParams defines parameters for GetReportTaskByIdApiV1ExtendedReportsReportTaskIdGet.
type GetReportTaskByIdApiV1ExtendedReportsReportTaskIdGetParams struct {
	// XClientName Наза клієнту або сервісу що інтегрується з API, наприклад 'My Custom SDK'
	XClientName *string `json:"X-Client-Name,omitempty"`

	// XClientVersion Номер версії клінту що інтегрується з API, наприклад 'v1.2.5'
	XClientVersion *string `json:"X-Client-Version,omitempty"`

	// XAccessKey Ключ доступу інтеграції (тільки для авторизованих API інтеграцій)
	XAccessKey *string `json:"X-Access-Key,omitempty"`
}

// GetReportXlsxByIdApiV1ExtendedReportsReportTaskIdReportXlsxGetParams defines parameters for GetReportXlsxByIdApiV1ExtendedReportsReportTaskIdReportXlsxGet.
type GetReportXlsxByIdApiV1ExtendedReportsReportTaskIdReportXlsxGetParams struct {
	// XClientName Наза клієнту або сервісу що інтегрується з API, наприклад 'My Custom SDK'
	XClientName *string `json:"X-Client-Name,omitempty"`

	// XClientVersion Номер версії клінту що інтегрується з API, наприклад 'v1.2.5'
	XClientVersion *string `json:"X-Client-Version,omitempty"`

	// XAccessKey Ключ доступу інтеграції (тільки для авторизованих API інтеграцій)
	XAccessKey *string `json:"X-Access-Key,omitempty"`
}

// GetGoodsApiV1GoodsGetParams defines parameters for GetGoodsApiV1GoodsGet.
type GetGoodsApiV1GoodsGetParams struct {
	// Name Пошук за назвою (Буде видалено, використовуйте параметр query)
	Name *string `form:"name,omitempty" json:"name,omitempty"`

	// Barcode Пошук за штрихкодом (Буде видалено, використовуйте параметр query)
	Barcode *string `form:"barcode,omitempty" json:"barcode,omitempty"`

	// Query Пошук товарів
	Query *string `form:"query,omitempty" json:"query,omitempty"`

	// OrderByName Сортування по назві
	OrderByName *GoodsIntegrationOrdering `form:"order_by_name,omitempty" json:"order_by_name,omitempty"`

	// OrderByCode Сортування по коду
	OrderByCode *GoodsIntegrationOrdering `form:"order_by_code,omitempty" json:"order_by_code,omitempty"`

	// OrderByPosition Сортування по позиції
	OrderByPosition *GoodsIntegrationOrdering `form:"order_by_position,omitempty" json:"order_by_position,omitempty"`
	Limit           *int                      `form:"limit,omitempty" json:"limit,omitempty"`
	Offset          *int                      `form:"offset,omitempty" json:"offset,omitempty"`

	// XClientName Наза клієнту або сервісу що інтегрується з API, наприклад 'My Custom SDK'
	XClientName *string `json:"X-Client-Name,omitempty"`

	// XClientVersion Номер версії клінту що інтегрується з API, наприклад 'v1.2.5'
	XClientVersion *string `json:"X-Client-Version,omitempty"`

	// XAccessKey Ключ доступу інтеграції (тільки для авторизованих API інтеграцій)
	XAccessKey *string `json:"X-Access-Key,omitempty"`
}

// ExportGoodsFileApiV1GoodsExportFileTaskIdGetParams defines parameters for ExportGoodsFileApiV1GoodsExportFileTaskIdGet.
type ExportGoodsFileApiV1GoodsExportFileTaskIdGetParams struct {
	// ChunkNumber Номер частини експорту товарів (експорт у json)
	ChunkNumber *int `form:"chunk_number,omitempty" json:"chunk_number,omitempty"`

	// XClientName Наза клієнту або сервісу що інтегрується з API, наприклад 'My Custom SDK'
	XClientName *string `json:"X-Client-Name,omitempty"`

	// XClientVersion Номер версії клінту що інтегрується з API, наприклад 'v1.2.5'
	XClientVersion *string `json:"X-Client-Version,omitempty"`

	// XAccessKey Ключ доступу інтеграції (тільки для авторизованих API інтеграцій)
	XAccessKey *string `json:"X-Access-Key,omitempty"`
}

// ExportGoodsTaskStatusApiV1GoodsExportTaskStatusTaskIdGetParams defines parameters for ExportGoodsTaskStatusApiV1GoodsExportTaskStatusTaskIdGet.
type ExportGoodsTaskStatusApiV1GoodsExportTaskStatusTaskIdGetParams struct {
	// XClientName Наза клієнту або сервісу що інтегрується з API, наприклад 'My Custom SDK'
	XClientName *string `json:"X-Client-Name,omitempty"`

	// XClientVersion Номер версії клінту що інтегрується з API, наприклад 'v1.2.5'
	XClientVersion *string `json:"X-Client-Version,omitempty"`

	// XAccessKey Ключ доступу інтеграції (тільки для авторизованих API інтеграцій)
	XAccessKey *string `json:"X-Access-Key,omitempty"`
}

// ExportGoodsApiV1GoodsExportExportExtensionGetParams defines parameters for ExportGoodsApiV1GoodsExportExportExtensionGet.
type ExportGoodsApiV1GoodsExportExportExtensionGetParams struct {
	// XClientName Наза клієнту або сервісу що інтегрується з API, наприклад 'My Custom SDK'
	XClientName *string `json:"X-Client-Name,omitempty"`

	// XClientVersion Номер версії клінту що інтегрується з API, наприклад 'v1.2.5'
	XClientVersion *string `json:"X-Client-Version,omitempty"`

	// XAccessKey Ключ доступу інтеграції (тільки для авторизованих API інтеграцій)
	XAccessKey *string `json:"X-Access-Key,omitempty"`
}

// ImportGoodsApplyChangesApiV1GoodsImportApplyChangesTaskIdPostParams defines parameters for ImportGoodsApplyChangesApiV1GoodsImportApplyChangesTaskIdPost.
type ImportGoodsApplyChangesApiV1GoodsImportApplyChangesTaskIdPostParams struct {
	// XClientName Наза клієнту або сервісу що інтегрується з API, наприклад 'My Custom SDK'
	XClientName *string `json:"X-Client-Name,omitempty"`

	// XClientVersion Номер версії клінту що інтегрується з API, наприклад 'v1.2.5'
	XClientVersion *string `json:"X-Client-Version,omitempty"`

	// XAccessKey Ключ доступу інтеграції (тільки для авторизованих API інтеграцій)
	XAccessKey *string `json:"X-Access-Key,omitempty"`
}

// ImportGoodsTaskStatusApiV1GoodsImportTaskStatusTaskIdGetParams defines parameters for ImportGoodsTaskStatusApiV1GoodsImportTaskStatusTaskIdGet.
type ImportGoodsTaskStatusApiV1GoodsImportTaskStatusTaskIdGetParams struct {
	// XClientName Наза клієнту або сервісу що інтегрується з API, наприклад 'My Custom SDK'
	XClientName *string `json:"X-Client-Name,omitempty"`

	// XClientVersion Номер версії клінту що інтегрується з API, наприклад 'v1.2.5'
	XClientVersion *string `json:"X-Client-Version,omitempty"`

	// XAccessKey Ключ доступу інтеграції (тільки для авторизованих API інтеграцій)
	XAccessKey *string `json:"X-Access-Key,omitempty"`
}

// ImportGoodsFromFileApiV1GoodsImportUploadPostParams defines parameters for ImportGoodsFromFileApiV1GoodsImportUploadPost.
type ImportGoodsFromFileApiV1GoodsImportUploadPostParams struct {
	// XClientName Наза клієнту або сервісу що інтегрується з API, наприклад 'My Custom SDK'
	XClientName *string `json:"X-Client-Name,omitempty"`

	// XClientVersion Номер версії клінту що інтегрується з API, наприклад 'v1.2.5'
	XClientVersion *string `json:"X-Client-Version,omitempty"`

	// XAccessKey Ключ доступу інтеграції (тільки для авторизованих API інтеграцій)
	XAccessKey *string `json:"X-Access-Key,omitempty"`
}

// GetGoodApiV1GoodsGoodIdGetParams defines parameters for GetGoodApiV1GoodsGoodIdGet.
type GetGoodApiV1GoodsGoodIdGetParams struct {
	// XClientName Наза клієнту або сервісу що інтегрується з API, наприклад 'My Custom SDK'
	XClientName *string `json:"X-Client-Name,omitempty"`

	// XClientVersion Номер версії клінту що інтегрується з API, наприклад 'v1.2.5'
	XClientVersion *string `json:"X-Client-Version,omitempty"`

	// XAccessKey Ключ доступу інтеграції (тільки для авторизованих API інтеграцій)
	XAccessKey *string `json:"X-Access-Key,omitempty"`
}

// GetOrdersApiV1OrdersGetParams defines parameters for GetOrdersApiV1OrdersGet.
type GetOrdersApiV1OrdersGetParams struct {
	Desc      *bool          `form:"desc,omitempty" json:"desc,omitempty"`
	Status    *[]OrderStatus `form:"status,omitempty" json:"status,omitempty"`
	StockCode *string        `form:"stock_code,omitempty" json:"stock_code,omitempty"`
	Limit     *int           `form:"limit,omitempty" json:"limit,omitempty"`
	Offset    *int           `form:"offset,omitempty" json:"offset,omitempty"`

	// XClientName Наза клієнту або сервісу що інтегрується з API, наприклад 'My Custom SDK'
	XClientName *string `json:"X-Client-Name,omitempty"`

	// XClientVersion Номер версії клінту що інтегрується з API, наприклад 'v1.2.5'
	XClientVersion *string `json:"X-Client-Version,omitempty"`

	// XAccessKey Ключ доступу інтеграції (тільки для авторизованих API інтеграцій)
	XAccessKey *string `json:"X-Access-Key,omitempty"`
}

// AddOrdersApiV1OrdersPostJSONBody defines parameters for AddOrdersApiV1OrdersPost.
type AddOrdersApiV1OrdersPostJSONBody struct {
	union json.RawMessage
}

// AddOrdersApiV1OrdersPostParams defines parameters for AddOrdersApiV1OrdersPost.
type AddOrdersApiV1OrdersPostParams struct {
	// XClientName Наза клієнту або сервісу що інтегрується з API, наприклад 'My Custom SDK'
	XClientName *string `json:"X-Client-Name,omitempty"`

	// XClientVersion Номер версії клінту що інтегрується з API, наприклад 'v1.2.5'
	XClientVersion *string `json:"X-Client-Version,omitempty"`

	// XAccessKey Ключ доступу інтеграції (тільки для авторизованих API інтеграцій)
	XAccessKey *string `json:"X-Access-Key,omitempty"`
}

// AddOrdersApiV1OrdersPostJSONBody0 defines parameters for AddOrdersApiV1OrdersPost.
type AddOrdersApiV1OrdersPostJSONBody0 = []CreateOrderModel

// CloseNotFiscalizeOrderApiV1OrdersClosePatchParams defines parameters for CloseNotFiscalizeOrderApiV1OrdersClosePatch.
type CloseNotFiscalizeOrderApiV1OrdersClosePatchParams struct {
	OrderId openapi_types.UUID `form:"order_id" json:"order_id"`

	// XClientName Наза клієнту або сервісу що інтегрується з API, наприклад 'My Custom SDK'
	XClientName *string `json:"X-Client-Name,omitempty"`

	// XClientVersion Номер версії клінту що інтегрується з API, наприклад 'v1.2.5'
	XClientVersion *string `json:"X-Client-Version,omitempty"`

	// XAccessKey Ключ доступу інтеграції (тільки для авторизованих API інтеграцій)
	XAccessKey *string `json:"X-Access-Key,omitempty"`
}

// UpdateCustomOrderStatusApiV1OrdersCustomStatusOrderIdPatchParams defines parameters for UpdateCustomOrderStatusApiV1OrdersCustomStatusOrderIdPatch.
type UpdateCustomOrderStatusApiV1OrdersCustomStatusOrderIdPatchParams struct {
	// NewStatus Новий статус замовлення
	NewStatus CustomOrderStatus `form:"new_status" json:"new_status"`

	// XClientName Наза клієнту або сервісу що інтегрується з API, наприклад 'My Custom SDK'
	XClientName *string `json:"X-Client-Name,omitempty"`

	// XClientVersion Номер версії клінту що інтегрується з API, наприклад 'v1.2.5'
	XClientVersion *string `json:"X-Client-Version,omitempty"`

	// XAccessKey Ключ доступу інтеграції (тільки для авторизованих API інтеграцій)
	XAccessKey *string `json:"X-Access-Key,omitempty"`
}

// DeleteIntegrationApiV1OrdersIntegrationDeleteParams defines parameters for DeleteIntegrationApiV1OrdersIntegrationDelete.
type DeleteIntegrationApiV1OrdersIntegrationDeleteParams struct {
	// XClientName Наза клієнту або сервісу що інтегрується з API, наприклад 'My Custom SDK'
	XClientName *string `json:"X-Client-Name,omitempty"`

	// XClientVersion Номер версії клінту що інтегрується з API, наприклад 'v1.2.5'
	XClientVersion *string `json:"X-Client-Version,omitempty"`

	// XAccessKey Ключ доступу інтеграції (тільки для авторизованих API інтеграцій)
	XAccessKey *string `json:"X-Access-Key,omitempty"`
}

// GetIntegrationApiV1OrdersIntegrationGetParams defines parameters for GetIntegrationApiV1OrdersIntegrationGet.
type GetIntegrationApiV1OrdersIntegrationGetParams struct {
	// XClientName Наза клієнту або сервісу що інтегрується з API, наприклад 'My Custom SDK'
	XClientName *string `json:"X-Client-Name,omitempty"`

	// XClientVersion Номер версії клінту що інтегрується з API, наприклад 'v1.2.5'
	XClientVersion *string `json:"X-Client-Version,omitempty"`

	// XAccessKey Ключ доступу інтеграції (тільки для авторизованих API інтеграцій)
	XAccessKey *string `json:"X-Access-Key,omitempty"`
}

// SetIntegrationApiV1OrdersIntegrationPostParams defines parameters for SetIntegrationApiV1OrdersIntegrationPost.
type SetIntegrationApiV1OrdersIntegrationPostParams struct {
	// XClientName Наза клієнту або сервісу що інтегрується з API, наприклад 'My Custom SDK'
	XClientName *string `json:"X-Client-Name,omitempty"`

	// XClientVersion Номер версії клінту що інтегрується з API, наприклад 'v1.2.5'
	XClientVersion *string `json:"X-Client-Version,omitempty"`

	// XAccessKey Ключ доступу інтеграції (тільки для авторизованих API інтеграцій)
	XAccessKey *string `json:"X-Access-Key,omitempty"`
}

// EditOrderApiV1OrdersIntegrationEditOrderPostParams defines parameters for EditOrderApiV1OrdersIntegrationEditOrderPost.
type EditOrderApiV1OrdersIntegrationEditOrderPostParams struct {
	// XClientName Наза клієнту або сервісу що інтегрується з API, наприклад 'My Custom SDK'
	XClientName *string `json:"X-Client-Name,omitempty"`

	// XClientVersion Номер версії клінту що інтегрується з API, наприклад 'v1.2.5'
	XClientVersion *string `json:"X-Client-Version,omitempty"`

	// XAccessKey Ключ доступу інтеграції (тільки для авторизованих API інтеграцій)
	XAccessKey *string `json:"X-Access-Key,omitempty"`
}

// RunOrdersSynchronizationApiV1OrdersSyncPostParams defines parameters for RunOrdersSynchronizationApiV1OrdersSyncPost.
type RunOrdersSynchronizationApiV1OrdersSyncPostParams struct {
	// XClientName Наза клієнту або сервісу що інтегрується з API, наприклад 'My Custom SDK'
	XClientName *string `json:"X-Client-Name,omitempty"`

	// XClientVersion Номер версії клінту що інтегрується з API, наприклад 'v1.2.5'
	XClientVersion *string `json:"X-Client-Version,omitempty"`

	// XAccessKey Ключ доступу інтеграції (тільки для авторизованих API інтеграцій)
	XAccessKey *string `json:"X-Access-Key,omitempty"`
}

// GetOrderApiV1OrdersOrderIdGetParams defines parameters for GetOrderApiV1OrdersOrderIdGet.
type GetOrderApiV1OrdersOrderIdGetParams struct {
	// XClientName Наза клієнту або сервісу що інтегрується з API, наприклад 'My Custom SDK'
	XClientName *string `json:"X-Client-Name,omitempty"`

	// XClientVersion Номер версії клінту що інтегрується з API, наприклад 'v1.2.5'
	XClientVersion *string `json:"X-Client-Version,omitempty"`

	// XAccessKey Ключ доступу інтеграції (тільки для авторизованих API інтеграцій)
	XAccessKey *string `json:"X-Access-Key,omitempty"`
}

// CancelOrderApiV1OrdersOrderIdPatchParams defines parameters for CancelOrderApiV1OrdersOrderIdPatch.
type CancelOrderApiV1OrdersOrderIdPatchParams struct {
	// XClientName Наза клієнту або сервісу що інтегрується з API, наприклад 'My Custom SDK'
	XClientName *string `json:"X-Client-Name,omitempty"`

	// XClientVersion Номер версії клінту що інтегрується з API, наприклад 'v1.2.5'
	XClientVersion *string `json:"X-Client-Version,omitempty"`

	// XAccessKey Ключ доступу інтеграції (тільки для авторизованих API інтеграцій)
	XAccessKey *string `json:"X-Access-Key,omitempty"`
}

// GetCurrentOrganizationLogoApiV1OrganizationLogoPngGetParams defines parameters for GetCurrentOrganizationLogoApiV1OrganizationLogoPngGet.
type GetCurrentOrganizationLogoApiV1OrganizationLogoPngGetParams struct {
	// XClientName Наза клієнту або сервісу що інтегрується з API, наприклад 'My Custom SDK'
	XClientName *string `json:"X-Client-Name,omitempty"`

	// XClientVersion Номер версії клінту що інтегрується з API, наприклад 'v1.2.5'
	XClientVersion *string `json:"X-Client-Version,omitempty"`

	// XAccessKey Ключ доступу інтеграції (тільки для авторизованих API інтеграцій)
	XAccessKey *string `json:"X-Access-Key,omitempty"`
}

// GetCurrentOrganizationReceiptSettingsApiV1OrganizationReceiptConfigGetParams defines parameters for GetCurrentOrganizationReceiptSettingsApiV1OrganizationReceiptConfigGet.
type GetCurrentOrganizationReceiptSettingsApiV1OrganizationReceiptConfigGetParams struct {
	// XClientName Наза клієнту або сервісу що інтегрується з API, наприклад 'My Custom SDK'
	XClientName *string `json:"X-Client-Name,omitempty"`

	// XClientVersion Номер версії клінту що інтегрується з API, наприклад 'v1.2.5'
	XClientVersion *string `json:"X-Client-Version,omitempty"`

	// XAccessKey Ключ доступу інтеграції (тільки для авторизованих API інтеграцій)
	XAccessKey *string `json:"X-Access-Key,omitempty"`
}

// GetCurrentOrganizationSmsBillingBalanceApiV1OrganizationSmsBillingGetParams defines parameters for GetCurrentOrganizationSmsBillingBalanceApiV1OrganizationSmsBillingGet.
type GetCurrentOrganizationSmsBillingBalanceApiV1OrganizationSmsBillingGetParams struct {
	// XClientName Наза клієнту або сервісу що інтегрується з API, наприклад 'My Custom SDK'
	XClientName *string `json:"X-Client-Name,omitempty"`

	// XClientVersion Номер версії клінту що інтегрується з API, наприклад 'v1.2.5'
	XClientVersion *string `json:"X-Client-Version,omitempty"`

	// XAccessKey Ключ доступу інтеграції (тільки для авторизованих API інтеграцій)
	XAccessKey *string `json:"X-Access-Key,omitempty"`
}

// GetCurrentOrganizationTextLogoApiV1OrganizationTextLogoPngGetParams defines parameters for GetCurrentOrganizationTextLogoApiV1OrganizationTextLogoPngGet.
type GetCurrentOrganizationTextLogoApiV1OrganizationTextLogoPngGetParams struct {
	// XClientName Наза клієнту або сервісу що інтегрується з API, наприклад 'My Custom SDK'
	XClientName *string `json:"X-Client-Name,omitempty"`

	// XClientVersion Номер версії клінту що інтегрується з API, наприклад 'v1.2.5'
	XClientVersion *string `json:"X-Client-Version,omitempty"`

	// XAccessKey Ключ доступу інтеграції (тільки для авторизованих API інтеграцій)
	XAccessKey *string `json:"X-Access-Key,omitempty"`
}

// GetReceiptsApiV1ReceiptsGetParams defines parameters for GetReceiptsApiV1ReceiptsGet.
type GetReceiptsApiV1ReceiptsGetParams struct {
	// FiscalCode Фіскальний номер
	FiscalCode *string `form:"fiscal_code,omitempty" json:"fiscal_code,omitempty"`

	// Serial Порядковий номер
	Serial *string `form:"serial,omitempty" json:"serial,omitempty"`

	// Desc Зворотній порядок сортування
	Desc   *bool `form:"desc,omitempty" json:"desc,omitempty"`
	Limit  *int  `form:"limit,omitempty" json:"limit,omitempty"`
	Offset *int  `form:"offset,omitempty" json:"offset,omitempty"`

	// XClientName Наза клієнту або сервісу що інтегрується з API, наприклад 'My Custom SDK'
	XClientName *string `json:"X-Client-Name,omitempty"`

	// XClientVersion Номер версії клінту що інтегрується з API, наприклад 'v1.2.5'
	XClientVersion *string `json:"X-Client-Version,omitempty"`

	// XAccessKey Ключ доступу інтеграції (тільки для авторизованих API інтеграцій)
	XAccessKey *string `json:"X-Access-Key,omitempty"`
}

// AddExternalReceiptApiV1ReceiptsAddExternalPostParams defines parameters for AddExternalReceiptApiV1ReceiptsAddExternalPost.
type AddExternalReceiptApiV1ReceiptsAddExternalPostParams struct {
	// XClientName Наза клієнту або сервісу що інтегрується з API, наприклад 'My Custom SDK'
	XClientName *string `json:"X-Client-Name,omitempty"`

	// XClientVersion Номер версії клінту що інтегрується з API, наприклад 'v1.2.5'
	XClientVersion *string `json:"X-Client-Version,omitempty"`

	// XAccessKey Ключ доступу інтеграції (тільки для авторизованих API інтеграцій)
	XAccessKey *string `json:"X-Access-Key,omitempty"`

	// XDeviceID ID RRO Agent або мобільного пристрою каси (Для блокування дублікатів)
	XDeviceID *string `json:"X-Device-ID,omitempty"`
}

// CashWithdrawalApiV1ReceiptsCashWithdrawalPostParams defines parameters for CashWithdrawalApiV1ReceiptsCashWithdrawalPost.
type CashWithdrawalApiV1ReceiptsCashWithdrawalPostParams struct {
	// XClientName Наза клієнту або сервісу що інтегрується з API, наприклад 'My Custom SDK'
	XClientName *string `json:"X-Client-Name,omitempty"`

	// XClientVersion Номер версії клінту що інтегрується з API, наприклад 'v1.2.5'
	XClientVersion *string `json:"X-Client-Version,omitempty"`

	// XAccessKey Ключ доступу інтеграції (тільки для авторизованих API інтеграцій)
	XAccessKey *string `json:"X-Access-Key,omitempty"`

	// XDeviceID ID RRO Agent або мобільного пристрою каси (Для блокування дублікатів)
	XDeviceID *string `json:"X-Device-ID,omitempty"`
}

// ExchangeApiV1ReceiptsCurrencyExchangePostParams defines parameters for ExchangeApiV1ReceiptsCurrencyExchangePost.
type ExchangeApiV1ReceiptsCurrencyExchangePostParams struct {
	// XClientName Наза клієнту або сервісу що інтегрується з API, наприклад 'My Custom SDK'
	XClientName *string `json:"X-Client-Name,omitempty"`

	// XClientVersion Номер версії клінту що інтегрується з API, наприклад 'v1.2.5'
	XClientVersion *string `json:"X-Client-Version,omitempty"`

	// XAccessKey Ключ доступу інтеграції (тільки для авторизованих API інтеграцій)
	XAccessKey *string `json:"X-Access-Key,omitempty"`
}

// GetReceiptsSearchApiV1ReceiptsSearchGetParams defines parameters for GetReceiptsSearchApiV1ReceiptsSearchGet.
type GetReceiptsSearchApiV1ReceiptsSearchGetParams struct {
	// FiscalCode Фіскальний номер чека
	FiscalCode *string `form:"fiscal_code,omitempty" json:"fiscal_code,omitempty"`

	// Barcode Пошук за штрихкодом чеку
	Barcode *string `form:"barcode,omitempty" json:"barcode,omitempty"`

	// ShiftId Фільтрування зміни
	ShiftId *[]openapi_types.UUID `form:"shift_id,omitempty" json:"shift_id,omitempty"`

	// BranchId Фільтрування торгової точки
	BranchId *[]openapi_types.UUID `form:"branch_id,omitempty" json:"branch_id,omitempty"`

	// CashRegisterId Фільтрування каси
	CashRegisterId *[]openapi_types.UUID `form:"cash_register_id,omitempty" json:"cash_register_id,omitempty"`

	// FromDate Чеки починаючи з дати
	FromDate *time.Time `form:"from_date,omitempty" json:"from_date,omitempty"`

	// ToDate Чеки раніше обраної дати
	ToDate *time.Time `form:"to_date,omitempty" json:"to_date,omitempty"`

	// Desc Зворотній порядок сортування
	Desc *bool `form:"desc,omitempty" json:"desc,omitempty"`

	// SelfReceipts Показувати тільки власні чеки
	SelfReceipts *bool `form:"self_receipts,omitempty" json:"self_receipts,omitempty"`
	Limit        *int  `form:"limit,omitempty" json:"limit,omitempty"`
	Offset       *int  `form:"offset,omitempty" json:"offset,omitempty"`

	// XClientName Наза клієнту або сервісу що інтегрується з API, наприклад 'My Custom SDK'
	XClientName *string `json:"X-Client-Name,omitempty"`

	// XClientVersion Номер версії клінту що інтегрується з API, наприклад 'v1.2.5'
	XClientVersion *string `json:"X-Client-Version,omitempty"`

	// XAccessKey Ключ доступу інтеграції (тільки для авторизованих API інтеграцій)
	XAccessKey *string `json:"X-Access-Key,omitempty"`
}

// CreateReceiptApiV1ReceiptsSellPostParams defines parameters for CreateReceiptApiV1ReceiptsSellPost.
type CreateReceiptApiV1ReceiptsSellPostParams struct {
	// XClientName Наза клієнту або сервісу що інтегрується з API, наприклад 'My Custom SDK'
	XClientName *string `json:"X-Client-Name,omitempty"`

	// XClientVersion Номер версії клінту що інтегрується з API, наприклад 'v1.2.5'
	XClientVersion *string `json:"X-Client-Version,omitempty"`

	// XAccessKey Ключ доступу інтеграції (тільки для авторизованих API інтеграцій)
	XAccessKey *string `json:"X-Access-Key,omitempty"`

	// XDeviceID ID RRO Agent або мобільного пристрою каси (Для блокування дублікатів)
	XDeviceID *string `json:"X-Device-ID,omitempty"`
}

// CreateOfflineReceiptApiV1ReceiptsSellOfflinePostParams defines parameters for CreateOfflineReceiptApiV1ReceiptsSellOfflinePost.
type CreateOfflineReceiptApiV1ReceiptsSellOfflinePostParams struct {
	// XClientName Наза клієнту або сервісу що інтегрується з API, наприклад 'My Custom SDK'
	XClientName *string `json:"X-Client-Name,omitempty"`

	// XClientVersion Номер версії клінту що інтегрується з API, наприклад 'v1.2.5'
	XClientVersion *string `json:"X-Client-Version,omitempty"`

	// XAccessKey Ключ доступу інтеграції (тільки для авторизованих API інтеграцій)
	XAccessKey *string `json:"X-Access-Key,omitempty"`

	// XDeviceID ID RRO Agent або мобільного пристрою каси (Для блокування дублікатів)
	XDeviceID *string `json:"X-Device-ID,omitempty"`
}

// CreateServiceReceiptApiV1ReceiptsServicePostParams defines parameters for CreateServiceReceiptApiV1ReceiptsServicePost.
type CreateServiceReceiptApiV1ReceiptsServicePostParams struct {
	// XClientName Наза клієнту або сервісу що інтегрується з API, наприклад 'My Custom SDK'
	XClientName *string `json:"X-Client-Name,omitempty"`

	// XClientVersion Номер версії клінту що інтегрується з API, наприклад 'v1.2.5'
	XClientVersion *string `json:"X-Client-Version,omitempty"`

	// XAccessKey Ключ доступу інтеграції (тільки для авторизованих API інтеграцій)
	XAccessKey *string `json:"X-Access-Key,omitempty"`

	// XDeviceID ID RRO Agent або мобільного пристрою каси (Для блокування дублікатів)
	XDeviceID *string `json:"X-Device-ID,omitempty"`
}

// CreateServiceCurrencyReceiptApiV1ReceiptsServiceCurrencyPostParams defines parameters for CreateServiceCurrencyReceiptApiV1ReceiptsServiceCurrencyPost.
type CreateServiceCurrencyReceiptApiV1ReceiptsServiceCurrencyPostParams struct {
	// XClientName Наза клієнту або сервісу що інтегрується з API, наприклад 'My Custom SDK'
	XClientName *string `json:"X-Client-Name,omitempty"`

	// XClientVersion Номер версії клінту що інтегрується з API, наприклад 'v1.2.5'
	XClientVersion *string `json:"X-Client-Version,omitempty"`

	// XAccessKey Ключ доступу інтеграції (тільки для авторизованих API інтеграцій)
	XAccessKey *string `json:"X-Access-Key,omitempty"`
}

// GetReceiptApiV1ReceiptsReceiptIdGetParams defines parameters for GetReceiptApiV1ReceiptsReceiptIdGet.
type GetReceiptApiV1ReceiptsReceiptIdGetParams struct {
	// XClientName Наза клієнту або сервісу що інтегрується з API, наприклад 'My Custom SDK'
	XClientName *string `json:"X-Client-Name,omitempty"`

	// XClientVersion Номер версії клінту що інтегрується з API, наприклад 'v1.2.5'
	XClientVersion *string `json:"X-Client-Version,omitempty"`

	// XAccessKey Ключ доступу інтеграції (тільки для авторизованих API інтеграцій)
	XAccessKey *string `json:"X-Access-Key,omitempty"`
}

// GetReceiptApiV1ReceiptsReceiptIdGetParamsReceiptId0 defines parameters for GetReceiptApiV1ReceiptsReceiptIdGet.
type GetReceiptApiV1ReceiptsReceiptIdGetParamsReceiptId0 = openapi_types.UUID

// GetReceiptApiV1ReceiptsReceiptIdGetParamsReceiptId1 defines parameters for GetReceiptApiV1ReceiptsReceiptIdGet.
type GetReceiptApiV1ReceiptsReceiptIdGetParamsReceiptId1 = string

// SendReceiptToEmailApiV1ReceiptsReceiptIdEmailPostJSONBody defines parameters for SendReceiptToEmailApiV1ReceiptsReceiptIdEmailPost.
type SendReceiptToEmailApiV1ReceiptsReceiptIdEmailPostJSONBody = []openapi_types.Email

// SendReceiptToEmailApiV1ReceiptsReceiptIdEmailPostParams defines parameters for SendReceiptToEmailApiV1ReceiptsReceiptIdEmailPost.
type SendReceiptToEmailApiV1ReceiptsReceiptIdEmailPostParams struct {
	// XClientName Наза клієнту або сервісу що інтегрується з API, наприклад 'My Custom SDK'
	XClientName *string `json:"X-Client-Name,omitempty"`

	// XClientVersion Номер версії клінту що інтегрується з API, наприклад 'v1.2.5'
	XClientVersion *string `json:"X-Client-Version,omitempty"`

	// XAccessKey Ключ доступу інтеграції (тільки для авторизованих API інтеграцій)
	XAccessKey *string `json:"X-Access-Key,omitempty"`
}

// SendReceiptToEmailApiV1ReceiptsReceiptIdEmailPostParamsReceiptId0 defines parameters for SendReceiptToEmailApiV1ReceiptsReceiptIdEmailPost.
type SendReceiptToEmailApiV1ReceiptsReceiptIdEmailPostParamsReceiptId0 = openapi_types.UUID

// SendReceiptToEmailApiV1ReceiptsReceiptIdEmailPostParamsReceiptId1 defines parameters for SendReceiptToEmailApiV1ReceiptsReceiptIdEmailPost.
type SendReceiptToEmailApiV1ReceiptsReceiptIdEmailPostParamsReceiptId1 = string

// GetReceiptHtmlApiV1ReceiptsReceiptIdHtmlGetParams defines parameters for GetReceiptHtmlApiV1ReceiptsReceiptIdHtmlGet.
type GetReceiptHtmlApiV1ReceiptsReceiptIdHtmlGetParams struct {
	Simple *bool `form:"simple,omitempty" json:"simple,omitempty"`

	// XClientName Наза клієнту або сервісу що інтегрується з API, наприклад 'My Custom SDK'
	XClientName *string `json:"X-Client-Name,omitempty"`

	// XClientVersion Номер версії клінту що інтегрується з API, наприклад 'v1.2.5'
	XClientVersion *string `json:"X-Client-Version,omitempty"`

	// XAccessKey Ключ доступу інтеграції (тільки для авторизованих API інтеграцій)
	XAccessKey *string `json:"X-Access-Key,omitempty"`
}

// GetReceiptHtmlApiV1ReceiptsReceiptIdHtmlGetParamsReceiptId0 defines parameters for GetReceiptHtmlApiV1ReceiptsReceiptIdHtmlGet.
type GetReceiptHtmlApiV1ReceiptsReceiptIdHtmlGetParamsReceiptId0 = openapi_types.UUID

// GetReceiptHtmlApiV1ReceiptsReceiptIdHtmlGetParamsReceiptId1 defines parameters for GetReceiptHtmlApiV1ReceiptsReceiptIdHtmlGet.
type GetReceiptHtmlApiV1ReceiptsReceiptIdHtmlGetParamsReceiptId1 = string

// GetReceiptPdfApiV1ReceiptsReceiptIdPdfGetParams defines parameters for GetReceiptPdfApiV1ReceiptsReceiptIdPdfGet.
type GetReceiptPdfApiV1ReceiptsReceiptIdPdfGetParams struct {
	// XClientName Наза клієнту або сервісу що інтегрується з API, наприклад 'My Custom SDK'
	XClientName *string `json:"X-Client-Name,omitempty"`

	// XClientVersion Номер версії клінту що інтегрується з API, наприклад 'v1.2.5'
	XClientVersion *string `json:"X-Client-Version,omitempty"`

	// XAccessKey Ключ доступу інтеграції (тільки для авторизованих API інтеграцій)
	XAccessKey *string `json:"X-Access-Key,omitempty"`
}

// GetReceiptPdfApiV1ReceiptsReceiptIdPdfGetParamsReceiptId0 defines parameters for GetReceiptPdfApiV1ReceiptsReceiptIdPdfGet.
type GetReceiptPdfApiV1ReceiptsReceiptIdPdfGetParamsReceiptId0 = openapi_types.UUID

// GetReceiptPdfApiV1ReceiptsReceiptIdPdfGetParamsReceiptId1 defines parameters for GetReceiptPdfApiV1ReceiptsReceiptIdPdfGet.
type GetReceiptPdfApiV1ReceiptsReceiptIdPdfGetParamsReceiptId1 = string

// GetReceiptPngApiV1ReceiptsReceiptIdPngGetParams defines parameters for GetReceiptPngApiV1ReceiptsReceiptIdPngGet.
type GetReceiptPngApiV1ReceiptsReceiptIdPngGetParams struct {
	// Width Кількість символів у рядку
	Width *int `form:"width,omitempty" json:"width,omitempty"`

	// PaperWidth Ширина паперу у міліметрах
	PaperWidth *int `form:"paper_width,omitempty" json:"paper_width,omitempty"`

	// QrcodeScale Ширина QR-коду у відсотках від загальної ширини паперу
	QrcodeScale *int `form:"qrcode_scale,omitempty" json:"qrcode_scale,omitempty"`

	// XClientName Наза клієнту або сервісу що інтегрується з API, наприклад 'My Custom SDK'
	XClientName *string `json:"X-Client-Name,omitempty"`

	// XClientVersion Номер версії клінту що інтегрується з API, наприклад 'v1.2.5'
	XClientVersion *string `json:"X-Client-Version,omitempty"`

	// XAccessKey Ключ доступу інтеграції (тільки для авторизованих API інтеграцій)
	XAccessKey *string `json:"X-Access-Key,omitempty"`
}

// GetReceiptPngApiV1ReceiptsReceiptIdPngGetParamsReceiptId0 defines parameters for GetReceiptPngApiV1ReceiptsReceiptIdPngGet.
type GetReceiptPngApiV1ReceiptsReceiptIdPngGetParamsReceiptId0 = openapi_types.UUID

// GetReceiptPngApiV1ReceiptsReceiptIdPngGetParamsReceiptId1 defines parameters for GetReceiptPngApiV1ReceiptsReceiptIdPngGet.
type GetReceiptPngApiV1ReceiptsReceiptIdPngGetParamsReceiptId1 = string

// GetReceiptQrCodeImageApiV1ReceiptsReceiptIdQrcodeGetParams defines parameters for GetReceiptQrCodeImageApiV1ReceiptsReceiptIdQrcodeGet.
type GetReceiptQrCodeImageApiV1ReceiptsReceiptIdQrcodeGetParams struct {
	// XClientName Наза клієнту або сервісу що інтегрується з API, наприклад 'My Custom SDK'
	XClientName *string `json:"X-Client-Name,omitempty"`

	// XClientVersion Номер версії клінту що інтегрується з API, наприклад 'v1.2.5'
	XClientVersion *string `json:"X-Client-Version,omitempty"`

	// XAccessKey Ключ доступу інтеграції (тільки для авторизованих API інтеграцій)
	XAccessKey *string `json:"X-Access-Key,omitempty"`
}

// GetReceiptQrCodeImageApiV1ReceiptsReceiptIdQrcodeGetParamsReceiptId0 defines parameters for GetReceiptQrCodeImageApiV1ReceiptsReceiptIdQrcodeGet.
type GetReceiptQrCodeImageApiV1ReceiptsReceiptIdQrcodeGetParamsReceiptId0 = openapi_types.UUID

// GetReceiptQrCodeImageApiV1ReceiptsReceiptIdQrcodeGetParamsReceiptId1 defines parameters for GetReceiptQrCodeImageApiV1ReceiptsReceiptIdQrcodeGet.
type GetReceiptQrCodeImageApiV1ReceiptsReceiptIdQrcodeGetParamsReceiptId1 = string

// SendReceiptViaSmsApiV1ReceiptsReceiptIdSmsPostParams defines parameters for SendReceiptViaSmsApiV1ReceiptsReceiptIdSmsPost.
type SendReceiptViaSmsApiV1ReceiptsReceiptIdSmsPostParams struct {
	// XClientName Наза клієнту або сервісу що інтегрується з API, наприклад 'My Custom SDK'
	XClientName *string `json:"X-Client-Name,omitempty"`

	// XClientVersion Номер версії клінту що інтегрується з API, наприклад 'v1.2.5'
	XClientVersion *string `json:"X-Client-Version,omitempty"`

	// XAccessKey Ключ доступу інтеграції (тільки для авторизованих API інтеграцій)
	XAccessKey *string `json:"X-Access-Key,omitempty"`
}

// SendReceiptViaSmsApiV1ReceiptsReceiptIdSmsPostParamsReceiptId0 defines parameters for SendReceiptViaSmsApiV1ReceiptsReceiptIdSmsPost.
type SendReceiptViaSmsApiV1ReceiptsReceiptIdSmsPostParamsReceiptId0 = openapi_types.UUID

// SendReceiptViaSmsApiV1ReceiptsReceiptIdSmsPostParamsReceiptId1 defines parameters for SendReceiptViaSmsApiV1ReceiptsReceiptIdSmsPost.
type SendReceiptViaSmsApiV1ReceiptsReceiptIdSmsPostParamsReceiptId1 = string

// GetReceiptTextApiV1ReceiptsReceiptIdTextGetParams defines parameters for GetReceiptTextApiV1ReceiptsReceiptIdTextGet.
type GetReceiptTextApiV1ReceiptsReceiptIdTextGetParams struct {
	// Width Print area width in characters
	Width *int `form:"width,omitempty" json:"width,omitempty"`

	// XClientName Наза клієнту або сервісу що інтегрується з API, наприклад 'My Custom SDK'
	XClientName *string `json:"X-Client-Name,omitempty"`

	// XClientVersion Номер версії клінту що інтегрується з API, наприклад 'v1.2.5'
	XClientVersion *string `json:"X-Client-Version,omitempty"`

	// XAccessKey Ключ доступу інтеграції (тільки для авторизованих API інтеграцій)
	XAccessKey *string `json:"X-Access-Key,omitempty"`
}

// GetReceiptTextApiV1ReceiptsReceiptIdTextGetParamsReceiptId0 defines parameters for GetReceiptTextApiV1ReceiptsReceiptIdTextGet.
type GetReceiptTextApiV1ReceiptsReceiptIdTextGetParamsReceiptId0 = openapi_types.UUID

// GetReceiptTextApiV1ReceiptsReceiptIdTextGetParamsReceiptId1 defines parameters for GetReceiptTextApiV1ReceiptsReceiptIdTextGet.
type GetReceiptTextApiV1ReceiptsReceiptIdTextGetParamsReceiptId1 = string

// GetReceiptXmlApiV1ReceiptsReceiptIdXmlGetParams defines parameters for GetReceiptXmlApiV1ReceiptsReceiptIdXmlGet.
type GetReceiptXmlApiV1ReceiptsReceiptIdXmlGetParams struct {
	// XClientName Наза клієнту або сервісу що інтегрується з API, наприклад 'My Custom SDK'
	XClientName *string `json:"X-Client-Name,omitempty"`

	// XClientVersion Номер версії клінту що інтегрується з API, наприклад 'v1.2.5'
	XClientVersion *string `json:"X-Client-Version,omitempty"`

	// XAccessKey Ключ доступу інтеграції (тільки для авторизованих API інтеграцій)
	XAccessKey *string `json:"X-Access-Key,omitempty"`
}

// GetReceiptXmlApiV1ReceiptsReceiptIdXmlGetParamsReceiptId0 defines parameters for GetReceiptXmlApiV1ReceiptsReceiptIdXmlGet.
type GetReceiptXmlApiV1ReceiptsReceiptIdXmlGetParamsReceiptId0 = openapi_types.UUID

// GetReceiptXmlApiV1ReceiptsReceiptIdXmlGetParamsReceiptId1 defines parameters for GetReceiptXmlApiV1ReceiptsReceiptIdXmlGet.
type GetReceiptXmlApiV1ReceiptsReceiptIdXmlGetParamsReceiptId1 = string

// GetReportsApiV1ReportsGetParams defines parameters for GetReportsApiV1ReportsGet.
type GetReportsApiV1ReportsGetParams struct {
	FromDate  *time.Time            `form:"from_date,omitempty" json:"from_date,omitempty"`
	ToDate    *time.Time            `form:"to_date,omitempty" json:"to_date,omitempty"`
	ShiftId   *[]openapi_types.UUID `form:"shift_id,omitempty" json:"shift_id,omitempty"`
	Serial    *string               `form:"serial,omitempty" json:"serial,omitempty"`
	IsZReport *bool                 `form:"is_z_report,omitempty" json:"is_z_report,omitempty"`
	Desc      *bool                 `form:"desc,omitempty" json:"desc,omitempty"`
	Limit     *int                  `form:"limit,omitempty" json:"limit,omitempty"`
	Offset    *int                  `form:"offset,omitempty" json:"offset,omitempty"`

	// XClientName Наза клієнту або сервісу що інтегрується з API, наприклад 'My Custom SDK'
	XClientName *string `json:"X-Client-Name,omitempty"`

	// XClientVersion Номер версії клінту що інтегрується з API, наприклад 'v1.2.5'
	XClientVersion *string `json:"X-Client-Version,omitempty"`

	// XAccessKey Ключ доступу інтеграції (тільки для авторизованих API інтеграцій)
	XAccessKey *string `json:"X-Access-Key,omitempty"`
}

// CreateXReportApiV1ReportsPostParams defines parameters for CreateXReportApiV1ReportsPost.
type CreateXReportApiV1ReportsPostParams struct {
	// XClientName Наза клієнту або сервісу що інтегрується з API, наприклад 'My Custom SDK'
	XClientName *string `json:"X-Client-Name,omitempty"`

	// XClientVersion Номер версії клінту що інтегрується з API, наприклад 'v1.2.5'
	XClientVersion *string `json:"X-Client-Version,omitempty"`

	// XAccessKey Ключ доступу інтеграції (тільки для авторизованих API інтеграцій)
	XAccessKey *string `json:"X-Access-Key,omitempty"`
}

// AddExternalReportApiV1ReportsAddExternalPostParams defines parameters for AddExternalReportApiV1ReportsAddExternalPost.
type AddExternalReportApiV1ReportsAddExternalPostParams struct {
	// XClientName Наза клієнту або сервісу що інтегрується з API, наприклад 'My Custom SDK'
	XClientName *string `json:"X-Client-Name,omitempty"`

	// XClientVersion Номер версії клінту що інтегрується з API, наприклад 'v1.2.5'
	XClientVersion *string `json:"X-Client-Version,omitempty"`

	// XAccessKey Ключ доступу інтеграції (тільки для авторизованих API інтеграцій)
	XAccessKey *string `json:"X-Access-Key,omitempty"`
}

// GetPeriodicalReportApiV1ReportsPeriodicalGetParams defines parameters for GetPeriodicalReportApiV1ReportsPeriodicalGet.
type GetPeriodicalReportApiV1ReportsPeriodicalGetParams struct {
	FromDate time.Time `form:"from_date" json:"from_date"`
	ToDate   time.Time `form:"to_date" json:"to_date"`
	Width    *int      `form:"width,omitempty" json:"width,omitempty"`

	// XClientName Наза клієнту або сервісу що інтегрується з API, наприклад 'My Custom SDK'
	XClientName *string `json:"X-Client-Name,omitempty"`

	// XClientVersion Номер версії клінту що інтегрується з API, наприклад 'v1.2.5'
	XClientVersion *string `json:"X-Client-Version,omitempty"`

	// XAccessKey Ключ доступу інтеграції (тільки для авторизованих API інтеграцій)
	XAccessKey  *string `json:"X-Access-Key,omitempty"`
	XLicenseKey string  `json:"X-License-Key"`
}

// GetSearchReportsApiV1ReportsSearchGetParams defines parameters for GetSearchReportsApiV1ReportsSearchGet.
type GetSearchReportsApiV1ReportsSearchGetParams struct {
	FromDate       *time.Time            `form:"from_date,omitempty" json:"from_date,omitempty"`
	ToDate         *time.Time            `form:"to_date,omitempty" json:"to_date,omitempty"`
	ShiftId        *[]openapi_types.UUID `form:"shift_id,omitempty" json:"shift_id,omitempty"`
	Serial         *string               `form:"serial,omitempty" json:"serial,omitempty"`
	IsZReport      *bool                 `form:"is_z_report,omitempty" json:"is_z_report,omitempty"`
	Desc           *bool                 `form:"desc,omitempty" json:"desc,omitempty"`
	CashRegisterId *[]openapi_types.UUID `form:"cash_register_id,omitempty" json:"cash_register_id,omitempty"`
	Limit          *int                  `form:"limit,omitempty" json:"limit,omitempty"`
	Offset         *int                  `form:"offset,omitempty" json:"offset,omitempty"`

	// XClientName Наза клієнту або сервісу що інтегрується з API, наприклад 'My Custom SDK'
	XClientName *string `json:"X-Client-Name,omitempty"`

	// XClientVersion Номер версії клінту що інтегрується з API, наприклад 'v1.2.5'
	XClientVersion *string `json:"X-Client-Version,omitempty"`

	// XAccessKey Ключ доступу інтеграції (тільки для авторизованих API інтеграцій)
	XAccessKey *string `json:"X-Access-Key,omitempty"`
}

// GetReportApiV1ReportsReportIdGetParams defines parameters for GetReportApiV1ReportsReportIdGet.
type GetReportApiV1ReportsReportIdGetParams struct {
	// XClientName Наза клієнту або сервісу що інтегрується з API, наприклад 'My Custom SDK'
	XClientName *string `json:"X-Client-Name,omitempty"`

	// XClientVersion Номер версії клінту що інтегрується з API, наприклад 'v1.2.5'
	XClientVersion *string `json:"X-Client-Version,omitempty"`

	// XAccessKey Ключ доступу інтеграції (тільки для авторизованих API інтеграцій)
	XAccessKey *string `json:"X-Access-Key,omitempty"`
}

// GetReportTextApiV1ReportsReportIdTextGetParams defines parameters for GetReportTextApiV1ReportsReportIdTextGet.
type GetReportTextApiV1ReportsReportIdTextGetParams struct {
	// Width Print area width in characters
	Width *int `form:"width,omitempty" json:"width,omitempty"`

	// XClientName Наза клієнту або сервісу що інтегрується з API, наприклад 'My Custom SDK'
	XClientName *string `json:"X-Client-Name,omitempty"`

	// XClientVersion Номер версії клінту що інтегрується з API, наприклад 'v1.2.5'
	XClientVersion *string `json:"X-Client-Version,omitempty"`

	// XAccessKey Ключ доступу інтеграції (тільки для авторизованих API інтеграцій)
	XAccessKey *string `json:"X-Access-Key,omitempty"`
}

// GetShiftsApiV1ShiftsGetParams defines parameters for GetShiftsApiV1ShiftsGet.
type GetShiftsApiV1ShiftsGetParams struct {
	// Statuses Статус зміни
	Statuses *[]ShiftStatus `form:"statuses,omitempty" json:"statuses,omitempty"`

	// Desc Зворотній порядок сортування
	Desc   *bool `form:"desc,omitempty" json:"desc,omitempty"`
	Limit  *int  `form:"limit,omitempty" json:"limit,omitempty"`
	Offset *int  `form:"offset,omitempty" json:"offset,omitempty"`

	// XClientName Наза клієнту або сервісу що інтегрується з API, наприклад 'My Custom SDK'
	XClientName *string `json:"X-Client-Name,omitempty"`

	// XClientVersion Номер версії клінту що інтегрується з API, наприклад 'v1.2.5'
	XClientVersion *string `json:"X-Client-Version,omitempty"`

	// XAccessKey Ключ доступу інтеграції (тільки для авторизованих API інтеграцій)
	XAccessKey *string `json:"X-Access-Key,omitempty"`
}

// CreateShiftApiV1ShiftsPostParams defines parameters for CreateShiftApiV1ShiftsPost.
type CreateShiftApiV1ShiftsPostParams struct {
	// XClientName Наза клієнту або сервісу що інтегрується з API, наприклад 'My Custom SDK'
	XClientName *string `json:"X-Client-Name,omitempty"`

	// XClientVersion Номер версії клінту що інтегрується з API, наприклад 'v1.2.5'
	XClientVersion *string `json:"X-Client-Version,omitempty"`

	// XAccessKey Ключ доступу інтеграції (тільки для авторизованих API інтеграцій)
	XAccessKey *string `json:"X-Access-Key,omitempty"`

	// XDeviceID ID RRO Agent або мобільного пристрою каси (Для блокування дублікатів)
	XDeviceID   *string `json:"X-Device-ID,omitempty"`
	XLicenseKey string  `json:"X-License-Key"`
}

// CloseShiftApiV1ShiftsClosePostParams defines parameters for CloseShiftApiV1ShiftsClosePost.
type CloseShiftApiV1ShiftsClosePostParams struct {
	// XClientName Наза клієнту або сервісу що інтегрується з API, наприклад 'My Custom SDK'
	XClientName *string `json:"X-Client-Name,omitempty"`

	// XClientVersion Номер версії клінту що інтегрується з API, наприклад 'v1.2.5'
	XClientVersion *string `json:"X-Client-Version,omitempty"`

	// XAccessKey Ключ доступу інтеграції (тільки для авторизованих API інтеграцій)
	XAccessKey *string `json:"X-Access-Key,omitempty"`

	// XDeviceID ID RRO Agent або мобільного пристрою каси (Для блокування дублікатів)
	XDeviceID *string `json:"X-Device-ID,omitempty"`
}

// GetShiftApiV1ShiftsShiftIdGetParams defines parameters for GetShiftApiV1ShiftsShiftIdGet.
type GetShiftApiV1ShiftsShiftIdGetParams struct {
	// XClientName Наза клієнту або сервісу що інтегрується з API, наприклад 'My Custom SDK'
	XClientName *string `json:"X-Client-Name,omitempty"`

	// XClientVersion Номер версії клінту що інтегрується з API, наприклад 'v1.2.5'
	XClientVersion *string `json:"X-Client-Version,omitempty"`

	// XAccessKey Ключ доступу інтеграції (тільки для авторизованих API інтеграцій)
	XAccessKey *string `json:"X-Access-Key,omitempty"`
}

// CloseShiftBySeniorCashierApiV1ShiftsShiftIdClosePostParams defines parameters for CloseShiftBySeniorCashierApiV1ShiftsShiftIdClosePost.
type CloseShiftBySeniorCashierApiV1ShiftsShiftIdClosePostParams struct {
	// XClientName Наза клієнту або сервісу що інтегрується з API, наприклад 'My Custom SDK'
	XClientName *string `json:"X-Client-Name,omitempty"`

	// XClientVersion Номер версії клінту що інтегрується з API, наприклад 'v1.2.5'
	XClientVersion *string `json:"X-Client-Version,omitempty"`

	// XAccessKey Ключ доступу інтеграції (тільки для авторизованих API інтеграцій)
	XAccessKey  *string `json:"X-Access-Key,omitempty"`
	XLicenseKey string  `json:"X-License-Key"`
}

// GetAllTaxesApiV1TaxGetParams defines parameters for GetAllTaxesApiV1TaxGet.
type GetAllTaxesApiV1TaxGetParams struct {
	// XClientName Наза клієнту або сервісу що інтегрується з API, наприклад 'My Custom SDK'
	XClientName *string `json:"X-Client-Name,omitempty"`

	// XClientVersion Номер версії клінту що інтегрується з API, наприклад 'v1.2.5'
	XClientVersion *string `json:"X-Client-Version,omitempty"`

	// XAccessKey Ключ доступу інтеграції (тільки для авторизованих API інтеграцій)
	XAccessKey  *string `json:"X-Access-Key,omitempty"`
	XLicenseKey string  `json:"X-License-Key"`
}

// GetTransactionsApiV1TransactionsGetParams defines parameters for GetTransactionsApiV1TransactionsGet.
type GetTransactionsApiV1TransactionsGetParams struct {
	Status *[]TransactionStatus `form:"status,omitempty" json:"status,omitempty"`
	Type   *[]TransactionType   `form:"type,omitempty" json:"type,omitempty"`
	Limit  *int                 `form:"limit,omitempty" json:"limit,omitempty"`
	Offset *int                 `form:"offset,omitempty" json:"offset,omitempty"`

	// XClientName Наза клієнту або сервісу що інтегрується з API, наприклад 'My Custom SDK'
	XClientName *string `json:"X-Client-Name,omitempty"`

	// XClientVersion Номер версії клінту що інтегрується з API, наприклад 'v1.2.5'
	XClientVersion *string `json:"X-Client-Version,omitempty"`

	// XAccessKey Ключ доступу інтеграції (тільки для авторизованих API інтеграцій)
	XAccessKey *string `json:"X-Access-Key,omitempty"`
}

// GetTransactionApiV1TransactionsTransactionIdGetParams defines parameters for GetTransactionApiV1TransactionsTransactionIdGet.
type GetTransactionApiV1TransactionsTransactionIdGetParams struct {
	// XClientName Наза клієнту або сервісу що інтегрується з API, наприклад 'My Custom SDK'
	XClientName *string `json:"X-Client-Name,omitempty"`

	// XClientVersion Номер версії клінту що інтегрується з API, наприклад 'v1.2.5'
	XClientVersion *string `json:"X-Client-Version,omitempty"`

	// XAccessKey Ключ доступу інтеграції (тільки для авторизованих API інтеграцій)
	XAccessKey *string `json:"X-Access-Key,omitempty"`
}

// UpdateTransactionApiV1TransactionsTransactionIdPatchParams defines parameters for UpdateTransactionApiV1TransactionsTransactionIdPatch.
type UpdateTransactionApiV1TransactionsTransactionIdPatchParams struct {
	// XClientName Наза клієнту або сервісу що інтегрується з API, наприклад 'My Custom SDK'
	XClientName *string `json:"X-Client-Name,omitempty"`

	// XClientVersion Номер версії клінту що інтегрується з API, наприклад 'v1.2.5'
	XClientVersion *string `json:"X-Client-Version,omitempty"`

	// XAccessKey Ключ доступу інтеграції (тільки для авторизованих API інтеграцій)
	XAccessKey *string `json:"X-Access-Key,omitempty"`
}

// DeleteWebhookApiV1WebhookDeleteParams defines parameters for DeleteWebhookApiV1WebhookDelete.
type DeleteWebhookApiV1WebhookDeleteParams struct {
	// XClientName Наза клієнту або сервісу що інтегрується з API, наприклад 'My Custom SDK'
	XClientName *string `json:"X-Client-Name,omitempty"`

	// XClientVersion Номер версії клінту що інтегрується з API, наприклад 'v1.2.5'
	XClientVersion *string `json:"X-Client-Version,omitempty"`

	// XAccessKey Ключ доступу інтеграції (тільки для авторизованих API інтеграцій)
	XAccessKey  *string `json:"X-Access-Key,omitempty"`
	XLicenseKey string  `json:"X-License-Key"`
}

// GetWebhookInfoApiV1WebhookGetParams defines parameters for GetWebhookInfoApiV1WebhookGet.
type GetWebhookInfoApiV1WebhookGetParams struct {
	// XClientName Наза клієнту або сервісу що інтегрується з API, наприклад 'My Custom SDK'
	XClientName *string `json:"X-Client-Name,omitempty"`

	// XClientVersion Номер версії клінту що інтегрується з API, наприклад 'v1.2.5'
	XClientVersion *string `json:"X-Client-Version,omitempty"`

	// XAccessKey Ключ доступу інтеграції (тільки для авторизованих API інтеграцій)
	XAccessKey  *string `json:"X-Access-Key,omitempty"`
	XLicenseKey string  `json:"X-License-Key"`
}

// SetWebhookApiV1WebhookPostParams defines parameters for SetWebhookApiV1WebhookPost.
type SetWebhookApiV1WebhookPostParams struct {
	// XClientName Наза клієнту або сервісу що інтегрується з API, наприклад 'My Custom SDK'
	XClientName *string `json:"X-Client-Name,omitempty"`

	// XClientVersion Номер версії клінту що інтегрується з API, наприклад 'v1.2.5'
	XClientVersion *string `json:"X-Client-Version,omitempty"`

	// XAccessKey Ключ доступу інтеграції (тільки для авторизованих API інтеграцій)
	XAccessKey  *string `json:"X-Access-Key,omitempty"`
	XLicenseKey string  `json:"X-License-Key"`
}

// GoOfflineActionApiV1CashRegistersGoOfflinePostJSONRequestBody defines body for GoOfflineActionApiV1CashRegistersGoOfflinePost for application/json ContentType.
type GoOfflineActionApiV1CashRegistersGoOfflinePostJSONRequestBody = GoOfflinePayload

// SignInCashierApiV1CashierSigninPostJSONRequestBody defines body for SignInCashierApiV1CashierSigninPost for application/json ContentType.
type SignInCashierApiV1CashierSigninPostJSONRequestBody = CashierSignIn

// SignInCashierViaPinCodeApiV1CashierSigninPinCodePostJSONRequestBody defines body for SignInCashierViaPinCodeApiV1CashierSigninPinCodePost for application/json ContentType.
type SignInCashierViaPinCodeApiV1CashierSigninPinCodePostJSONRequestBody = CashierSignInPinCode

// SetupCurrencyRatesApiV1CurrencyRateSetupPostJSONRequestBody defines body for SetupCurrencyRatesApiV1CurrencyRateSetupPost for application/json ContentType.
type SetupCurrencyRatesApiV1CurrencyRateSetupPostJSONRequestBody = SetupRatesPayload

// GoodsReportApiV1ExtendedReportsGoodsPostJSONRequestBody defines body for GoodsReportApiV1ExtendedReportsGoodsPost for application/json ContentType.
type GoodsReportApiV1ExtendedReportsGoodsPostJSONRequestBody = ExtendedReportFiltersPayload

// ImportGoodsFromFileApiV1GoodsImportUploadPostMultipartRequestBody defines body for ImportGoodsFromFileApiV1GoodsImportUploadPost for multipart/form-data ContentType.
type ImportGoodsFromFileApiV1GoodsImportUploadPostMultipartRequestBody = BodyImportGoodsFromFileApiV1GoodsImportUploadPost

// AddOrdersApiV1OrdersPostJSONRequestBody defines body for AddOrdersApiV1OrdersPost for application/json ContentType.
type AddOrdersApiV1OrdersPostJSONRequestBody AddOrdersApiV1OrdersPostJSONBody

// SetIntegrationApiV1OrdersIntegrationPostJSONRequestBody defines body for SetIntegrationApiV1OrdersIntegrationPost for application/json ContentType.
type SetIntegrationApiV1OrdersIntegrationPostJSONRequestBody = SetIntegrationPayload

// EditOrderApiV1OrdersIntegrationEditOrderPostJSONRequestBody defines body for EditOrderApiV1OrdersIntegrationEditOrderPost for application/json ContentType.
type EditOrderApiV1OrdersIntegrationEditOrderPostJSONRequestBody = IntegrationEditOrderReceiptSchema

// AddExternalReceiptApiV1ReceiptsAddExternalPostJSONRequestBody defines body for AddExternalReceiptApiV1ReceiptsAddExternalPost for application/json ContentType.
type AddExternalReceiptApiV1ReceiptsAddExternalPostJSONRequestBody = CalculatedReceiptSellPayload

// CashWithdrawalApiV1ReceiptsCashWithdrawalPostJSONRequestBody defines body for CashWithdrawalApiV1ReceiptsCashWithdrawalPost for application/json ContentType.
type CashWithdrawalApiV1ReceiptsCashWithdrawalPostJSONRequestBody = CashWithdrawalReceiptPayload

// ExchangeApiV1ReceiptsCurrencyExchangePostJSONRequestBody defines body for ExchangeApiV1ReceiptsCurrencyExchangePost for application/json ContentType.
type ExchangeApiV1ReceiptsCurrencyExchangePostJSONRequestBody = CurrencyExchangePayload

// CreateReceiptApiV1ReceiptsSellPostJSONRequestBody defines body for CreateReceiptApiV1ReceiptsSellPost for application/json ContentType.
type CreateReceiptApiV1ReceiptsSellPostJSONRequestBody = ReceiptSellPayload

// CreateOfflineReceiptApiV1ReceiptsSellOfflinePostJSONRequestBody defines body for CreateOfflineReceiptApiV1ReceiptsSellOfflinePost for application/json ContentType.
type CreateOfflineReceiptApiV1ReceiptsSellOfflinePostJSONRequestBody = OfflineReceiptSellPayload

// CreateServiceReceiptApiV1ReceiptsServicePostJSONRequestBody defines body for CreateServiceReceiptApiV1ReceiptsServicePost for application/json ContentType.
type CreateServiceReceiptApiV1ReceiptsServicePostJSONRequestBody = ReceiptServicePayload

// CreateServiceCurrencyReceiptApiV1ReceiptsServiceCurrencyPostJSONRequestBody defines body for CreateServiceCurrencyReceiptApiV1ReceiptsServiceCurrencyPost for application/json ContentType.
type CreateServiceCurrencyReceiptApiV1ReceiptsServiceCurrencyPostJSONRequestBody = ServiceCurrencyPayload

// SendReceiptToEmailApiV1ReceiptsReceiptIdEmailPostJSONRequestBody defines body for SendReceiptToEmailApiV1ReceiptsReceiptIdEmailPost for application/json ContentType.
type SendReceiptToEmailApiV1ReceiptsReceiptIdEmailPostJSONRequestBody = SendReceiptToEmailApiV1ReceiptsReceiptIdEmailPostJSONBody

// SendReceiptViaSmsApiV1ReceiptsReceiptIdSmsPostJSONRequestBody defines body for SendReceiptViaSmsApiV1ReceiptsReceiptIdSmsPost for application/json ContentType.
type SendReceiptViaSmsApiV1ReceiptsReceiptIdSmsPostJSONRequestBody = ReceiptDeliverySmsPayload

// AddExternalReportApiV1ReportsAddExternalPostJSONRequestBody defines body for AddExternalReportApiV1ReportsAddExternalPost for application/json ContentType.
type AddExternalReportApiV1ReportsAddExternalPostJSONRequestBody = ReportPayload

// CreateShiftApiV1ShiftsPostJSONRequestBody defines body for CreateShiftApiV1ShiftsPost for application/json ContentType.
type CreateShiftApiV1ShiftsPostJSONRequestBody = CreateShiftPayload

// CloseShiftApiV1ShiftsClosePostJSONRequestBody defines body for CloseShiftApiV1ShiftsClosePost for application/json ContentType.
type CloseShiftApiV1ShiftsClosePostJSONRequestBody = CloseShiftPayload

// CloseShiftBySeniorCashierApiV1ShiftsShiftIdClosePostJSONRequestBody defines body for CloseShiftBySeniorCashierApiV1ShiftsShiftIdClosePost for application/json ContentType.
type CloseShiftBySeniorCashierApiV1ShiftsShiftIdClosePostJSONRequestBody = ShortCloseShiftPayload

// UpdateTransactionApiV1TransactionsTransactionIdPatchJSONRequestBody defines body for UpdateTransactionApiV1TransactionsTransactionIdPatch for application/json ContentType.
type UpdateTransactionApiV1TransactionsTransactionIdPatchJSONRequestBody = UpdateTransactionPayload

// SetWebhookApiV1WebhookPostJSONRequestBody defines body for SetWebhookApiV1WebhookPost for application/json ContentType.
type SetWebhookApiV1WebhookPostJSONRequestBody = SetWebhookPayload

// AsCalculatedDiscountPayloadTaxCode0 returns the union data inside the CalculatedDiscountPayload_TaxCode as a CalculatedDiscountPayloadTaxCode0
func (t CalculatedDiscountPayload_TaxCode) AsCalculatedDiscountPayloadTaxCode0() (CalculatedDiscountPayloadTaxCode0, error) {
	var body CalculatedDiscountPayloadTaxCode0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromCalculatedDiscountPayloadTaxCode0 overwrites any union data inside the CalculatedDiscountPayload_TaxCode as the provided CalculatedDiscountPayloadTaxCode0
func (t *CalculatedDiscountPayload_TaxCode) FromCalculatedDiscountPayloadTaxCode0(v CalculatedDiscountPayloadTaxCode0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeCalculatedDiscountPayloadTaxCode0 performs a merge with any union data inside the CalculatedDiscountPayload_TaxCode, using the provided CalculatedDiscountPayloadTaxCode0
func (t *CalculatedDiscountPayload_TaxCode) MergeCalculatedDiscountPayloadTaxCode0(v CalculatedDiscountPayloadTaxCode0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(b, t.union)
	t.union = merged
	return err
}

// AsCalculatedDiscountPayloadTaxCode1 returns the union data inside the CalculatedDiscountPayload_TaxCode as a CalculatedDiscountPayloadTaxCode1
func (t CalculatedDiscountPayload_TaxCode) AsCalculatedDiscountPayloadTaxCode1() (CalculatedDiscountPayloadTaxCode1, error) {
	var body CalculatedDiscountPayloadTaxCode1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromCalculatedDiscountPayloadTaxCode1 overwrites any union data inside the CalculatedDiscountPayload_TaxCode as the provided CalculatedDiscountPayloadTaxCode1
func (t *CalculatedDiscountPayload_TaxCode) FromCalculatedDiscountPayloadTaxCode1(v CalculatedDiscountPayloadTaxCode1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeCalculatedDiscountPayloadTaxCode1 performs a merge with any union data inside the CalculatedDiscountPayload_TaxCode, using the provided CalculatedDiscountPayloadTaxCode1
func (t *CalculatedDiscountPayload_TaxCode) MergeCalculatedDiscountPayloadTaxCode1(v CalculatedDiscountPayloadTaxCode1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(b, t.union)
	t.union = merged
	return err
}

func (t CalculatedDiscountPayload_TaxCode) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *CalculatedDiscountPayload_TaxCode) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsCalculatedDiscountPayloadTaxCodes0 returns the union data inside the CalculatedDiscountPayload_TaxCodes as a CalculatedDiscountPayloadTaxCodes0
func (t CalculatedDiscountPayload_TaxCodes) AsCalculatedDiscountPayloadTaxCodes0() (CalculatedDiscountPayloadTaxCodes0, error) {
	var body CalculatedDiscountPayloadTaxCodes0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromCalculatedDiscountPayloadTaxCodes0 overwrites any union data inside the CalculatedDiscountPayload_TaxCodes as the provided CalculatedDiscountPayloadTaxCodes0
func (t *CalculatedDiscountPayload_TaxCodes) FromCalculatedDiscountPayloadTaxCodes0(v CalculatedDiscountPayloadTaxCodes0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeCalculatedDiscountPayloadTaxCodes0 performs a merge with any union data inside the CalculatedDiscountPayload_TaxCodes, using the provided CalculatedDiscountPayloadTaxCodes0
func (t *CalculatedDiscountPayload_TaxCodes) MergeCalculatedDiscountPayloadTaxCodes0(v CalculatedDiscountPayloadTaxCodes0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(b, t.union)
	t.union = merged
	return err
}

// AsCalculatedDiscountPayloadTaxCodes1 returns the union data inside the CalculatedDiscountPayload_TaxCodes as a CalculatedDiscountPayloadTaxCodes1
func (t CalculatedDiscountPayload_TaxCodes) AsCalculatedDiscountPayloadTaxCodes1() (CalculatedDiscountPayloadTaxCodes1, error) {
	var body CalculatedDiscountPayloadTaxCodes1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromCalculatedDiscountPayloadTaxCodes1 overwrites any union data inside the CalculatedDiscountPayload_TaxCodes as the provided CalculatedDiscountPayloadTaxCodes1
func (t *CalculatedDiscountPayload_TaxCodes) FromCalculatedDiscountPayloadTaxCodes1(v CalculatedDiscountPayloadTaxCodes1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeCalculatedDiscountPayloadTaxCodes1 performs a merge with any union data inside the CalculatedDiscountPayload_TaxCodes, using the provided CalculatedDiscountPayloadTaxCodes1
func (t *CalculatedDiscountPayload_TaxCodes) MergeCalculatedDiscountPayloadTaxCodes1(v CalculatedDiscountPayloadTaxCodes1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(b, t.union)
	t.union = merged
	return err
}

func (t CalculatedDiscountPayload_TaxCodes) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *CalculatedDiscountPayload_TaxCodes) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsCalculatedReceiptSellPayloadContext0 returns the union data inside the CalculatedReceiptSellPayload_Context_AdditionalProperties as a CalculatedReceiptSellPayloadContext0
func (t CalculatedReceiptSellPayload_Context_AdditionalProperties) AsCalculatedReceiptSellPayloadContext0() (CalculatedReceiptSellPayloadContext0, error) {
	var body CalculatedReceiptSellPayloadContext0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromCalculatedReceiptSellPayloadContext0 overwrites any union data inside the CalculatedReceiptSellPayload_Context_AdditionalProperties as the provided CalculatedReceiptSellPayloadContext0
func (t *CalculatedReceiptSellPayload_Context_AdditionalProperties) FromCalculatedReceiptSellPayloadContext0(v CalculatedReceiptSellPayloadContext0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeCalculatedReceiptSellPayloadContext0 performs a merge with any union data inside the CalculatedReceiptSellPayload_Context_AdditionalProperties, using the provided CalculatedReceiptSellPayloadContext0
func (t *CalculatedReceiptSellPayload_Context_AdditionalProperties) MergeCalculatedReceiptSellPayloadContext0(v CalculatedReceiptSellPayloadContext0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(b, t.union)
	t.union = merged
	return err
}

// AsCalculatedReceiptSellPayloadContext1 returns the union data inside the CalculatedReceiptSellPayload_Context_AdditionalProperties as a CalculatedReceiptSellPayloadContext1
func (t CalculatedReceiptSellPayload_Context_AdditionalProperties) AsCalculatedReceiptSellPayloadContext1() (CalculatedReceiptSellPayloadContext1, error) {
	var body CalculatedReceiptSellPayloadContext1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromCalculatedReceiptSellPayloadContext1 overwrites any union data inside the CalculatedReceiptSellPayload_Context_AdditionalProperties as the provided CalculatedReceiptSellPayloadContext1
func (t *CalculatedReceiptSellPayload_Context_AdditionalProperties) FromCalculatedReceiptSellPayloadContext1(v CalculatedReceiptSellPayloadContext1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeCalculatedReceiptSellPayloadContext1 performs a merge with any union data inside the CalculatedReceiptSellPayload_Context_AdditionalProperties, using the provided CalculatedReceiptSellPayloadContext1
func (t *CalculatedReceiptSellPayload_Context_AdditionalProperties) MergeCalculatedReceiptSellPayloadContext1(v CalculatedReceiptSellPayloadContext1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(b, t.union)
	t.union = merged
	return err
}

// AsCalculatedReceiptSellPayloadContext2 returns the union data inside the CalculatedReceiptSellPayload_Context_AdditionalProperties as a CalculatedReceiptSellPayloadContext2
func (t CalculatedReceiptSellPayload_Context_AdditionalProperties) AsCalculatedReceiptSellPayloadContext2() (CalculatedReceiptSellPayloadContext2, error) {
	var body CalculatedReceiptSellPayloadContext2
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromCalculatedReceiptSellPayloadContext2 overwrites any union data inside the CalculatedReceiptSellPayload_Context_AdditionalProperties as the provided CalculatedReceiptSellPayloadContext2
func (t *CalculatedReceiptSellPayload_Context_AdditionalProperties) FromCalculatedReceiptSellPayloadContext2(v CalculatedReceiptSellPayloadContext2) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeCalculatedReceiptSellPayloadContext2 performs a merge with any union data inside the CalculatedReceiptSellPayload_Context_AdditionalProperties, using the provided CalculatedReceiptSellPayloadContext2
func (t *CalculatedReceiptSellPayload_Context_AdditionalProperties) MergeCalculatedReceiptSellPayloadContext2(v CalculatedReceiptSellPayloadContext2) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(b, t.union)
	t.union = merged
	return err
}

// AsCalculatedReceiptSellPayloadContext3 returns the union data inside the CalculatedReceiptSellPayload_Context_AdditionalProperties as a CalculatedReceiptSellPayloadContext3
func (t CalculatedReceiptSellPayload_Context_AdditionalProperties) AsCalculatedReceiptSellPayloadContext3() (CalculatedReceiptSellPayloadContext3, error) {
	var body CalculatedReceiptSellPayloadContext3
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromCalculatedReceiptSellPayloadContext3 overwrites any union data inside the CalculatedReceiptSellPayload_Context_AdditionalProperties as the provided CalculatedReceiptSellPayloadContext3
func (t *CalculatedReceiptSellPayload_Context_AdditionalProperties) FromCalculatedReceiptSellPayloadContext3(v CalculatedReceiptSellPayloadContext3) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeCalculatedReceiptSellPayloadContext3 performs a merge with any union data inside the CalculatedReceiptSellPayload_Context_AdditionalProperties, using the provided CalculatedReceiptSellPayloadContext3
func (t *CalculatedReceiptSellPayload_Context_AdditionalProperties) MergeCalculatedReceiptSellPayloadContext3(v CalculatedReceiptSellPayloadContext3) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(b, t.union)
	t.union = merged
	return err
}

func (t CalculatedReceiptSellPayload_Context_AdditionalProperties) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *CalculatedReceiptSellPayload_Context_AdditionalProperties) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsCashPaymentPayload returns the union data inside the CalculatedReceiptSellPayload_Payments_Item as a CashPaymentPayload
func (t CalculatedReceiptSellPayload_Payments_Item) AsCashPaymentPayload() (CashPaymentPayload, error) {
	var body CashPaymentPayload
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromCashPaymentPayload overwrites any union data inside the CalculatedReceiptSellPayload_Payments_Item as the provided CashPaymentPayload
func (t *CalculatedReceiptSellPayload_Payments_Item) FromCashPaymentPayload(v CashPaymentPayload) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeCashPaymentPayload performs a merge with any union data inside the CalculatedReceiptSellPayload_Payments_Item, using the provided CashPaymentPayload
func (t *CalculatedReceiptSellPayload_Payments_Item) MergeCashPaymentPayload(v CashPaymentPayload) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(b, t.union)
	t.union = merged
	return err
}

// AsCardPaymentPayload returns the union data inside the CalculatedReceiptSellPayload_Payments_Item as a CardPaymentPayload
func (t CalculatedReceiptSellPayload_Payments_Item) AsCardPaymentPayload() (CardPaymentPayload, error) {
	var body CardPaymentPayload
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromCardPaymentPayload overwrites any union data inside the CalculatedReceiptSellPayload_Payments_Item as the provided CardPaymentPayload
func (t *CalculatedReceiptSellPayload_Payments_Item) FromCardPaymentPayload(v CardPaymentPayload) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeCardPaymentPayload performs a merge with any union data inside the CalculatedReceiptSellPayload_Payments_Item, using the provided CardPaymentPayload
func (t *CalculatedReceiptSellPayload_Payments_Item) MergeCardPaymentPayload(v CardPaymentPayload) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(b, t.union)
	t.union = merged
	return err
}

// AsObsoleteCardPaymentPayload returns the union data inside the CalculatedReceiptSellPayload_Payments_Item as a ObsoleteCardPaymentPayload
func (t CalculatedReceiptSellPayload_Payments_Item) AsObsoleteCardPaymentPayload() (ObsoleteCardPaymentPayload, error) {
	var body ObsoleteCardPaymentPayload
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromObsoleteCardPaymentPayload overwrites any union data inside the CalculatedReceiptSellPayload_Payments_Item as the provided ObsoleteCardPaymentPayload
func (t *CalculatedReceiptSellPayload_Payments_Item) FromObsoleteCardPaymentPayload(v ObsoleteCardPaymentPayload) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeObsoleteCardPaymentPayload performs a merge with any union data inside the CalculatedReceiptSellPayload_Payments_Item, using the provided ObsoleteCardPaymentPayload
func (t *CalculatedReceiptSellPayload_Payments_Item) MergeObsoleteCardPaymentPayload(v ObsoleteCardPaymentPayload) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(b, t.union)
	t.union = merged
	return err
}

func (t CalculatedReceiptSellPayload_Payments_Item) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *CalculatedReceiptSellPayload_Payments_Item) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsCashWithdrawalReceiptPayloadContext0 returns the union data inside the CashWithdrawalReceiptPayload_Context_AdditionalProperties as a CashWithdrawalReceiptPayloadContext0
func (t CashWithdrawalReceiptPayload_Context_AdditionalProperties) AsCashWithdrawalReceiptPayloadContext0() (CashWithdrawalReceiptPayloadContext0, error) {
	var body CashWithdrawalReceiptPayloadContext0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromCashWithdrawalReceiptPayloadContext0 overwrites any union data inside the CashWithdrawalReceiptPayload_Context_AdditionalProperties as the provided CashWithdrawalReceiptPayloadContext0
func (t *CashWithdrawalReceiptPayload_Context_AdditionalProperties) FromCashWithdrawalReceiptPayloadContext0(v CashWithdrawalReceiptPayloadContext0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeCashWithdrawalReceiptPayloadContext0 performs a merge with any union data inside the CashWithdrawalReceiptPayload_Context_AdditionalProperties, using the provided CashWithdrawalReceiptPayloadContext0
func (t *CashWithdrawalReceiptPayload_Context_AdditionalProperties) MergeCashWithdrawalReceiptPayloadContext0(v CashWithdrawalReceiptPayloadContext0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(b, t.union)
	t.union = merged
	return err
}

// AsCashWithdrawalReceiptPayloadContext1 returns the union data inside the CashWithdrawalReceiptPayload_Context_AdditionalProperties as a CashWithdrawalReceiptPayloadContext1
func (t CashWithdrawalReceiptPayload_Context_AdditionalProperties) AsCashWithdrawalReceiptPayloadContext1() (CashWithdrawalReceiptPayloadContext1, error) {
	var body CashWithdrawalReceiptPayloadContext1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromCashWithdrawalReceiptPayloadContext1 overwrites any union data inside the CashWithdrawalReceiptPayload_Context_AdditionalProperties as the provided CashWithdrawalReceiptPayloadContext1
func (t *CashWithdrawalReceiptPayload_Context_AdditionalProperties) FromCashWithdrawalReceiptPayloadContext1(v CashWithdrawalReceiptPayloadContext1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeCashWithdrawalReceiptPayloadContext1 performs a merge with any union data inside the CashWithdrawalReceiptPayload_Context_AdditionalProperties, using the provided CashWithdrawalReceiptPayloadContext1
func (t *CashWithdrawalReceiptPayload_Context_AdditionalProperties) MergeCashWithdrawalReceiptPayloadContext1(v CashWithdrawalReceiptPayloadContext1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(b, t.union)
	t.union = merged
	return err
}

// AsCashWithdrawalReceiptPayloadContext2 returns the union data inside the CashWithdrawalReceiptPayload_Context_AdditionalProperties as a CashWithdrawalReceiptPayloadContext2
func (t CashWithdrawalReceiptPayload_Context_AdditionalProperties) AsCashWithdrawalReceiptPayloadContext2() (CashWithdrawalReceiptPayloadContext2, error) {
	var body CashWithdrawalReceiptPayloadContext2
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromCashWithdrawalReceiptPayloadContext2 overwrites any union data inside the CashWithdrawalReceiptPayload_Context_AdditionalProperties as the provided CashWithdrawalReceiptPayloadContext2
func (t *CashWithdrawalReceiptPayload_Context_AdditionalProperties) FromCashWithdrawalReceiptPayloadContext2(v CashWithdrawalReceiptPayloadContext2) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeCashWithdrawalReceiptPayloadContext2 performs a merge with any union data inside the CashWithdrawalReceiptPayload_Context_AdditionalProperties, using the provided CashWithdrawalReceiptPayloadContext2
func (t *CashWithdrawalReceiptPayload_Context_AdditionalProperties) MergeCashWithdrawalReceiptPayloadContext2(v CashWithdrawalReceiptPayloadContext2) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(b, t.union)
	t.union = merged
	return err
}

// AsCashWithdrawalReceiptPayloadContext3 returns the union data inside the CashWithdrawalReceiptPayload_Context_AdditionalProperties as a CashWithdrawalReceiptPayloadContext3
func (t CashWithdrawalReceiptPayload_Context_AdditionalProperties) AsCashWithdrawalReceiptPayloadContext3() (CashWithdrawalReceiptPayloadContext3, error) {
	var body CashWithdrawalReceiptPayloadContext3
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromCashWithdrawalReceiptPayloadContext3 overwrites any union data inside the CashWithdrawalReceiptPayload_Context_AdditionalProperties as the provided CashWithdrawalReceiptPayloadContext3
func (t *CashWithdrawalReceiptPayload_Context_AdditionalProperties) FromCashWithdrawalReceiptPayloadContext3(v CashWithdrawalReceiptPayloadContext3) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeCashWithdrawalReceiptPayloadContext3 performs a merge with any union data inside the CashWithdrawalReceiptPayload_Context_AdditionalProperties, using the provided CashWithdrawalReceiptPayloadContext3
func (t *CashWithdrawalReceiptPayload_Context_AdditionalProperties) MergeCashWithdrawalReceiptPayloadContext3(v CashWithdrawalReceiptPayloadContext3) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(b, t.union)
	t.union = merged
	return err
}

func (t CashWithdrawalReceiptPayload_Context_AdditionalProperties) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *CashWithdrawalReceiptPayload_Context_AdditionalProperties) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsDiscountModelTaxCode0 returns the union data inside the DiscountModel_TaxCode as a DiscountModelTaxCode0
func (t DiscountModel_TaxCode) AsDiscountModelTaxCode0() (DiscountModelTaxCode0, error) {
	var body DiscountModelTaxCode0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromDiscountModelTaxCode0 overwrites any union data inside the DiscountModel_TaxCode as the provided DiscountModelTaxCode0
func (t *DiscountModel_TaxCode) FromDiscountModelTaxCode0(v DiscountModelTaxCode0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeDiscountModelTaxCode0 performs a merge with any union data inside the DiscountModel_TaxCode, using the provided DiscountModelTaxCode0
func (t *DiscountModel_TaxCode) MergeDiscountModelTaxCode0(v DiscountModelTaxCode0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(b, t.union)
	t.union = merged
	return err
}

// AsDiscountModelTaxCode1 returns the union data inside the DiscountModel_TaxCode as a DiscountModelTaxCode1
func (t DiscountModel_TaxCode) AsDiscountModelTaxCode1() (DiscountModelTaxCode1, error) {
	var body DiscountModelTaxCode1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromDiscountModelTaxCode1 overwrites any union data inside the DiscountModel_TaxCode as the provided DiscountModelTaxCode1
func (t *DiscountModel_TaxCode) FromDiscountModelTaxCode1(v DiscountModelTaxCode1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeDiscountModelTaxCode1 performs a merge with any union data inside the DiscountModel_TaxCode, using the provided DiscountModelTaxCode1
func (t *DiscountModel_TaxCode) MergeDiscountModelTaxCode1(v DiscountModelTaxCode1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(b, t.union)
	t.union = merged
	return err
}

func (t DiscountModel_TaxCode) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *DiscountModel_TaxCode) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsDiscountModelTaxCodes0 returns the union data inside the DiscountModel_TaxCodes as a DiscountModelTaxCodes0
func (t DiscountModel_TaxCodes) AsDiscountModelTaxCodes0() (DiscountModelTaxCodes0, error) {
	var body DiscountModelTaxCodes0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromDiscountModelTaxCodes0 overwrites any union data inside the DiscountModel_TaxCodes as the provided DiscountModelTaxCodes0
func (t *DiscountModel_TaxCodes) FromDiscountModelTaxCodes0(v DiscountModelTaxCodes0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeDiscountModelTaxCodes0 performs a merge with any union data inside the DiscountModel_TaxCodes, using the provided DiscountModelTaxCodes0
func (t *DiscountModel_TaxCodes) MergeDiscountModelTaxCodes0(v DiscountModelTaxCodes0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(b, t.union)
	t.union = merged
	return err
}

// AsDiscountModelTaxCodes1 returns the union data inside the DiscountModel_TaxCodes as a DiscountModelTaxCodes1
func (t DiscountModel_TaxCodes) AsDiscountModelTaxCodes1() (DiscountModelTaxCodes1, error) {
	var body DiscountModelTaxCodes1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromDiscountModelTaxCodes1 overwrites any union data inside the DiscountModel_TaxCodes as the provided DiscountModelTaxCodes1
func (t *DiscountModel_TaxCodes) FromDiscountModelTaxCodes1(v DiscountModelTaxCodes1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeDiscountModelTaxCodes1 performs a merge with any union data inside the DiscountModel_TaxCodes, using the provided DiscountModelTaxCodes1
func (t *DiscountModel_TaxCodes) MergeDiscountModelTaxCodes1(v DiscountModelTaxCodes1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(b, t.union)
	t.union = merged
	return err
}

func (t DiscountModel_TaxCodes) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *DiscountModel_TaxCodes) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsDiscountPayloadTaxCode0 returns the union data inside the DiscountPayload_TaxCode as a DiscountPayloadTaxCode0
func (t DiscountPayload_TaxCode) AsDiscountPayloadTaxCode0() (DiscountPayloadTaxCode0, error) {
	var body DiscountPayloadTaxCode0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromDiscountPayloadTaxCode0 overwrites any union data inside the DiscountPayload_TaxCode as the provided DiscountPayloadTaxCode0
func (t *DiscountPayload_TaxCode) FromDiscountPayloadTaxCode0(v DiscountPayloadTaxCode0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeDiscountPayloadTaxCode0 performs a merge with any union data inside the DiscountPayload_TaxCode, using the provided DiscountPayloadTaxCode0
func (t *DiscountPayload_TaxCode) MergeDiscountPayloadTaxCode0(v DiscountPayloadTaxCode0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(b, t.union)
	t.union = merged
	return err
}

// AsDiscountPayloadTaxCode1 returns the union data inside the DiscountPayload_TaxCode as a DiscountPayloadTaxCode1
func (t DiscountPayload_TaxCode) AsDiscountPayloadTaxCode1() (DiscountPayloadTaxCode1, error) {
	var body DiscountPayloadTaxCode1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromDiscountPayloadTaxCode1 overwrites any union data inside the DiscountPayload_TaxCode as the provided DiscountPayloadTaxCode1
func (t *DiscountPayload_TaxCode) FromDiscountPayloadTaxCode1(v DiscountPayloadTaxCode1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeDiscountPayloadTaxCode1 performs a merge with any union data inside the DiscountPayload_TaxCode, using the provided DiscountPayloadTaxCode1
func (t *DiscountPayload_TaxCode) MergeDiscountPayloadTaxCode1(v DiscountPayloadTaxCode1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(b, t.union)
	t.union = merged
	return err
}

func (t DiscountPayload_TaxCode) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *DiscountPayload_TaxCode) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsDiscountPayloadTaxCodes0 returns the union data inside the DiscountPayload_TaxCodes as a DiscountPayloadTaxCodes0
func (t DiscountPayload_TaxCodes) AsDiscountPayloadTaxCodes0() (DiscountPayloadTaxCodes0, error) {
	var body DiscountPayloadTaxCodes0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromDiscountPayloadTaxCodes0 overwrites any union data inside the DiscountPayload_TaxCodes as the provided DiscountPayloadTaxCodes0
func (t *DiscountPayload_TaxCodes) FromDiscountPayloadTaxCodes0(v DiscountPayloadTaxCodes0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeDiscountPayloadTaxCodes0 performs a merge with any union data inside the DiscountPayload_TaxCodes, using the provided DiscountPayloadTaxCodes0
func (t *DiscountPayload_TaxCodes) MergeDiscountPayloadTaxCodes0(v DiscountPayloadTaxCodes0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(b, t.union)
	t.union = merged
	return err
}

// AsDiscountPayloadTaxCodes1 returns the union data inside the DiscountPayload_TaxCodes as a DiscountPayloadTaxCodes1
func (t DiscountPayload_TaxCodes) AsDiscountPayloadTaxCodes1() (DiscountPayloadTaxCodes1, error) {
	var body DiscountPayloadTaxCodes1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromDiscountPayloadTaxCodes1 overwrites any union data inside the DiscountPayload_TaxCodes as the provided DiscountPayloadTaxCodes1
func (t *DiscountPayload_TaxCodes) FromDiscountPayloadTaxCodes1(v DiscountPayloadTaxCodes1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeDiscountPayloadTaxCodes1 performs a merge with any union data inside the DiscountPayload_TaxCodes, using the provided DiscountPayloadTaxCodes1
func (t *DiscountPayload_TaxCodes) MergeDiscountPayloadTaxCodes1(v DiscountPayloadTaxCodes1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(b, t.union)
	t.union = merged
	return err
}

func (t DiscountPayload_TaxCodes) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *DiscountPayload_TaxCodes) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsGoodDetailsPayloadTax0 returns the union data inside the GoodDetailsPayload_Tax as a GoodDetailsPayloadTax0
func (t GoodDetailsPayload_Tax) AsGoodDetailsPayloadTax0() (GoodDetailsPayloadTax0, error) {
	var body GoodDetailsPayloadTax0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromGoodDetailsPayloadTax0 overwrites any union data inside the GoodDetailsPayload_Tax as the provided GoodDetailsPayloadTax0
func (t *GoodDetailsPayload_Tax) FromGoodDetailsPayloadTax0(v GoodDetailsPayloadTax0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeGoodDetailsPayloadTax0 performs a merge with any union data inside the GoodDetailsPayload_Tax, using the provided GoodDetailsPayloadTax0
func (t *GoodDetailsPayload_Tax) MergeGoodDetailsPayloadTax0(v GoodDetailsPayloadTax0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(b, t.union)
	t.union = merged
	return err
}

// AsGoodDetailsPayloadTax1 returns the union data inside the GoodDetailsPayload_Tax as a GoodDetailsPayloadTax1
func (t GoodDetailsPayload_Tax) AsGoodDetailsPayloadTax1() (GoodDetailsPayloadTax1, error) {
	var body GoodDetailsPayloadTax1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromGoodDetailsPayloadTax1 overwrites any union data inside the GoodDetailsPayload_Tax as the provided GoodDetailsPayloadTax1
func (t *GoodDetailsPayload_Tax) FromGoodDetailsPayloadTax1(v GoodDetailsPayloadTax1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeGoodDetailsPayloadTax1 performs a merge with any union data inside the GoodDetailsPayload_Tax, using the provided GoodDetailsPayloadTax1
func (t *GoodDetailsPayload_Tax) MergeGoodDetailsPayloadTax1(v GoodDetailsPayloadTax1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(b, t.union)
	t.union = merged
	return err
}

func (t GoodDetailsPayload_Tax) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *GoodDetailsPayload_Tax) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsCashPaymentPayload returns the union data inside the IntegrationEditOrderReceiptSchema_Payments_Item as a CashPaymentPayload
func (t IntegrationEditOrderReceiptSchema_Payments_Item) AsCashPaymentPayload() (CashPaymentPayload, error) {
	var body CashPaymentPayload
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromCashPaymentPayload overwrites any union data inside the IntegrationEditOrderReceiptSchema_Payments_Item as the provided CashPaymentPayload
func (t *IntegrationEditOrderReceiptSchema_Payments_Item) FromCashPaymentPayload(v CashPaymentPayload) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeCashPaymentPayload performs a merge with any union data inside the IntegrationEditOrderReceiptSchema_Payments_Item, using the provided CashPaymentPayload
func (t *IntegrationEditOrderReceiptSchema_Payments_Item) MergeCashPaymentPayload(v CashPaymentPayload) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(b, t.union)
	t.union = merged
	return err
}

// AsCardPaymentPayload returns the union data inside the IntegrationEditOrderReceiptSchema_Payments_Item as a CardPaymentPayload
func (t IntegrationEditOrderReceiptSchema_Payments_Item) AsCardPaymentPayload() (CardPaymentPayload, error) {
	var body CardPaymentPayload
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromCardPaymentPayload overwrites any union data inside the IntegrationEditOrderReceiptSchema_Payments_Item as the provided CardPaymentPayload
func (t *IntegrationEditOrderReceiptSchema_Payments_Item) FromCardPaymentPayload(v CardPaymentPayload) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeCardPaymentPayload performs a merge with any union data inside the IntegrationEditOrderReceiptSchema_Payments_Item, using the provided CardPaymentPayload
func (t *IntegrationEditOrderReceiptSchema_Payments_Item) MergeCardPaymentPayload(v CardPaymentPayload) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(b, t.union)
	t.union = merged
	return err
}

// AsObsoleteCardPaymentPayload returns the union data inside the IntegrationEditOrderReceiptSchema_Payments_Item as a ObsoleteCardPaymentPayload
func (t IntegrationEditOrderReceiptSchema_Payments_Item) AsObsoleteCardPaymentPayload() (ObsoleteCardPaymentPayload, error) {
	var body ObsoleteCardPaymentPayload
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromObsoleteCardPaymentPayload overwrites any union data inside the IntegrationEditOrderReceiptSchema_Payments_Item as the provided ObsoleteCardPaymentPayload
func (t *IntegrationEditOrderReceiptSchema_Payments_Item) FromObsoleteCardPaymentPayload(v ObsoleteCardPaymentPayload) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeObsoleteCardPaymentPayload performs a merge with any union data inside the IntegrationEditOrderReceiptSchema_Payments_Item, using the provided ObsoleteCardPaymentPayload
func (t *IntegrationEditOrderReceiptSchema_Payments_Item) MergeObsoleteCardPaymentPayload(v ObsoleteCardPaymentPayload) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(b, t.union)
	t.union = merged
	return err
}

func (t IntegrationEditOrderReceiptSchema_Payments_Item) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *IntegrationEditOrderReceiptSchema_Payments_Item) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsOfflineReceiptSellPayloadContext0 returns the union data inside the OfflineReceiptSellPayload_Context_AdditionalProperties as a OfflineReceiptSellPayloadContext0
func (t OfflineReceiptSellPayload_Context_AdditionalProperties) AsOfflineReceiptSellPayloadContext0() (OfflineReceiptSellPayloadContext0, error) {
	var body OfflineReceiptSellPayloadContext0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromOfflineReceiptSellPayloadContext0 overwrites any union data inside the OfflineReceiptSellPayload_Context_AdditionalProperties as the provided OfflineReceiptSellPayloadContext0
func (t *OfflineReceiptSellPayload_Context_AdditionalProperties) FromOfflineReceiptSellPayloadContext0(v OfflineReceiptSellPayloadContext0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeOfflineReceiptSellPayloadContext0 performs a merge with any union data inside the OfflineReceiptSellPayload_Context_AdditionalProperties, using the provided OfflineReceiptSellPayloadContext0
func (t *OfflineReceiptSellPayload_Context_AdditionalProperties) MergeOfflineReceiptSellPayloadContext0(v OfflineReceiptSellPayloadContext0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(b, t.union)
	t.union = merged
	return err
}

// AsOfflineReceiptSellPayloadContext1 returns the union data inside the OfflineReceiptSellPayload_Context_AdditionalProperties as a OfflineReceiptSellPayloadContext1
func (t OfflineReceiptSellPayload_Context_AdditionalProperties) AsOfflineReceiptSellPayloadContext1() (OfflineReceiptSellPayloadContext1, error) {
	var body OfflineReceiptSellPayloadContext1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromOfflineReceiptSellPayloadContext1 overwrites any union data inside the OfflineReceiptSellPayload_Context_AdditionalProperties as the provided OfflineReceiptSellPayloadContext1
func (t *OfflineReceiptSellPayload_Context_AdditionalProperties) FromOfflineReceiptSellPayloadContext1(v OfflineReceiptSellPayloadContext1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeOfflineReceiptSellPayloadContext1 performs a merge with any union data inside the OfflineReceiptSellPayload_Context_AdditionalProperties, using the provided OfflineReceiptSellPayloadContext1
func (t *OfflineReceiptSellPayload_Context_AdditionalProperties) MergeOfflineReceiptSellPayloadContext1(v OfflineReceiptSellPayloadContext1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(b, t.union)
	t.union = merged
	return err
}

// AsOfflineReceiptSellPayloadContext2 returns the union data inside the OfflineReceiptSellPayload_Context_AdditionalProperties as a OfflineReceiptSellPayloadContext2
func (t OfflineReceiptSellPayload_Context_AdditionalProperties) AsOfflineReceiptSellPayloadContext2() (OfflineReceiptSellPayloadContext2, error) {
	var body OfflineReceiptSellPayloadContext2
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromOfflineReceiptSellPayloadContext2 overwrites any union data inside the OfflineReceiptSellPayload_Context_AdditionalProperties as the provided OfflineReceiptSellPayloadContext2
func (t *OfflineReceiptSellPayload_Context_AdditionalProperties) FromOfflineReceiptSellPayloadContext2(v OfflineReceiptSellPayloadContext2) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeOfflineReceiptSellPayloadContext2 performs a merge with any union data inside the OfflineReceiptSellPayload_Context_AdditionalProperties, using the provided OfflineReceiptSellPayloadContext2
func (t *OfflineReceiptSellPayload_Context_AdditionalProperties) MergeOfflineReceiptSellPayloadContext2(v OfflineReceiptSellPayloadContext2) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(b, t.union)
	t.union = merged
	return err
}

// AsOfflineReceiptSellPayloadContext3 returns the union data inside the OfflineReceiptSellPayload_Context_AdditionalProperties as a OfflineReceiptSellPayloadContext3
func (t OfflineReceiptSellPayload_Context_AdditionalProperties) AsOfflineReceiptSellPayloadContext3() (OfflineReceiptSellPayloadContext3, error) {
	var body OfflineReceiptSellPayloadContext3
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromOfflineReceiptSellPayloadContext3 overwrites any union data inside the OfflineReceiptSellPayload_Context_AdditionalProperties as the provided OfflineReceiptSellPayloadContext3
func (t *OfflineReceiptSellPayload_Context_AdditionalProperties) FromOfflineReceiptSellPayloadContext3(v OfflineReceiptSellPayloadContext3) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeOfflineReceiptSellPayloadContext3 performs a merge with any union data inside the OfflineReceiptSellPayload_Context_AdditionalProperties, using the provided OfflineReceiptSellPayloadContext3
func (t *OfflineReceiptSellPayload_Context_AdditionalProperties) MergeOfflineReceiptSellPayloadContext3(v OfflineReceiptSellPayloadContext3) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(b, t.union)
	t.union = merged
	return err
}

func (t OfflineReceiptSellPayload_Context_AdditionalProperties) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *OfflineReceiptSellPayload_Context_AdditionalProperties) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsCashPaymentPayload returns the union data inside the OfflineReceiptSellPayload_Payments_Item as a CashPaymentPayload
func (t OfflineReceiptSellPayload_Payments_Item) AsCashPaymentPayload() (CashPaymentPayload, error) {
	var body CashPaymentPayload
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromCashPaymentPayload overwrites any union data inside the OfflineReceiptSellPayload_Payments_Item as the provided CashPaymentPayload
func (t *OfflineReceiptSellPayload_Payments_Item) FromCashPaymentPayload(v CashPaymentPayload) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeCashPaymentPayload performs a merge with any union data inside the OfflineReceiptSellPayload_Payments_Item, using the provided CashPaymentPayload
func (t *OfflineReceiptSellPayload_Payments_Item) MergeCashPaymentPayload(v CashPaymentPayload) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(b, t.union)
	t.union = merged
	return err
}

// AsCardPaymentPayload returns the union data inside the OfflineReceiptSellPayload_Payments_Item as a CardPaymentPayload
func (t OfflineReceiptSellPayload_Payments_Item) AsCardPaymentPayload() (CardPaymentPayload, error) {
	var body CardPaymentPayload
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromCardPaymentPayload overwrites any union data inside the OfflineReceiptSellPayload_Payments_Item as the provided CardPaymentPayload
func (t *OfflineReceiptSellPayload_Payments_Item) FromCardPaymentPayload(v CardPaymentPayload) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeCardPaymentPayload performs a merge with any union data inside the OfflineReceiptSellPayload_Payments_Item, using the provided CardPaymentPayload
func (t *OfflineReceiptSellPayload_Payments_Item) MergeCardPaymentPayload(v CardPaymentPayload) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(b, t.union)
	t.union = merged
	return err
}

// AsObsoleteCardPaymentPayload returns the union data inside the OfflineReceiptSellPayload_Payments_Item as a ObsoleteCardPaymentPayload
func (t OfflineReceiptSellPayload_Payments_Item) AsObsoleteCardPaymentPayload() (ObsoleteCardPaymentPayload, error) {
	var body ObsoleteCardPaymentPayload
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromObsoleteCardPaymentPayload overwrites any union data inside the OfflineReceiptSellPayload_Payments_Item as the provided ObsoleteCardPaymentPayload
func (t *OfflineReceiptSellPayload_Payments_Item) FromObsoleteCardPaymentPayload(v ObsoleteCardPaymentPayload) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeObsoleteCardPaymentPayload performs a merge with any union data inside the OfflineReceiptSellPayload_Payments_Item, using the provided ObsoleteCardPaymentPayload
func (t *OfflineReceiptSellPayload_Payments_Item) MergeObsoleteCardPaymentPayload(v ObsoleteCardPaymentPayload) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(b, t.union)
	t.union = merged
	return err
}

func (t OfflineReceiptSellPayload_Payments_Item) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *OfflineReceiptSellPayload_Payments_Item) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsOrderGoodDetailsModelTax0 returns the union data inside the OrderGoodDetailsModel_Tax as a OrderGoodDetailsModelTax0
func (t OrderGoodDetailsModel_Tax) AsOrderGoodDetailsModelTax0() (OrderGoodDetailsModelTax0, error) {
	var body OrderGoodDetailsModelTax0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromOrderGoodDetailsModelTax0 overwrites any union data inside the OrderGoodDetailsModel_Tax as the provided OrderGoodDetailsModelTax0
func (t *OrderGoodDetailsModel_Tax) FromOrderGoodDetailsModelTax0(v OrderGoodDetailsModelTax0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeOrderGoodDetailsModelTax0 performs a merge with any union data inside the OrderGoodDetailsModel_Tax, using the provided OrderGoodDetailsModelTax0
func (t *OrderGoodDetailsModel_Tax) MergeOrderGoodDetailsModelTax0(v OrderGoodDetailsModelTax0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(b, t.union)
	t.union = merged
	return err
}

// AsOrderGoodDetailsModelTax1 returns the union data inside the OrderGoodDetailsModel_Tax as a OrderGoodDetailsModelTax1
func (t OrderGoodDetailsModel_Tax) AsOrderGoodDetailsModelTax1() (OrderGoodDetailsModelTax1, error) {
	var body OrderGoodDetailsModelTax1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromOrderGoodDetailsModelTax1 overwrites any union data inside the OrderGoodDetailsModel_Tax as the provided OrderGoodDetailsModelTax1
func (t *OrderGoodDetailsModel_Tax) FromOrderGoodDetailsModelTax1(v OrderGoodDetailsModelTax1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeOrderGoodDetailsModelTax1 performs a merge with any union data inside the OrderGoodDetailsModel_Tax, using the provided OrderGoodDetailsModelTax1
func (t *OrderGoodDetailsModel_Tax) MergeOrderGoodDetailsModelTax1(v OrderGoodDetailsModelTax1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(b, t.union)
	t.union = merged
	return err
}

func (t OrderGoodDetailsModel_Tax) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *OrderGoodDetailsModel_Tax) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsCashPaymentPayload returns the union data inside the OrderReceiptModel_Payments_Item as a CashPaymentPayload
func (t OrderReceiptModel_Payments_Item) AsCashPaymentPayload() (CashPaymentPayload, error) {
	var body CashPaymentPayload
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromCashPaymentPayload overwrites any union data inside the OrderReceiptModel_Payments_Item as the provided CashPaymentPayload
func (t *OrderReceiptModel_Payments_Item) FromCashPaymentPayload(v CashPaymentPayload) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeCashPaymentPayload performs a merge with any union data inside the OrderReceiptModel_Payments_Item, using the provided CashPaymentPayload
func (t *OrderReceiptModel_Payments_Item) MergeCashPaymentPayload(v CashPaymentPayload) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(b, t.union)
	t.union = merged
	return err
}

// AsCardPaymentPayload returns the union data inside the OrderReceiptModel_Payments_Item as a CardPaymentPayload
func (t OrderReceiptModel_Payments_Item) AsCardPaymentPayload() (CardPaymentPayload, error) {
	var body CardPaymentPayload
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromCardPaymentPayload overwrites any union data inside the OrderReceiptModel_Payments_Item as the provided CardPaymentPayload
func (t *OrderReceiptModel_Payments_Item) FromCardPaymentPayload(v CardPaymentPayload) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeCardPaymentPayload performs a merge with any union data inside the OrderReceiptModel_Payments_Item, using the provided CardPaymentPayload
func (t *OrderReceiptModel_Payments_Item) MergeCardPaymentPayload(v CardPaymentPayload) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(b, t.union)
	t.union = merged
	return err
}

// AsObsoleteCardPaymentPayload returns the union data inside the OrderReceiptModel_Payments_Item as a ObsoleteCardPaymentPayload
func (t OrderReceiptModel_Payments_Item) AsObsoleteCardPaymentPayload() (ObsoleteCardPaymentPayload, error) {
	var body ObsoleteCardPaymentPayload
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromObsoleteCardPaymentPayload overwrites any union data inside the OrderReceiptModel_Payments_Item as the provided ObsoleteCardPaymentPayload
func (t *OrderReceiptModel_Payments_Item) FromObsoleteCardPaymentPayload(v ObsoleteCardPaymentPayload) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeObsoleteCardPaymentPayload performs a merge with any union data inside the OrderReceiptModel_Payments_Item, using the provided ObsoleteCardPaymentPayload
func (t *OrderReceiptModel_Payments_Item) MergeObsoleteCardPaymentPayload(v ObsoleteCardPaymentPayload) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(b, t.union)
	t.union = merged
	return err
}

func (t OrderReceiptModel_Payments_Item) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *OrderReceiptModel_Payments_Item) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsCashPaymentPayload returns the union data inside the ReceiptModel_Payments_Item as a CashPaymentPayload
func (t ReceiptModel_Payments_Item) AsCashPaymentPayload() (CashPaymentPayload, error) {
	var body CashPaymentPayload
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromCashPaymentPayload overwrites any union data inside the ReceiptModel_Payments_Item as the provided CashPaymentPayload
func (t *ReceiptModel_Payments_Item) FromCashPaymentPayload(v CashPaymentPayload) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeCashPaymentPayload performs a merge with any union data inside the ReceiptModel_Payments_Item, using the provided CashPaymentPayload
func (t *ReceiptModel_Payments_Item) MergeCashPaymentPayload(v CashPaymentPayload) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(b, t.union)
	t.union = merged
	return err
}

// AsCardPaymentPayload returns the union data inside the ReceiptModel_Payments_Item as a CardPaymentPayload
func (t ReceiptModel_Payments_Item) AsCardPaymentPayload() (CardPaymentPayload, error) {
	var body CardPaymentPayload
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromCardPaymentPayload overwrites any union data inside the ReceiptModel_Payments_Item as the provided CardPaymentPayload
func (t *ReceiptModel_Payments_Item) FromCardPaymentPayload(v CardPaymentPayload) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeCardPaymentPayload performs a merge with any union data inside the ReceiptModel_Payments_Item, using the provided CardPaymentPayload
func (t *ReceiptModel_Payments_Item) MergeCardPaymentPayload(v CardPaymentPayload) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(b, t.union)
	t.union = merged
	return err
}

// AsObsoleteCardPaymentPayload returns the union data inside the ReceiptModel_Payments_Item as a ObsoleteCardPaymentPayload
func (t ReceiptModel_Payments_Item) AsObsoleteCardPaymentPayload() (ObsoleteCardPaymentPayload, error) {
	var body ObsoleteCardPaymentPayload
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromObsoleteCardPaymentPayload overwrites any union data inside the ReceiptModel_Payments_Item as the provided ObsoleteCardPaymentPayload
func (t *ReceiptModel_Payments_Item) FromObsoleteCardPaymentPayload(v ObsoleteCardPaymentPayload) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeObsoleteCardPaymentPayload performs a merge with any union data inside the ReceiptModel_Payments_Item, using the provided ObsoleteCardPaymentPayload
func (t *ReceiptModel_Payments_Item) MergeObsoleteCardPaymentPayload(v ObsoleteCardPaymentPayload) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(b, t.union)
	t.union = merged
	return err
}

func (t ReceiptModel_Payments_Item) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *ReceiptModel_Payments_Item) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsReceiptSellPayloadContext0 returns the union data inside the ReceiptSellPayload_Context_AdditionalProperties as a ReceiptSellPayloadContext0
func (t ReceiptSellPayload_Context_AdditionalProperties) AsReceiptSellPayloadContext0() (ReceiptSellPayloadContext0, error) {
	var body ReceiptSellPayloadContext0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromReceiptSellPayloadContext0 overwrites any union data inside the ReceiptSellPayload_Context_AdditionalProperties as the provided ReceiptSellPayloadContext0
func (t *ReceiptSellPayload_Context_AdditionalProperties) FromReceiptSellPayloadContext0(v ReceiptSellPayloadContext0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeReceiptSellPayloadContext0 performs a merge with any union data inside the ReceiptSellPayload_Context_AdditionalProperties, using the provided ReceiptSellPayloadContext0
func (t *ReceiptSellPayload_Context_AdditionalProperties) MergeReceiptSellPayloadContext0(v ReceiptSellPayloadContext0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(b, t.union)
	t.union = merged
	return err
}

// AsReceiptSellPayloadContext1 returns the union data inside the ReceiptSellPayload_Context_AdditionalProperties as a ReceiptSellPayloadContext1
func (t ReceiptSellPayload_Context_AdditionalProperties) AsReceiptSellPayloadContext1() (ReceiptSellPayloadContext1, error) {
	var body ReceiptSellPayloadContext1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromReceiptSellPayloadContext1 overwrites any union data inside the ReceiptSellPayload_Context_AdditionalProperties as the provided ReceiptSellPayloadContext1
func (t *ReceiptSellPayload_Context_AdditionalProperties) FromReceiptSellPayloadContext1(v ReceiptSellPayloadContext1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeReceiptSellPayloadContext1 performs a merge with any union data inside the ReceiptSellPayload_Context_AdditionalProperties, using the provided ReceiptSellPayloadContext1
func (t *ReceiptSellPayload_Context_AdditionalProperties) MergeReceiptSellPayloadContext1(v ReceiptSellPayloadContext1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(b, t.union)
	t.union = merged
	return err
}

// AsReceiptSellPayloadContext2 returns the union data inside the ReceiptSellPayload_Context_AdditionalProperties as a ReceiptSellPayloadContext2
func (t ReceiptSellPayload_Context_AdditionalProperties) AsReceiptSellPayloadContext2() (ReceiptSellPayloadContext2, error) {
	var body ReceiptSellPayloadContext2
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromReceiptSellPayloadContext2 overwrites any union data inside the ReceiptSellPayload_Context_AdditionalProperties as the provided ReceiptSellPayloadContext2
func (t *ReceiptSellPayload_Context_AdditionalProperties) FromReceiptSellPayloadContext2(v ReceiptSellPayloadContext2) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeReceiptSellPayloadContext2 performs a merge with any union data inside the ReceiptSellPayload_Context_AdditionalProperties, using the provided ReceiptSellPayloadContext2
func (t *ReceiptSellPayload_Context_AdditionalProperties) MergeReceiptSellPayloadContext2(v ReceiptSellPayloadContext2) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(b, t.union)
	t.union = merged
	return err
}

// AsReceiptSellPayloadContext3 returns the union data inside the ReceiptSellPayload_Context_AdditionalProperties as a ReceiptSellPayloadContext3
func (t ReceiptSellPayload_Context_AdditionalProperties) AsReceiptSellPayloadContext3() (ReceiptSellPayloadContext3, error) {
	var body ReceiptSellPayloadContext3
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromReceiptSellPayloadContext3 overwrites any union data inside the ReceiptSellPayload_Context_AdditionalProperties as the provided ReceiptSellPayloadContext3
func (t *ReceiptSellPayload_Context_AdditionalProperties) FromReceiptSellPayloadContext3(v ReceiptSellPayloadContext3) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeReceiptSellPayloadContext3 performs a merge with any union data inside the ReceiptSellPayload_Context_AdditionalProperties, using the provided ReceiptSellPayloadContext3
func (t *ReceiptSellPayload_Context_AdditionalProperties) MergeReceiptSellPayloadContext3(v ReceiptSellPayloadContext3) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(b, t.union)
	t.union = merged
	return err
}

func (t ReceiptSellPayload_Context_AdditionalProperties) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *ReceiptSellPayload_Context_AdditionalProperties) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsCashPaymentPayload returns the union data inside the ReceiptSellPayload_Payments_Item as a CashPaymentPayload
func (t ReceiptSellPayload_Payments_Item) AsCashPaymentPayload() (CashPaymentPayload, error) {
	var body CashPaymentPayload
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromCashPaymentPayload overwrites any union data inside the ReceiptSellPayload_Payments_Item as the provided CashPaymentPayload
func (t *ReceiptSellPayload_Payments_Item) FromCashPaymentPayload(v CashPaymentPayload) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeCashPaymentPayload performs a merge with any union data inside the ReceiptSellPayload_Payments_Item, using the provided CashPaymentPayload
func (t *ReceiptSellPayload_Payments_Item) MergeCashPaymentPayload(v CashPaymentPayload) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(b, t.union)
	t.union = merged
	return err
}

// AsCardPaymentPayload returns the union data inside the ReceiptSellPayload_Payments_Item as a CardPaymentPayload
func (t ReceiptSellPayload_Payments_Item) AsCardPaymentPayload() (CardPaymentPayload, error) {
	var body CardPaymentPayload
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromCardPaymentPayload overwrites any union data inside the ReceiptSellPayload_Payments_Item as the provided CardPaymentPayload
func (t *ReceiptSellPayload_Payments_Item) FromCardPaymentPayload(v CardPaymentPayload) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeCardPaymentPayload performs a merge with any union data inside the ReceiptSellPayload_Payments_Item, using the provided CardPaymentPayload
func (t *ReceiptSellPayload_Payments_Item) MergeCardPaymentPayload(v CardPaymentPayload) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(b, t.union)
	t.union = merged
	return err
}

// AsObsoleteCardPaymentPayload returns the union data inside the ReceiptSellPayload_Payments_Item as a ObsoleteCardPaymentPayload
func (t ReceiptSellPayload_Payments_Item) AsObsoleteCardPaymentPayload() (ObsoleteCardPaymentPayload, error) {
	var body ObsoleteCardPaymentPayload
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromObsoleteCardPaymentPayload overwrites any union data inside the ReceiptSellPayload_Payments_Item as the provided ObsoleteCardPaymentPayload
func (t *ReceiptSellPayload_Payments_Item) FromObsoleteCardPaymentPayload(v ObsoleteCardPaymentPayload) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeObsoleteCardPaymentPayload performs a merge with any union data inside the ReceiptSellPayload_Payments_Item, using the provided ObsoleteCardPaymentPayload
func (t *ReceiptSellPayload_Payments_Item) MergeObsoleteCardPaymentPayload(v ObsoleteCardPaymentPayload) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(b, t.union)
	t.union = merged
	return err
}

func (t ReceiptSellPayload_Payments_Item) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *ReceiptSellPayload_Payments_Item) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsReceiptServicePayloadContext0 returns the union data inside the ReceiptServicePayload_Context_AdditionalProperties as a ReceiptServicePayloadContext0
func (t ReceiptServicePayload_Context_AdditionalProperties) AsReceiptServicePayloadContext0() (ReceiptServicePayloadContext0, error) {
	var body ReceiptServicePayloadContext0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromReceiptServicePayloadContext0 overwrites any union data inside the ReceiptServicePayload_Context_AdditionalProperties as the provided ReceiptServicePayloadContext0
func (t *ReceiptServicePayload_Context_AdditionalProperties) FromReceiptServicePayloadContext0(v ReceiptServicePayloadContext0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeReceiptServicePayloadContext0 performs a merge with any union data inside the ReceiptServicePayload_Context_AdditionalProperties, using the provided ReceiptServicePayloadContext0
func (t *ReceiptServicePayload_Context_AdditionalProperties) MergeReceiptServicePayloadContext0(v ReceiptServicePayloadContext0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(b, t.union)
	t.union = merged
	return err
}

// AsReceiptServicePayloadContext1 returns the union data inside the ReceiptServicePayload_Context_AdditionalProperties as a ReceiptServicePayloadContext1
func (t ReceiptServicePayload_Context_AdditionalProperties) AsReceiptServicePayloadContext1() (ReceiptServicePayloadContext1, error) {
	var body ReceiptServicePayloadContext1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromReceiptServicePayloadContext1 overwrites any union data inside the ReceiptServicePayload_Context_AdditionalProperties as the provided ReceiptServicePayloadContext1
func (t *ReceiptServicePayload_Context_AdditionalProperties) FromReceiptServicePayloadContext1(v ReceiptServicePayloadContext1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeReceiptServicePayloadContext1 performs a merge with any union data inside the ReceiptServicePayload_Context_AdditionalProperties, using the provided ReceiptServicePayloadContext1
func (t *ReceiptServicePayload_Context_AdditionalProperties) MergeReceiptServicePayloadContext1(v ReceiptServicePayloadContext1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(b, t.union)
	t.union = merged
	return err
}

// AsReceiptServicePayloadContext2 returns the union data inside the ReceiptServicePayload_Context_AdditionalProperties as a ReceiptServicePayloadContext2
func (t ReceiptServicePayload_Context_AdditionalProperties) AsReceiptServicePayloadContext2() (ReceiptServicePayloadContext2, error) {
	var body ReceiptServicePayloadContext2
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromReceiptServicePayloadContext2 overwrites any union data inside the ReceiptServicePayload_Context_AdditionalProperties as the provided ReceiptServicePayloadContext2
func (t *ReceiptServicePayload_Context_AdditionalProperties) FromReceiptServicePayloadContext2(v ReceiptServicePayloadContext2) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeReceiptServicePayloadContext2 performs a merge with any union data inside the ReceiptServicePayload_Context_AdditionalProperties, using the provided ReceiptServicePayloadContext2
func (t *ReceiptServicePayload_Context_AdditionalProperties) MergeReceiptServicePayloadContext2(v ReceiptServicePayloadContext2) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(b, t.union)
	t.union = merged
	return err
}

// AsReceiptServicePayloadContext3 returns the union data inside the ReceiptServicePayload_Context_AdditionalProperties as a ReceiptServicePayloadContext3
func (t ReceiptServicePayload_Context_AdditionalProperties) AsReceiptServicePayloadContext3() (ReceiptServicePayloadContext3, error) {
	var body ReceiptServicePayloadContext3
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromReceiptServicePayloadContext3 overwrites any union data inside the ReceiptServicePayload_Context_AdditionalProperties as the provided ReceiptServicePayloadContext3
func (t *ReceiptServicePayload_Context_AdditionalProperties) FromReceiptServicePayloadContext3(v ReceiptServicePayloadContext3) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeReceiptServicePayloadContext3 performs a merge with any union data inside the ReceiptServicePayload_Context_AdditionalProperties, using the provided ReceiptServicePayloadContext3
func (t *ReceiptServicePayload_Context_AdditionalProperties) MergeReceiptServicePayloadContext3(v ReceiptServicePayloadContext3) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(b, t.union)
	t.union = merged
	return err
}

func (t ReceiptServicePayload_Context_AdditionalProperties) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *ReceiptServicePayload_Context_AdditionalProperties) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsCashPaymentPayload returns the union data inside the ReceiptServicePayload_Payment as a CashPaymentPayload
func (t ReceiptServicePayload_Payment) AsCashPaymentPayload() (CashPaymentPayload, error) {
	var body CashPaymentPayload
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromCashPaymentPayload overwrites any union data inside the ReceiptServicePayload_Payment as the provided CashPaymentPayload
func (t *ReceiptServicePayload_Payment) FromCashPaymentPayload(v CashPaymentPayload) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeCashPaymentPayload performs a merge with any union data inside the ReceiptServicePayload_Payment, using the provided CashPaymentPayload
func (t *ReceiptServicePayload_Payment) MergeCashPaymentPayload(v CashPaymentPayload) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(b, t.union)
	t.union = merged
	return err
}

// AsCardPaymentPayload returns the union data inside the ReceiptServicePayload_Payment as a CardPaymentPayload
func (t ReceiptServicePayload_Payment) AsCardPaymentPayload() (CardPaymentPayload, error) {
	var body CardPaymentPayload
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromCardPaymentPayload overwrites any union data inside the ReceiptServicePayload_Payment as the provided CardPaymentPayload
func (t *ReceiptServicePayload_Payment) FromCardPaymentPayload(v CardPaymentPayload) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeCardPaymentPayload performs a merge with any union data inside the ReceiptServicePayload_Payment, using the provided CardPaymentPayload
func (t *ReceiptServicePayload_Payment) MergeCardPaymentPayload(v CardPaymentPayload) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(b, t.union)
	t.union = merged
	return err
}

// AsObsoleteCardPaymentPayload returns the union data inside the ReceiptServicePayload_Payment as a ObsoleteCardPaymentPayload
func (t ReceiptServicePayload_Payment) AsObsoleteCardPaymentPayload() (ObsoleteCardPaymentPayload, error) {
	var body ObsoleteCardPaymentPayload
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromObsoleteCardPaymentPayload overwrites any union data inside the ReceiptServicePayload_Payment as the provided ObsoleteCardPaymentPayload
func (t *ReceiptServicePayload_Payment) FromObsoleteCardPaymentPayload(v ObsoleteCardPaymentPayload) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeObsoleteCardPaymentPayload performs a merge with any union data inside the ReceiptServicePayload_Payment, using the provided ObsoleteCardPaymentPayload
func (t *ReceiptServicePayload_Payment) MergeObsoleteCardPaymentPayload(v ObsoleteCardPaymentPayload) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(b, t.union)
	t.union = merged
	return err
}

func (t ReceiptServicePayload_Payment) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *ReceiptServicePayload_Payment) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsCashPaymentPayload returns the union data inside the ShortReceiptModel_Payments_Item as a CashPaymentPayload
func (t ShortReceiptModel_Payments_Item) AsCashPaymentPayload() (CashPaymentPayload, error) {
	var body CashPaymentPayload
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromCashPaymentPayload overwrites any union data inside the ShortReceiptModel_Payments_Item as the provided CashPaymentPayload
func (t *ShortReceiptModel_Payments_Item) FromCashPaymentPayload(v CashPaymentPayload) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeCashPaymentPayload performs a merge with any union data inside the ShortReceiptModel_Payments_Item, using the provided CashPaymentPayload
func (t *ShortReceiptModel_Payments_Item) MergeCashPaymentPayload(v CashPaymentPayload) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(b, t.union)
	t.union = merged
	return err
}

// AsCardPaymentPayload returns the union data inside the ShortReceiptModel_Payments_Item as a CardPaymentPayload
func (t ShortReceiptModel_Payments_Item) AsCardPaymentPayload() (CardPaymentPayload, error) {
	var body CardPaymentPayload
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromCardPaymentPayload overwrites any union data inside the ShortReceiptModel_Payments_Item as the provided CardPaymentPayload
func (t *ShortReceiptModel_Payments_Item) FromCardPaymentPayload(v CardPaymentPayload) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeCardPaymentPayload performs a merge with any union data inside the ShortReceiptModel_Payments_Item, using the provided CardPaymentPayload
func (t *ShortReceiptModel_Payments_Item) MergeCardPaymentPayload(v CardPaymentPayload) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(b, t.union)
	t.union = merged
	return err
}

// AsObsoleteCardPaymentPayload returns the union data inside the ShortReceiptModel_Payments_Item as a ObsoleteCardPaymentPayload
func (t ShortReceiptModel_Payments_Item) AsObsoleteCardPaymentPayload() (ObsoleteCardPaymentPayload, error) {
	var body ObsoleteCardPaymentPayload
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromObsoleteCardPaymentPayload overwrites any union data inside the ShortReceiptModel_Payments_Item as the provided ObsoleteCardPaymentPayload
func (t *ShortReceiptModel_Payments_Item) FromObsoleteCardPaymentPayload(v ObsoleteCardPaymentPayload) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeObsoleteCardPaymentPayload performs a merge with any union data inside the ShortReceiptModel_Payments_Item, using the provided ObsoleteCardPaymentPayload
func (t *ShortReceiptModel_Payments_Item) MergeObsoleteCardPaymentPayload(v ObsoleteCardPaymentPayload) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(b, t.union)
	t.union = merged
	return err
}

func (t ShortReceiptModel_Payments_Item) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *ShortReceiptModel_Payments_Item) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// RequestEditorFn  is the function signature for the RequestEditor callback function
type RequestEditorFn func(ctx context.Context, req *http.Request) error

// Doer performs HTTP requests.
//
// The standard http.Client implements this interface.
type HttpRequestDoer interface {
	Do(req *http.Request) (*http.Response, error)
}

// Client which conforms to the OpenAPI3 specification for this service.
type Client struct {
	// The endpoint of the server conforming to this interface, with scheme,
	// https://api.deepmap.com for example. This can contain a path relative
	// to the server, such as https://api.deepmap.com/dev-test, and all the
	// paths in the swagger spec will be appended to the server.
	Server string

	// Doer for performing requests, typically a *http.Client with any
	// customized settings, such as certificate chains.
	Client HttpRequestDoer

	// A list of callbacks for modifying requests which are generated before sending over
	// the network.
	RequestEditors []RequestEditorFn
}

// ClientOption allows setting custom parameters during construction
type ClientOption func(*Client) error

// Creates a new Client, with reasonable defaults
func NewClient(server string, opts ...ClientOption) (*Client, error) {
	// create a client with sane default values
	client := Client{
		Server: server,
	}
	// mutate client and add all optional params
	for _, o := range opts {
		if err := o(&client); err != nil {
			return nil, err
		}
	}
	// ensure the server URL always has a trailing slash
	if !strings.HasSuffix(client.Server, "/") {
		client.Server += "/"
	}
	// create httpClient, if not already present
	if client.Client == nil {
		client.Client = &http.Client{}
	}
	return &client, nil
}

// WithHTTPClient allows overriding the default Doer, which is
// automatically created using http.Client. This is useful for tests.
func WithHTTPClient(doer HttpRequestDoer) ClientOption {
	return func(c *Client) error {
		c.Client = doer
		return nil
	}
}

// WithRequestEditorFn allows setting up a callback function, which will be
// called right before sending the request. This can be used to mutate the request.
func WithRequestEditorFn(fn RequestEditorFn) ClientOption {
	return func(c *Client) error {
		c.RequestEditors = append(c.RequestEditors, fn)
		return nil
	}
}

// The interface specification for the client above.
type ClientInterface interface {
	// GetCashRegistersApiV1CashRegistersGet request
	GetCashRegistersApiV1CashRegistersGet(ctx context.Context, params *GetCashRegistersApiV1CashRegistersGetParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AskOfflineCodesApiV1CashRegistersAskOfflineCodesGet request
	AskOfflineCodesApiV1CashRegistersAskOfflineCodesGet(ctx context.Context, params *AskOfflineCodesApiV1CashRegistersAskOfflineCodesGetParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetOfflineCodesApiV1CashRegistersGetOfflineCodesGet request
	GetOfflineCodesApiV1CashRegistersGetOfflineCodesGet(ctx context.Context, params *GetOfflineCodesApiV1CashRegistersGetOfflineCodesGetParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetOfflineCodesCountApiV1CashRegistersGetOfflineCodesCountGet request
	GetOfflineCodesCountApiV1CashRegistersGetOfflineCodesCountGet(ctx context.Context, params *GetOfflineCodesCountApiV1CashRegistersGetOfflineCodesCountGetParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetOfflineTimeApiV1CashRegistersGetOfflineTimeGet request
	GetOfflineTimeApiV1CashRegistersGetOfflineTimeGet(ctx context.Context, params *GetOfflineTimeApiV1CashRegistersGetOfflineTimeGetParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GoOfflineActionApiV1CashRegistersGoOfflinePost request with any body
	GoOfflineActionApiV1CashRegistersGoOfflinePostWithBody(ctx context.Context, params *GoOfflineActionApiV1CashRegistersGoOfflinePostParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	GoOfflineActionApiV1CashRegistersGoOfflinePost(ctx context.Context, params *GoOfflineActionApiV1CashRegistersGoOfflinePostParams, body GoOfflineActionApiV1CashRegistersGoOfflinePostJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GoOnlineActionApiV1CashRegistersGoOnlinePost request
	GoOnlineActionApiV1CashRegistersGoOnlinePost(ctx context.Context, params *GoOnlineActionApiV1CashRegistersGoOnlinePostParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetCashRegisterInfoApiV1CashRegistersInfoGet request
	GetCashRegisterInfoApiV1CashRegistersInfoGet(ctx context.Context, params *GetCashRegisterInfoApiV1CashRegistersInfoGetParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PingTaxServiceActionApiV1CashRegistersPingTaxServicePost request
	PingTaxServiceActionApiV1CashRegistersPingTaxServicePost(ctx context.Context, params *PingTaxServiceActionApiV1CashRegistersPingTaxServicePostParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetCashRegisterApiV1CashRegistersCashRegisterIdGet request
	GetCashRegisterApiV1CashRegistersCashRegisterIdGet(ctx context.Context, cashRegisterId openapi_types.UUID, params *GetCashRegisterApiV1CashRegistersCashRegisterIdGetParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CheckSignatureApiV1CashierCheckSignatureGet request
	CheckSignatureApiV1CashierCheckSignatureGet(ctx context.Context, params *CheckSignatureApiV1CashierCheckSignatureGetParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetCashierProfileApiV1CashierMeGet request
	GetCashierProfileApiV1CashierMeGet(ctx context.Context, params *GetCashierProfileApiV1CashierMeGetParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetCashierShiftApiV1CashierShiftGet request
	GetCashierShiftApiV1CashierShiftGet(ctx context.Context, params *GetCashierShiftApiV1CashierShiftGetParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SignInCashierApiV1CashierSigninPost request with any body
	SignInCashierApiV1CashierSigninPostWithBody(ctx context.Context, params *SignInCashierApiV1CashierSigninPostParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	SignInCashierApiV1CashierSigninPost(ctx context.Context, params *SignInCashierApiV1CashierSigninPostParams, body SignInCashierApiV1CashierSigninPostJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SignInCashierViaPinCodeApiV1CashierSigninPinCodePost request with any body
	SignInCashierViaPinCodeApiV1CashierSigninPinCodePostWithBody(ctx context.Context, params *SignInCashierViaPinCodeApiV1CashierSigninPinCodePostParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	SignInCashierViaPinCodeApiV1CashierSigninPinCodePost(ctx context.Context, params *SignInCashierViaPinCodeApiV1CashierSigninPinCodePostParams, body SignInCashierViaPinCodeApiV1CashierSigninPinCodePostJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SignOutCashierApiV1CashierSignoutPost request
	SignOutCashierApiV1CashierSignoutPost(ctx context.Context, params *SignOutCashierApiV1CashierSignoutPostParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetCurrencyRatesApiV1CurrencyRateGet request
	GetCurrencyRatesApiV1CurrencyRateGet(ctx context.Context, params *GetCurrencyRatesApiV1CurrencyRateGetParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SetupCurrencyRatesApiV1CurrencyRateSetupPost request with any body
	SetupCurrencyRatesApiV1CurrencyRateSetupPostWithBody(ctx context.Context, params *SetupCurrencyRatesApiV1CurrencyRateSetupPostParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	SetupCurrencyRatesApiV1CurrencyRateSetupPost(ctx context.Context, params *SetupCurrencyRatesApiV1CurrencyRateSetupPostParams, body SetupCurrencyRatesApiV1CurrencyRateSetupPostJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetCurrencyRateApiV1CurrencyRateCurrencyCodeGet request
	GetCurrencyRateApiV1CurrencyRateCurrencyCodeGet(ctx context.Context, currencyCode string, params *GetCurrencyRateApiV1CurrencyRateCurrencyCodeGetParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GoodsReportApiV1ExtendedReportsGoodsPost request with any body
	GoodsReportApiV1ExtendedReportsGoodsPostWithBody(ctx context.Context, params *GoodsReportApiV1ExtendedReportsGoodsPostParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	GoodsReportApiV1ExtendedReportsGoodsPost(ctx context.Context, params *GoodsReportApiV1ExtendedReportsGoodsPostParams, body GoodsReportApiV1ExtendedReportsGoodsPostJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetReportTaskByIdApiV1ExtendedReportsReportTaskIdGet request
	GetReportTaskByIdApiV1ExtendedReportsReportTaskIdGet(ctx context.Context, reportTaskId openapi_types.UUID, params *GetReportTaskByIdApiV1ExtendedReportsReportTaskIdGetParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetReportXlsxByIdApiV1ExtendedReportsReportTaskIdReportXlsxGet request
	GetReportXlsxByIdApiV1ExtendedReportsReportTaskIdReportXlsxGet(ctx context.Context, reportTaskId openapi_types.UUID, params *GetReportXlsxByIdApiV1ExtendedReportsReportTaskIdReportXlsxGetParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetGoodsApiV1GoodsGet request
	GetGoodsApiV1GoodsGet(ctx context.Context, params *GetGoodsApiV1GoodsGetParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ExportGoodsFileApiV1GoodsExportFileTaskIdGet request
	ExportGoodsFileApiV1GoodsExportFileTaskIdGet(ctx context.Context, taskId openapi_types.UUID, params *ExportGoodsFileApiV1GoodsExportFileTaskIdGetParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ExportGoodsTaskStatusApiV1GoodsExportTaskStatusTaskIdGet request
	ExportGoodsTaskStatusApiV1GoodsExportTaskStatusTaskIdGet(ctx context.Context, taskId openapi_types.UUID, params *ExportGoodsTaskStatusApiV1GoodsExportTaskStatusTaskIdGetParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ExportGoodsApiV1GoodsExportExportExtensionGet request
	ExportGoodsApiV1GoodsExportExportExtensionGet(ctx context.Context, exportExtension ExportExtensionType, params *ExportGoodsApiV1GoodsExportExportExtensionGetParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ImportGoodsApplyChangesApiV1GoodsImportApplyChangesTaskIdPost request
	ImportGoodsApplyChangesApiV1GoodsImportApplyChangesTaskIdPost(ctx context.Context, taskId openapi_types.UUID, params *ImportGoodsApplyChangesApiV1GoodsImportApplyChangesTaskIdPostParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ImportGoodsTaskStatusApiV1GoodsImportTaskStatusTaskIdGet request
	ImportGoodsTaskStatusApiV1GoodsImportTaskStatusTaskIdGet(ctx context.Context, taskId openapi_types.UUID, params *ImportGoodsTaskStatusApiV1GoodsImportTaskStatusTaskIdGetParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ImportGoodsFromFileApiV1GoodsImportUploadPost request with any body
	ImportGoodsFromFileApiV1GoodsImportUploadPostWithBody(ctx context.Context, params *ImportGoodsFromFileApiV1GoodsImportUploadPostParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetGoodApiV1GoodsGoodIdGet request
	GetGoodApiV1GoodsGoodIdGet(ctx context.Context, goodId openapi_types.UUID, params *GetGoodApiV1GoodsGoodIdGetParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetOrdersApiV1OrdersGet request
	GetOrdersApiV1OrdersGet(ctx context.Context, params *GetOrdersApiV1OrdersGetParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AddOrdersApiV1OrdersPost request with any body
	AddOrdersApiV1OrdersPostWithBody(ctx context.Context, params *AddOrdersApiV1OrdersPostParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	AddOrdersApiV1OrdersPost(ctx context.Context, params *AddOrdersApiV1OrdersPostParams, body AddOrdersApiV1OrdersPostJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CloseNotFiscalizeOrderApiV1OrdersClosePatch request
	CloseNotFiscalizeOrderApiV1OrdersClosePatch(ctx context.Context, params *CloseNotFiscalizeOrderApiV1OrdersClosePatchParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateCustomOrderStatusApiV1OrdersCustomStatusOrderIdPatch request
	UpdateCustomOrderStatusApiV1OrdersCustomStatusOrderIdPatch(ctx context.Context, orderId openapi_types.UUID, params *UpdateCustomOrderStatusApiV1OrdersCustomStatusOrderIdPatchParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteIntegrationApiV1OrdersIntegrationDelete request
	DeleteIntegrationApiV1OrdersIntegrationDelete(ctx context.Context, params *DeleteIntegrationApiV1OrdersIntegrationDeleteParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetIntegrationApiV1OrdersIntegrationGet request
	GetIntegrationApiV1OrdersIntegrationGet(ctx context.Context, params *GetIntegrationApiV1OrdersIntegrationGetParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SetIntegrationApiV1OrdersIntegrationPost request with any body
	SetIntegrationApiV1OrdersIntegrationPostWithBody(ctx context.Context, params *SetIntegrationApiV1OrdersIntegrationPostParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	SetIntegrationApiV1OrdersIntegrationPost(ctx context.Context, params *SetIntegrationApiV1OrdersIntegrationPostParams, body SetIntegrationApiV1OrdersIntegrationPostJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// EditOrderApiV1OrdersIntegrationEditOrderPost request with any body
	EditOrderApiV1OrdersIntegrationEditOrderPostWithBody(ctx context.Context, params *EditOrderApiV1OrdersIntegrationEditOrderPostParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	EditOrderApiV1OrdersIntegrationEditOrderPost(ctx context.Context, params *EditOrderApiV1OrdersIntegrationEditOrderPostParams, body EditOrderApiV1OrdersIntegrationEditOrderPostJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RunOrdersSynchronizationApiV1OrdersSyncPost request
	RunOrdersSynchronizationApiV1OrdersSyncPost(ctx context.Context, params *RunOrdersSynchronizationApiV1OrdersSyncPostParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetOrderApiV1OrdersOrderIdGet request
	GetOrderApiV1OrdersOrderIdGet(ctx context.Context, orderId openapi_types.UUID, params *GetOrderApiV1OrdersOrderIdGetParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CancelOrderApiV1OrdersOrderIdPatch request
	CancelOrderApiV1OrdersOrderIdPatch(ctx context.Context, orderId openapi_types.UUID, params *CancelOrderApiV1OrdersOrderIdPatchParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetCurrentOrganizationLogoApiV1OrganizationLogoPngGet request
	GetCurrentOrganizationLogoApiV1OrganizationLogoPngGet(ctx context.Context, params *GetCurrentOrganizationLogoApiV1OrganizationLogoPngGetParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetCurrentOrganizationReceiptSettingsApiV1OrganizationReceiptConfigGet request
	GetCurrentOrganizationReceiptSettingsApiV1OrganizationReceiptConfigGet(ctx context.Context, params *GetCurrentOrganizationReceiptSettingsApiV1OrganizationReceiptConfigGetParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetCurrentOrganizationSmsBillingBalanceApiV1OrganizationSmsBillingGet request
	GetCurrentOrganizationSmsBillingBalanceApiV1OrganizationSmsBillingGet(ctx context.Context, params *GetCurrentOrganizationSmsBillingBalanceApiV1OrganizationSmsBillingGetParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetCurrentOrganizationTextLogoApiV1OrganizationTextLogoPngGet request
	GetCurrentOrganizationTextLogoApiV1OrganizationTextLogoPngGet(ctx context.Context, params *GetCurrentOrganizationTextLogoApiV1OrganizationTextLogoPngGetParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetReceiptsApiV1ReceiptsGet request
	GetReceiptsApiV1ReceiptsGet(ctx context.Context, params *GetReceiptsApiV1ReceiptsGetParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AddExternalReceiptApiV1ReceiptsAddExternalPost request with any body
	AddExternalReceiptApiV1ReceiptsAddExternalPostWithBody(ctx context.Context, params *AddExternalReceiptApiV1ReceiptsAddExternalPostParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	AddExternalReceiptApiV1ReceiptsAddExternalPost(ctx context.Context, params *AddExternalReceiptApiV1ReceiptsAddExternalPostParams, body AddExternalReceiptApiV1ReceiptsAddExternalPostJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CashWithdrawalApiV1ReceiptsCashWithdrawalPost request with any body
	CashWithdrawalApiV1ReceiptsCashWithdrawalPostWithBody(ctx context.Context, params *CashWithdrawalApiV1ReceiptsCashWithdrawalPostParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CashWithdrawalApiV1ReceiptsCashWithdrawalPost(ctx context.Context, params *CashWithdrawalApiV1ReceiptsCashWithdrawalPostParams, body CashWithdrawalApiV1ReceiptsCashWithdrawalPostJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ExchangeApiV1ReceiptsCurrencyExchangePost request with any body
	ExchangeApiV1ReceiptsCurrencyExchangePostWithBody(ctx context.Context, params *ExchangeApiV1ReceiptsCurrencyExchangePostParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ExchangeApiV1ReceiptsCurrencyExchangePost(ctx context.Context, params *ExchangeApiV1ReceiptsCurrencyExchangePostParams, body ExchangeApiV1ReceiptsCurrencyExchangePostJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetReceiptsSearchApiV1ReceiptsSearchGet request
	GetReceiptsSearchApiV1ReceiptsSearchGet(ctx context.Context, params *GetReceiptsSearchApiV1ReceiptsSearchGetParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateReceiptApiV1ReceiptsSellPost request with any body
	CreateReceiptApiV1ReceiptsSellPostWithBody(ctx context.Context, params *CreateReceiptApiV1ReceiptsSellPostParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateReceiptApiV1ReceiptsSellPost(ctx context.Context, params *CreateReceiptApiV1ReceiptsSellPostParams, body CreateReceiptApiV1ReceiptsSellPostJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateOfflineReceiptApiV1ReceiptsSellOfflinePost request with any body
	CreateOfflineReceiptApiV1ReceiptsSellOfflinePostWithBody(ctx context.Context, params *CreateOfflineReceiptApiV1ReceiptsSellOfflinePostParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateOfflineReceiptApiV1ReceiptsSellOfflinePost(ctx context.Context, params *CreateOfflineReceiptApiV1ReceiptsSellOfflinePostParams, body CreateOfflineReceiptApiV1ReceiptsSellOfflinePostJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateServiceReceiptApiV1ReceiptsServicePost request with any body
	CreateServiceReceiptApiV1ReceiptsServicePostWithBody(ctx context.Context, params *CreateServiceReceiptApiV1ReceiptsServicePostParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateServiceReceiptApiV1ReceiptsServicePost(ctx context.Context, params *CreateServiceReceiptApiV1ReceiptsServicePostParams, body CreateServiceReceiptApiV1ReceiptsServicePostJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateServiceCurrencyReceiptApiV1ReceiptsServiceCurrencyPost request with any body
	CreateServiceCurrencyReceiptApiV1ReceiptsServiceCurrencyPostWithBody(ctx context.Context, params *CreateServiceCurrencyReceiptApiV1ReceiptsServiceCurrencyPostParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateServiceCurrencyReceiptApiV1ReceiptsServiceCurrencyPost(ctx context.Context, params *CreateServiceCurrencyReceiptApiV1ReceiptsServiceCurrencyPostParams, body CreateServiceCurrencyReceiptApiV1ReceiptsServiceCurrencyPostJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetReceiptApiV1ReceiptsReceiptIdGet request
	GetReceiptApiV1ReceiptsReceiptIdGet(ctx context.Context, receiptId struct {
		union json.RawMessage
	}, params *GetReceiptApiV1ReceiptsReceiptIdGetParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SendReceiptToEmailApiV1ReceiptsReceiptIdEmailPost request with any body
	SendReceiptToEmailApiV1ReceiptsReceiptIdEmailPostWithBody(ctx context.Context, receiptId struct {
		union json.RawMessage
	}, params *SendReceiptToEmailApiV1ReceiptsReceiptIdEmailPostParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	SendReceiptToEmailApiV1ReceiptsReceiptIdEmailPost(ctx context.Context, receiptId struct {
		union json.RawMessage
	}, params *SendReceiptToEmailApiV1ReceiptsReceiptIdEmailPostParams, body SendReceiptToEmailApiV1ReceiptsReceiptIdEmailPostJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetReceiptHtmlApiV1ReceiptsReceiptIdHtmlGet request
	GetReceiptHtmlApiV1ReceiptsReceiptIdHtmlGet(ctx context.Context, receiptId struct {
		union json.RawMessage
	}, params *GetReceiptHtmlApiV1ReceiptsReceiptIdHtmlGetParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetReceiptPdfApiV1ReceiptsReceiptIdPdfGet request
	GetReceiptPdfApiV1ReceiptsReceiptIdPdfGet(ctx context.Context, receiptId struct {
		union json.RawMessage
	}, params *GetReceiptPdfApiV1ReceiptsReceiptIdPdfGetParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetReceiptPngApiV1ReceiptsReceiptIdPngGet request
	GetReceiptPngApiV1ReceiptsReceiptIdPngGet(ctx context.Context, receiptId struct {
		union json.RawMessage
	}, params *GetReceiptPngApiV1ReceiptsReceiptIdPngGetParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetReceiptQrCodeImageApiV1ReceiptsReceiptIdQrcodeGet request
	GetReceiptQrCodeImageApiV1ReceiptsReceiptIdQrcodeGet(ctx context.Context, receiptId struct {
		union json.RawMessage
	}, params *GetReceiptQrCodeImageApiV1ReceiptsReceiptIdQrcodeGetParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SendReceiptViaSmsApiV1ReceiptsReceiptIdSmsPost request with any body
	SendReceiptViaSmsApiV1ReceiptsReceiptIdSmsPostWithBody(ctx context.Context, receiptId struct {
		union json.RawMessage
	}, params *SendReceiptViaSmsApiV1ReceiptsReceiptIdSmsPostParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	SendReceiptViaSmsApiV1ReceiptsReceiptIdSmsPost(ctx context.Context, receiptId struct {
		union json.RawMessage
	}, params *SendReceiptViaSmsApiV1ReceiptsReceiptIdSmsPostParams, body SendReceiptViaSmsApiV1ReceiptsReceiptIdSmsPostJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetReceiptTextApiV1ReceiptsReceiptIdTextGet request
	GetReceiptTextApiV1ReceiptsReceiptIdTextGet(ctx context.Context, receiptId struct {
		union json.RawMessage
	}, params *GetReceiptTextApiV1ReceiptsReceiptIdTextGetParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetReceiptXmlApiV1ReceiptsReceiptIdXmlGet request
	GetReceiptXmlApiV1ReceiptsReceiptIdXmlGet(ctx context.Context, receiptId struct {
		union json.RawMessage
	}, params *GetReceiptXmlApiV1ReceiptsReceiptIdXmlGetParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetReportsApiV1ReportsGet request
	GetReportsApiV1ReportsGet(ctx context.Context, params *GetReportsApiV1ReportsGetParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateXReportApiV1ReportsPost request
	CreateXReportApiV1ReportsPost(ctx context.Context, params *CreateXReportApiV1ReportsPostParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AddExternalReportApiV1ReportsAddExternalPost request with any body
	AddExternalReportApiV1ReportsAddExternalPostWithBody(ctx context.Context, params *AddExternalReportApiV1ReportsAddExternalPostParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	AddExternalReportApiV1ReportsAddExternalPost(ctx context.Context, params *AddExternalReportApiV1ReportsAddExternalPostParams, body AddExternalReportApiV1ReportsAddExternalPostJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetPeriodicalReportApiV1ReportsPeriodicalGet request
	GetPeriodicalReportApiV1ReportsPeriodicalGet(ctx context.Context, params *GetPeriodicalReportApiV1ReportsPeriodicalGetParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetSearchReportsApiV1ReportsSearchGet request
	GetSearchReportsApiV1ReportsSearchGet(ctx context.Context, params *GetSearchReportsApiV1ReportsSearchGetParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetReportApiV1ReportsReportIdGet request
	GetReportApiV1ReportsReportIdGet(ctx context.Context, reportId openapi_types.UUID, params *GetReportApiV1ReportsReportIdGetParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetReportTextApiV1ReportsReportIdTextGet request
	GetReportTextApiV1ReportsReportIdTextGet(ctx context.Context, reportId openapi_types.UUID, params *GetReportTextApiV1ReportsReportIdTextGetParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetShiftsApiV1ShiftsGet request
	GetShiftsApiV1ShiftsGet(ctx context.Context, params *GetShiftsApiV1ShiftsGetParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateShiftApiV1ShiftsPost request with any body
	CreateShiftApiV1ShiftsPostWithBody(ctx context.Context, params *CreateShiftApiV1ShiftsPostParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateShiftApiV1ShiftsPost(ctx context.Context, params *CreateShiftApiV1ShiftsPostParams, body CreateShiftApiV1ShiftsPostJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CloseShiftApiV1ShiftsClosePost request with any body
	CloseShiftApiV1ShiftsClosePostWithBody(ctx context.Context, params *CloseShiftApiV1ShiftsClosePostParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CloseShiftApiV1ShiftsClosePost(ctx context.Context, params *CloseShiftApiV1ShiftsClosePostParams, body CloseShiftApiV1ShiftsClosePostJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetShiftApiV1ShiftsShiftIdGet request
	GetShiftApiV1ShiftsShiftIdGet(ctx context.Context, shiftId openapi_types.UUID, params *GetShiftApiV1ShiftsShiftIdGetParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CloseShiftBySeniorCashierApiV1ShiftsShiftIdClosePost request with any body
	CloseShiftBySeniorCashierApiV1ShiftsShiftIdClosePostWithBody(ctx context.Context, shiftId openapi_types.UUID, params *CloseShiftBySeniorCashierApiV1ShiftsShiftIdClosePostParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CloseShiftBySeniorCashierApiV1ShiftsShiftIdClosePost(ctx context.Context, shiftId openapi_types.UUID, params *CloseShiftBySeniorCashierApiV1ShiftsShiftIdClosePostParams, body CloseShiftBySeniorCashierApiV1ShiftsShiftIdClosePostJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetAllTaxesApiV1TaxGet request
	GetAllTaxesApiV1TaxGet(ctx context.Context, params *GetAllTaxesApiV1TaxGetParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetTransactionsApiV1TransactionsGet request
	GetTransactionsApiV1TransactionsGet(ctx context.Context, params *GetTransactionsApiV1TransactionsGetParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetTransactionApiV1TransactionsTransactionIdGet request
	GetTransactionApiV1TransactionsTransactionIdGet(ctx context.Context, transactionId openapi_types.UUID, params *GetTransactionApiV1TransactionsTransactionIdGetParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateTransactionApiV1TransactionsTransactionIdPatch request with any body
	UpdateTransactionApiV1TransactionsTransactionIdPatchWithBody(ctx context.Context, transactionId openapi_types.UUID, params *UpdateTransactionApiV1TransactionsTransactionIdPatchParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateTransactionApiV1TransactionsTransactionIdPatch(ctx context.Context, transactionId openapi_types.UUID, params *UpdateTransactionApiV1TransactionsTransactionIdPatchParams, body UpdateTransactionApiV1TransactionsTransactionIdPatchJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteWebhookApiV1WebhookDelete request
	DeleteWebhookApiV1WebhookDelete(ctx context.Context, params *DeleteWebhookApiV1WebhookDeleteParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetWebhookInfoApiV1WebhookGet request
	GetWebhookInfoApiV1WebhookGet(ctx context.Context, params *GetWebhookInfoApiV1WebhookGetParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SetWebhookApiV1WebhookPost request with any body
	SetWebhookApiV1WebhookPostWithBody(ctx context.Context, params *SetWebhookApiV1WebhookPostParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	SetWebhookApiV1WebhookPost(ctx context.Context, params *SetWebhookApiV1WebhookPostParams, body SetWebhookApiV1WebhookPostJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)
}

func (c *Client) GetCashRegistersApiV1CashRegistersGet(ctx context.Context, params *GetCashRegistersApiV1CashRegistersGetParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetCashRegistersApiV1CashRegistersGetRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AskOfflineCodesApiV1CashRegistersAskOfflineCodesGet(ctx context.Context, params *AskOfflineCodesApiV1CashRegistersAskOfflineCodesGetParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAskOfflineCodesApiV1CashRegistersAskOfflineCodesGetRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetOfflineCodesApiV1CashRegistersGetOfflineCodesGet(ctx context.Context, params *GetOfflineCodesApiV1CashRegistersGetOfflineCodesGetParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetOfflineCodesApiV1CashRegistersGetOfflineCodesGetRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetOfflineCodesCountApiV1CashRegistersGetOfflineCodesCountGet(ctx context.Context, params *GetOfflineCodesCountApiV1CashRegistersGetOfflineCodesCountGetParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetOfflineCodesCountApiV1CashRegistersGetOfflineCodesCountGetRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetOfflineTimeApiV1CashRegistersGetOfflineTimeGet(ctx context.Context, params *GetOfflineTimeApiV1CashRegistersGetOfflineTimeGetParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetOfflineTimeApiV1CashRegistersGetOfflineTimeGetRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GoOfflineActionApiV1CashRegistersGoOfflinePostWithBody(ctx context.Context, params *GoOfflineActionApiV1CashRegistersGoOfflinePostParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGoOfflineActionApiV1CashRegistersGoOfflinePostRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GoOfflineActionApiV1CashRegistersGoOfflinePost(ctx context.Context, params *GoOfflineActionApiV1CashRegistersGoOfflinePostParams, body GoOfflineActionApiV1CashRegistersGoOfflinePostJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGoOfflineActionApiV1CashRegistersGoOfflinePostRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GoOnlineActionApiV1CashRegistersGoOnlinePost(ctx context.Context, params *GoOnlineActionApiV1CashRegistersGoOnlinePostParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGoOnlineActionApiV1CashRegistersGoOnlinePostRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetCashRegisterInfoApiV1CashRegistersInfoGet(ctx context.Context, params *GetCashRegisterInfoApiV1CashRegistersInfoGetParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetCashRegisterInfoApiV1CashRegistersInfoGetRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PingTaxServiceActionApiV1CashRegistersPingTaxServicePost(ctx context.Context, params *PingTaxServiceActionApiV1CashRegistersPingTaxServicePostParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPingTaxServiceActionApiV1CashRegistersPingTaxServicePostRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetCashRegisterApiV1CashRegistersCashRegisterIdGet(ctx context.Context, cashRegisterId openapi_types.UUID, params *GetCashRegisterApiV1CashRegistersCashRegisterIdGetParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetCashRegisterApiV1CashRegistersCashRegisterIdGetRequest(c.Server, cashRegisterId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CheckSignatureApiV1CashierCheckSignatureGet(ctx context.Context, params *CheckSignatureApiV1CashierCheckSignatureGetParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCheckSignatureApiV1CashierCheckSignatureGetRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetCashierProfileApiV1CashierMeGet(ctx context.Context, params *GetCashierProfileApiV1CashierMeGetParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetCashierProfileApiV1CashierMeGetRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetCashierShiftApiV1CashierShiftGet(ctx context.Context, params *GetCashierShiftApiV1CashierShiftGetParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetCashierShiftApiV1CashierShiftGetRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SignInCashierApiV1CashierSigninPostWithBody(ctx context.Context, params *SignInCashierApiV1CashierSigninPostParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSignInCashierApiV1CashierSigninPostRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SignInCashierApiV1CashierSigninPost(ctx context.Context, params *SignInCashierApiV1CashierSigninPostParams, body SignInCashierApiV1CashierSigninPostJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSignInCashierApiV1CashierSigninPostRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SignInCashierViaPinCodeApiV1CashierSigninPinCodePostWithBody(ctx context.Context, params *SignInCashierViaPinCodeApiV1CashierSigninPinCodePostParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSignInCashierViaPinCodeApiV1CashierSigninPinCodePostRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SignInCashierViaPinCodeApiV1CashierSigninPinCodePost(ctx context.Context, params *SignInCashierViaPinCodeApiV1CashierSigninPinCodePostParams, body SignInCashierViaPinCodeApiV1CashierSigninPinCodePostJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSignInCashierViaPinCodeApiV1CashierSigninPinCodePostRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SignOutCashierApiV1CashierSignoutPost(ctx context.Context, params *SignOutCashierApiV1CashierSignoutPostParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSignOutCashierApiV1CashierSignoutPostRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetCurrencyRatesApiV1CurrencyRateGet(ctx context.Context, params *GetCurrencyRatesApiV1CurrencyRateGetParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetCurrencyRatesApiV1CurrencyRateGetRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SetupCurrencyRatesApiV1CurrencyRateSetupPostWithBody(ctx context.Context, params *SetupCurrencyRatesApiV1CurrencyRateSetupPostParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSetupCurrencyRatesApiV1CurrencyRateSetupPostRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SetupCurrencyRatesApiV1CurrencyRateSetupPost(ctx context.Context, params *SetupCurrencyRatesApiV1CurrencyRateSetupPostParams, body SetupCurrencyRatesApiV1CurrencyRateSetupPostJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSetupCurrencyRatesApiV1CurrencyRateSetupPostRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetCurrencyRateApiV1CurrencyRateCurrencyCodeGet(ctx context.Context, currencyCode string, params *GetCurrencyRateApiV1CurrencyRateCurrencyCodeGetParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetCurrencyRateApiV1CurrencyRateCurrencyCodeGetRequest(c.Server, currencyCode, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GoodsReportApiV1ExtendedReportsGoodsPostWithBody(ctx context.Context, params *GoodsReportApiV1ExtendedReportsGoodsPostParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGoodsReportApiV1ExtendedReportsGoodsPostRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GoodsReportApiV1ExtendedReportsGoodsPost(ctx context.Context, params *GoodsReportApiV1ExtendedReportsGoodsPostParams, body GoodsReportApiV1ExtendedReportsGoodsPostJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGoodsReportApiV1ExtendedReportsGoodsPostRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetReportTaskByIdApiV1ExtendedReportsReportTaskIdGet(ctx context.Context, reportTaskId openapi_types.UUID, params *GetReportTaskByIdApiV1ExtendedReportsReportTaskIdGetParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetReportTaskByIdApiV1ExtendedReportsReportTaskIdGetRequest(c.Server, reportTaskId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetReportXlsxByIdApiV1ExtendedReportsReportTaskIdReportXlsxGet(ctx context.Context, reportTaskId openapi_types.UUID, params *GetReportXlsxByIdApiV1ExtendedReportsReportTaskIdReportXlsxGetParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetReportXlsxByIdApiV1ExtendedReportsReportTaskIdReportXlsxGetRequest(c.Server, reportTaskId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetGoodsApiV1GoodsGet(ctx context.Context, params *GetGoodsApiV1GoodsGetParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetGoodsApiV1GoodsGetRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ExportGoodsFileApiV1GoodsExportFileTaskIdGet(ctx context.Context, taskId openapi_types.UUID, params *ExportGoodsFileApiV1GoodsExportFileTaskIdGetParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewExportGoodsFileApiV1GoodsExportFileTaskIdGetRequest(c.Server, taskId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ExportGoodsTaskStatusApiV1GoodsExportTaskStatusTaskIdGet(ctx context.Context, taskId openapi_types.UUID, params *ExportGoodsTaskStatusApiV1GoodsExportTaskStatusTaskIdGetParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewExportGoodsTaskStatusApiV1GoodsExportTaskStatusTaskIdGetRequest(c.Server, taskId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ExportGoodsApiV1GoodsExportExportExtensionGet(ctx context.Context, exportExtension ExportExtensionType, params *ExportGoodsApiV1GoodsExportExportExtensionGetParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewExportGoodsApiV1GoodsExportExportExtensionGetRequest(c.Server, exportExtension, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ImportGoodsApplyChangesApiV1GoodsImportApplyChangesTaskIdPost(ctx context.Context, taskId openapi_types.UUID, params *ImportGoodsApplyChangesApiV1GoodsImportApplyChangesTaskIdPostParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewImportGoodsApplyChangesApiV1GoodsImportApplyChangesTaskIdPostRequest(c.Server, taskId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ImportGoodsTaskStatusApiV1GoodsImportTaskStatusTaskIdGet(ctx context.Context, taskId openapi_types.UUID, params *ImportGoodsTaskStatusApiV1GoodsImportTaskStatusTaskIdGetParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewImportGoodsTaskStatusApiV1GoodsImportTaskStatusTaskIdGetRequest(c.Server, taskId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ImportGoodsFromFileApiV1GoodsImportUploadPostWithBody(ctx context.Context, params *ImportGoodsFromFileApiV1GoodsImportUploadPostParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewImportGoodsFromFileApiV1GoodsImportUploadPostRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetGoodApiV1GoodsGoodIdGet(ctx context.Context, goodId openapi_types.UUID, params *GetGoodApiV1GoodsGoodIdGetParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetGoodApiV1GoodsGoodIdGetRequest(c.Server, goodId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetOrdersApiV1OrdersGet(ctx context.Context, params *GetOrdersApiV1OrdersGetParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetOrdersApiV1OrdersGetRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AddOrdersApiV1OrdersPostWithBody(ctx context.Context, params *AddOrdersApiV1OrdersPostParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAddOrdersApiV1OrdersPostRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AddOrdersApiV1OrdersPost(ctx context.Context, params *AddOrdersApiV1OrdersPostParams, body AddOrdersApiV1OrdersPostJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAddOrdersApiV1OrdersPostRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CloseNotFiscalizeOrderApiV1OrdersClosePatch(ctx context.Context, params *CloseNotFiscalizeOrderApiV1OrdersClosePatchParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCloseNotFiscalizeOrderApiV1OrdersClosePatchRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateCustomOrderStatusApiV1OrdersCustomStatusOrderIdPatch(ctx context.Context, orderId openapi_types.UUID, params *UpdateCustomOrderStatusApiV1OrdersCustomStatusOrderIdPatchParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateCustomOrderStatusApiV1OrdersCustomStatusOrderIdPatchRequest(c.Server, orderId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteIntegrationApiV1OrdersIntegrationDelete(ctx context.Context, params *DeleteIntegrationApiV1OrdersIntegrationDeleteParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteIntegrationApiV1OrdersIntegrationDeleteRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetIntegrationApiV1OrdersIntegrationGet(ctx context.Context, params *GetIntegrationApiV1OrdersIntegrationGetParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetIntegrationApiV1OrdersIntegrationGetRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SetIntegrationApiV1OrdersIntegrationPostWithBody(ctx context.Context, params *SetIntegrationApiV1OrdersIntegrationPostParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSetIntegrationApiV1OrdersIntegrationPostRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SetIntegrationApiV1OrdersIntegrationPost(ctx context.Context, params *SetIntegrationApiV1OrdersIntegrationPostParams, body SetIntegrationApiV1OrdersIntegrationPostJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSetIntegrationApiV1OrdersIntegrationPostRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) EditOrderApiV1OrdersIntegrationEditOrderPostWithBody(ctx context.Context, params *EditOrderApiV1OrdersIntegrationEditOrderPostParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewEditOrderApiV1OrdersIntegrationEditOrderPostRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) EditOrderApiV1OrdersIntegrationEditOrderPost(ctx context.Context, params *EditOrderApiV1OrdersIntegrationEditOrderPostParams, body EditOrderApiV1OrdersIntegrationEditOrderPostJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewEditOrderApiV1OrdersIntegrationEditOrderPostRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RunOrdersSynchronizationApiV1OrdersSyncPost(ctx context.Context, params *RunOrdersSynchronizationApiV1OrdersSyncPostParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRunOrdersSynchronizationApiV1OrdersSyncPostRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetOrderApiV1OrdersOrderIdGet(ctx context.Context, orderId openapi_types.UUID, params *GetOrderApiV1OrdersOrderIdGetParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetOrderApiV1OrdersOrderIdGetRequest(c.Server, orderId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CancelOrderApiV1OrdersOrderIdPatch(ctx context.Context, orderId openapi_types.UUID, params *CancelOrderApiV1OrdersOrderIdPatchParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCancelOrderApiV1OrdersOrderIdPatchRequest(c.Server, orderId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetCurrentOrganizationLogoApiV1OrganizationLogoPngGet(ctx context.Context, params *GetCurrentOrganizationLogoApiV1OrganizationLogoPngGetParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetCurrentOrganizationLogoApiV1OrganizationLogoPngGetRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetCurrentOrganizationReceiptSettingsApiV1OrganizationReceiptConfigGet(ctx context.Context, params *GetCurrentOrganizationReceiptSettingsApiV1OrganizationReceiptConfigGetParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetCurrentOrganizationReceiptSettingsApiV1OrganizationReceiptConfigGetRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetCurrentOrganizationSmsBillingBalanceApiV1OrganizationSmsBillingGet(ctx context.Context, params *GetCurrentOrganizationSmsBillingBalanceApiV1OrganizationSmsBillingGetParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetCurrentOrganizationSmsBillingBalanceApiV1OrganizationSmsBillingGetRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetCurrentOrganizationTextLogoApiV1OrganizationTextLogoPngGet(ctx context.Context, params *GetCurrentOrganizationTextLogoApiV1OrganizationTextLogoPngGetParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetCurrentOrganizationTextLogoApiV1OrganizationTextLogoPngGetRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetReceiptsApiV1ReceiptsGet(ctx context.Context, params *GetReceiptsApiV1ReceiptsGetParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetReceiptsApiV1ReceiptsGetRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AddExternalReceiptApiV1ReceiptsAddExternalPostWithBody(ctx context.Context, params *AddExternalReceiptApiV1ReceiptsAddExternalPostParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAddExternalReceiptApiV1ReceiptsAddExternalPostRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AddExternalReceiptApiV1ReceiptsAddExternalPost(ctx context.Context, params *AddExternalReceiptApiV1ReceiptsAddExternalPostParams, body AddExternalReceiptApiV1ReceiptsAddExternalPostJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAddExternalReceiptApiV1ReceiptsAddExternalPostRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CashWithdrawalApiV1ReceiptsCashWithdrawalPostWithBody(ctx context.Context, params *CashWithdrawalApiV1ReceiptsCashWithdrawalPostParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCashWithdrawalApiV1ReceiptsCashWithdrawalPostRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CashWithdrawalApiV1ReceiptsCashWithdrawalPost(ctx context.Context, params *CashWithdrawalApiV1ReceiptsCashWithdrawalPostParams, body CashWithdrawalApiV1ReceiptsCashWithdrawalPostJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCashWithdrawalApiV1ReceiptsCashWithdrawalPostRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ExchangeApiV1ReceiptsCurrencyExchangePostWithBody(ctx context.Context, params *ExchangeApiV1ReceiptsCurrencyExchangePostParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewExchangeApiV1ReceiptsCurrencyExchangePostRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ExchangeApiV1ReceiptsCurrencyExchangePost(ctx context.Context, params *ExchangeApiV1ReceiptsCurrencyExchangePostParams, body ExchangeApiV1ReceiptsCurrencyExchangePostJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewExchangeApiV1ReceiptsCurrencyExchangePostRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetReceiptsSearchApiV1ReceiptsSearchGet(ctx context.Context, params *GetReceiptsSearchApiV1ReceiptsSearchGetParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetReceiptsSearchApiV1ReceiptsSearchGetRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateReceiptApiV1ReceiptsSellPostWithBody(ctx context.Context, params *CreateReceiptApiV1ReceiptsSellPostParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateReceiptApiV1ReceiptsSellPostRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateReceiptApiV1ReceiptsSellPost(ctx context.Context, params *CreateReceiptApiV1ReceiptsSellPostParams, body CreateReceiptApiV1ReceiptsSellPostJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateReceiptApiV1ReceiptsSellPostRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateOfflineReceiptApiV1ReceiptsSellOfflinePostWithBody(ctx context.Context, params *CreateOfflineReceiptApiV1ReceiptsSellOfflinePostParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateOfflineReceiptApiV1ReceiptsSellOfflinePostRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateOfflineReceiptApiV1ReceiptsSellOfflinePost(ctx context.Context, params *CreateOfflineReceiptApiV1ReceiptsSellOfflinePostParams, body CreateOfflineReceiptApiV1ReceiptsSellOfflinePostJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateOfflineReceiptApiV1ReceiptsSellOfflinePostRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateServiceReceiptApiV1ReceiptsServicePostWithBody(ctx context.Context, params *CreateServiceReceiptApiV1ReceiptsServicePostParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateServiceReceiptApiV1ReceiptsServicePostRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateServiceReceiptApiV1ReceiptsServicePost(ctx context.Context, params *CreateServiceReceiptApiV1ReceiptsServicePostParams, body CreateServiceReceiptApiV1ReceiptsServicePostJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateServiceReceiptApiV1ReceiptsServicePostRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateServiceCurrencyReceiptApiV1ReceiptsServiceCurrencyPostWithBody(ctx context.Context, params *CreateServiceCurrencyReceiptApiV1ReceiptsServiceCurrencyPostParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateServiceCurrencyReceiptApiV1ReceiptsServiceCurrencyPostRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateServiceCurrencyReceiptApiV1ReceiptsServiceCurrencyPost(ctx context.Context, params *CreateServiceCurrencyReceiptApiV1ReceiptsServiceCurrencyPostParams, body CreateServiceCurrencyReceiptApiV1ReceiptsServiceCurrencyPostJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateServiceCurrencyReceiptApiV1ReceiptsServiceCurrencyPostRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetReceiptApiV1ReceiptsReceiptIdGet(ctx context.Context, receiptId struct {
	union json.RawMessage
}, params *GetReceiptApiV1ReceiptsReceiptIdGetParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetReceiptApiV1ReceiptsReceiptIdGetRequest(c.Server, receiptId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SendReceiptToEmailApiV1ReceiptsReceiptIdEmailPostWithBody(ctx context.Context, receiptId struct {
	union json.RawMessage
}, params *SendReceiptToEmailApiV1ReceiptsReceiptIdEmailPostParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSendReceiptToEmailApiV1ReceiptsReceiptIdEmailPostRequestWithBody(c.Server, receiptId, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SendReceiptToEmailApiV1ReceiptsReceiptIdEmailPost(ctx context.Context, receiptId struct {
	union json.RawMessage
}, params *SendReceiptToEmailApiV1ReceiptsReceiptIdEmailPostParams, body SendReceiptToEmailApiV1ReceiptsReceiptIdEmailPostJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSendReceiptToEmailApiV1ReceiptsReceiptIdEmailPostRequest(c.Server, receiptId, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetReceiptHtmlApiV1ReceiptsReceiptIdHtmlGet(ctx context.Context, receiptId struct {
	union json.RawMessage
}, params *GetReceiptHtmlApiV1ReceiptsReceiptIdHtmlGetParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetReceiptHtmlApiV1ReceiptsReceiptIdHtmlGetRequest(c.Server, receiptId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetReceiptPdfApiV1ReceiptsReceiptIdPdfGet(ctx context.Context, receiptId struct {
	union json.RawMessage
}, params *GetReceiptPdfApiV1ReceiptsReceiptIdPdfGetParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetReceiptPdfApiV1ReceiptsReceiptIdPdfGetRequest(c.Server, receiptId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetReceiptPngApiV1ReceiptsReceiptIdPngGet(ctx context.Context, receiptId struct {
	union json.RawMessage
}, params *GetReceiptPngApiV1ReceiptsReceiptIdPngGetParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetReceiptPngApiV1ReceiptsReceiptIdPngGetRequest(c.Server, receiptId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetReceiptQrCodeImageApiV1ReceiptsReceiptIdQrcodeGet(ctx context.Context, receiptId struct {
	union json.RawMessage
}, params *GetReceiptQrCodeImageApiV1ReceiptsReceiptIdQrcodeGetParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetReceiptQrCodeImageApiV1ReceiptsReceiptIdQrcodeGetRequest(c.Server, receiptId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SendReceiptViaSmsApiV1ReceiptsReceiptIdSmsPostWithBody(ctx context.Context, receiptId struct {
	union json.RawMessage
}, params *SendReceiptViaSmsApiV1ReceiptsReceiptIdSmsPostParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSendReceiptViaSmsApiV1ReceiptsReceiptIdSmsPostRequestWithBody(c.Server, receiptId, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SendReceiptViaSmsApiV1ReceiptsReceiptIdSmsPost(ctx context.Context, receiptId struct {
	union json.RawMessage
}, params *SendReceiptViaSmsApiV1ReceiptsReceiptIdSmsPostParams, body SendReceiptViaSmsApiV1ReceiptsReceiptIdSmsPostJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSendReceiptViaSmsApiV1ReceiptsReceiptIdSmsPostRequest(c.Server, receiptId, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetReceiptTextApiV1ReceiptsReceiptIdTextGet(ctx context.Context, receiptId struct {
	union json.RawMessage
}, params *GetReceiptTextApiV1ReceiptsReceiptIdTextGetParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetReceiptTextApiV1ReceiptsReceiptIdTextGetRequest(c.Server, receiptId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetReceiptXmlApiV1ReceiptsReceiptIdXmlGet(ctx context.Context, receiptId struct {
	union json.RawMessage
}, params *GetReceiptXmlApiV1ReceiptsReceiptIdXmlGetParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetReceiptXmlApiV1ReceiptsReceiptIdXmlGetRequest(c.Server, receiptId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetReportsApiV1ReportsGet(ctx context.Context, params *GetReportsApiV1ReportsGetParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetReportsApiV1ReportsGetRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateXReportApiV1ReportsPost(ctx context.Context, params *CreateXReportApiV1ReportsPostParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateXReportApiV1ReportsPostRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AddExternalReportApiV1ReportsAddExternalPostWithBody(ctx context.Context, params *AddExternalReportApiV1ReportsAddExternalPostParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAddExternalReportApiV1ReportsAddExternalPostRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AddExternalReportApiV1ReportsAddExternalPost(ctx context.Context, params *AddExternalReportApiV1ReportsAddExternalPostParams, body AddExternalReportApiV1ReportsAddExternalPostJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAddExternalReportApiV1ReportsAddExternalPostRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetPeriodicalReportApiV1ReportsPeriodicalGet(ctx context.Context, params *GetPeriodicalReportApiV1ReportsPeriodicalGetParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetPeriodicalReportApiV1ReportsPeriodicalGetRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetSearchReportsApiV1ReportsSearchGet(ctx context.Context, params *GetSearchReportsApiV1ReportsSearchGetParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetSearchReportsApiV1ReportsSearchGetRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetReportApiV1ReportsReportIdGet(ctx context.Context, reportId openapi_types.UUID, params *GetReportApiV1ReportsReportIdGetParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetReportApiV1ReportsReportIdGetRequest(c.Server, reportId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetReportTextApiV1ReportsReportIdTextGet(ctx context.Context, reportId openapi_types.UUID, params *GetReportTextApiV1ReportsReportIdTextGetParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetReportTextApiV1ReportsReportIdTextGetRequest(c.Server, reportId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetShiftsApiV1ShiftsGet(ctx context.Context, params *GetShiftsApiV1ShiftsGetParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetShiftsApiV1ShiftsGetRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateShiftApiV1ShiftsPostWithBody(ctx context.Context, params *CreateShiftApiV1ShiftsPostParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateShiftApiV1ShiftsPostRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateShiftApiV1ShiftsPost(ctx context.Context, params *CreateShiftApiV1ShiftsPostParams, body CreateShiftApiV1ShiftsPostJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateShiftApiV1ShiftsPostRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CloseShiftApiV1ShiftsClosePostWithBody(ctx context.Context, params *CloseShiftApiV1ShiftsClosePostParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCloseShiftApiV1ShiftsClosePostRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CloseShiftApiV1ShiftsClosePost(ctx context.Context, params *CloseShiftApiV1ShiftsClosePostParams, body CloseShiftApiV1ShiftsClosePostJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCloseShiftApiV1ShiftsClosePostRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetShiftApiV1ShiftsShiftIdGet(ctx context.Context, shiftId openapi_types.UUID, params *GetShiftApiV1ShiftsShiftIdGetParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetShiftApiV1ShiftsShiftIdGetRequest(c.Server, shiftId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CloseShiftBySeniorCashierApiV1ShiftsShiftIdClosePostWithBody(ctx context.Context, shiftId openapi_types.UUID, params *CloseShiftBySeniorCashierApiV1ShiftsShiftIdClosePostParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCloseShiftBySeniorCashierApiV1ShiftsShiftIdClosePostRequestWithBody(c.Server, shiftId, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CloseShiftBySeniorCashierApiV1ShiftsShiftIdClosePost(ctx context.Context, shiftId openapi_types.UUID, params *CloseShiftBySeniorCashierApiV1ShiftsShiftIdClosePostParams, body CloseShiftBySeniorCashierApiV1ShiftsShiftIdClosePostJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCloseShiftBySeniorCashierApiV1ShiftsShiftIdClosePostRequest(c.Server, shiftId, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetAllTaxesApiV1TaxGet(ctx context.Context, params *GetAllTaxesApiV1TaxGetParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAllTaxesApiV1TaxGetRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetTransactionsApiV1TransactionsGet(ctx context.Context, params *GetTransactionsApiV1TransactionsGetParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetTransactionsApiV1TransactionsGetRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetTransactionApiV1TransactionsTransactionIdGet(ctx context.Context, transactionId openapi_types.UUID, params *GetTransactionApiV1TransactionsTransactionIdGetParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetTransactionApiV1TransactionsTransactionIdGetRequest(c.Server, transactionId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateTransactionApiV1TransactionsTransactionIdPatchWithBody(ctx context.Context, transactionId openapi_types.UUID, params *UpdateTransactionApiV1TransactionsTransactionIdPatchParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateTransactionApiV1TransactionsTransactionIdPatchRequestWithBody(c.Server, transactionId, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateTransactionApiV1TransactionsTransactionIdPatch(ctx context.Context, transactionId openapi_types.UUID, params *UpdateTransactionApiV1TransactionsTransactionIdPatchParams, body UpdateTransactionApiV1TransactionsTransactionIdPatchJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateTransactionApiV1TransactionsTransactionIdPatchRequest(c.Server, transactionId, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteWebhookApiV1WebhookDelete(ctx context.Context, params *DeleteWebhookApiV1WebhookDeleteParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteWebhookApiV1WebhookDeleteRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetWebhookInfoApiV1WebhookGet(ctx context.Context, params *GetWebhookInfoApiV1WebhookGetParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetWebhookInfoApiV1WebhookGetRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SetWebhookApiV1WebhookPostWithBody(ctx context.Context, params *SetWebhookApiV1WebhookPostParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSetWebhookApiV1WebhookPostRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SetWebhookApiV1WebhookPost(ctx context.Context, params *SetWebhookApiV1WebhookPostParams, body SetWebhookApiV1WebhookPostJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSetWebhookApiV1WebhookPostRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

// NewGetCashRegistersApiV1CashRegistersGetRequest generates requests for GetCashRegistersApiV1CashRegistersGet
func NewGetCashRegistersApiV1CashRegistersGetRequest(server string, params *GetCashRegistersApiV1CashRegistersGetParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/cash-registers")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.InUse != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "in_use", runtime.ParamLocationQuery, *params.InUse); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Limit != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Offset != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params.XClientName != nil {
		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Client-Name", runtime.ParamLocationHeader, *params.XClientName)
		if err != nil {
			return nil, err
		}

		req.Header.Set("X-Client-Name", headerParam0)
	}

	if params.XClientVersion != nil {
		var headerParam1 string

		headerParam1, err = runtime.StyleParamWithLocation("simple", false, "X-Client-Version", runtime.ParamLocationHeader, *params.XClientVersion)
		if err != nil {
			return nil, err
		}

		req.Header.Set("X-Client-Version", headerParam1)
	}

	if params.XAccessKey != nil {
		var headerParam2 string

		headerParam2, err = runtime.StyleParamWithLocation("simple", false, "X-Access-Key", runtime.ParamLocationHeader, *params.XAccessKey)
		if err != nil {
			return nil, err
		}

		req.Header.Set("X-Access-Key", headerParam2)
	}

	return req, nil
}

// NewAskOfflineCodesApiV1CashRegistersAskOfflineCodesGetRequest generates requests for AskOfflineCodesApiV1CashRegistersAskOfflineCodesGet
func NewAskOfflineCodesApiV1CashRegistersAskOfflineCodesGetRequest(server string, params *AskOfflineCodesApiV1CashRegistersAskOfflineCodesGetParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/cash-registers/ask-offline-codes")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Count != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "count", runtime.ParamLocationQuery, *params.Count); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Sync != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sync", runtime.ParamLocationQuery, *params.Sync); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params.XClientName != nil {
		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Client-Name", runtime.ParamLocationHeader, *params.XClientName)
		if err != nil {
			return nil, err
		}

		req.Header.Set("X-Client-Name", headerParam0)
	}

	if params.XClientVersion != nil {
		var headerParam1 string

		headerParam1, err = runtime.StyleParamWithLocation("simple", false, "X-Client-Version", runtime.ParamLocationHeader, *params.XClientVersion)
		if err != nil {
			return nil, err
		}

		req.Header.Set("X-Client-Version", headerParam1)
	}

	if params.XAccessKey != nil {
		var headerParam2 string

		headerParam2, err = runtime.StyleParamWithLocation("simple", false, "X-Access-Key", runtime.ParamLocationHeader, *params.XAccessKey)
		if err != nil {
			return nil, err
		}

		req.Header.Set("X-Access-Key", headerParam2)
	}

	if params.XDeviceID != nil {
		var headerParam3 string

		headerParam3, err = runtime.StyleParamWithLocation("simple", false, "X-Device-ID", runtime.ParamLocationHeader, *params.XDeviceID)
		if err != nil {
			return nil, err
		}

		req.Header.Set("X-Device-ID", headerParam3)
	}

	var headerParam4 string

	headerParam4, err = runtime.StyleParamWithLocation("simple", false, "X-License-Key", runtime.ParamLocationHeader, params.XLicenseKey)
	if err != nil {
		return nil, err
	}

	req.Header.Set("X-License-Key", headerParam4)

	return req, nil
}

// NewGetOfflineCodesApiV1CashRegistersGetOfflineCodesGetRequest generates requests for GetOfflineCodesApiV1CashRegistersGetOfflineCodesGet
func NewGetOfflineCodesApiV1CashRegistersGetOfflineCodesGetRequest(server string, params *GetOfflineCodesApiV1CashRegistersGetOfflineCodesGetParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/cash-registers/get-offline-codes")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Count != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "count", runtime.ParamLocationQuery, *params.Count); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params.XClientName != nil {
		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Client-Name", runtime.ParamLocationHeader, *params.XClientName)
		if err != nil {
			return nil, err
		}

		req.Header.Set("X-Client-Name", headerParam0)
	}

	if params.XClientVersion != nil {
		var headerParam1 string

		headerParam1, err = runtime.StyleParamWithLocation("simple", false, "X-Client-Version", runtime.ParamLocationHeader, *params.XClientVersion)
		if err != nil {
			return nil, err
		}

		req.Header.Set("X-Client-Version", headerParam1)
	}

	if params.XAccessKey != nil {
		var headerParam2 string

		headerParam2, err = runtime.StyleParamWithLocation("simple", false, "X-Access-Key", runtime.ParamLocationHeader, *params.XAccessKey)
		if err != nil {
			return nil, err
		}

		req.Header.Set("X-Access-Key", headerParam2)
	}

	if params.XLicenseKey != nil {
		var headerParam3 string

		headerParam3, err = runtime.StyleParamWithLocation("simple", false, "X-License-Key", runtime.ParamLocationHeader, *params.XLicenseKey)
		if err != nil {
			return nil, err
		}

		req.Header.Set("X-License-Key", headerParam3)
	}

	return req, nil
}

// NewGetOfflineCodesCountApiV1CashRegistersGetOfflineCodesCountGetRequest generates requests for GetOfflineCodesCountApiV1CashRegistersGetOfflineCodesCountGet
func NewGetOfflineCodesCountApiV1CashRegistersGetOfflineCodesCountGetRequest(server string, params *GetOfflineCodesCountApiV1CashRegistersGetOfflineCodesCountGetParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/cash-registers/get-offline-codes-count")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params.XClientName != nil {
		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Client-Name", runtime.ParamLocationHeader, *params.XClientName)
		if err != nil {
			return nil, err
		}

		req.Header.Set("X-Client-Name", headerParam0)
	}

	if params.XClientVersion != nil {
		var headerParam1 string

		headerParam1, err = runtime.StyleParamWithLocation("simple", false, "X-Client-Version", runtime.ParamLocationHeader, *params.XClientVersion)
		if err != nil {
			return nil, err
		}

		req.Header.Set("X-Client-Version", headerParam1)
	}

	if params.XAccessKey != nil {
		var headerParam2 string

		headerParam2, err = runtime.StyleParamWithLocation("simple", false, "X-Access-Key", runtime.ParamLocationHeader, *params.XAccessKey)
		if err != nil {
			return nil, err
		}

		req.Header.Set("X-Access-Key", headerParam2)
	}

	var headerParam3 string

	headerParam3, err = runtime.StyleParamWithLocation("simple", false, "X-License-Key", runtime.ParamLocationHeader, params.XLicenseKey)
	if err != nil {
		return nil, err
	}

	req.Header.Set("X-License-Key", headerParam3)

	return req, nil
}

// NewGetOfflineTimeApiV1CashRegistersGetOfflineTimeGetRequest generates requests for GetOfflineTimeApiV1CashRegistersGetOfflineTimeGet
func NewGetOfflineTimeApiV1CashRegistersGetOfflineTimeGetRequest(server string, params *GetOfflineTimeApiV1CashRegistersGetOfflineTimeGetParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/cash-registers/get-offline-time")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.FromDate != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "from_date", runtime.ParamLocationQuery, *params.FromDate); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.ToDate != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "to_date", runtime.ParamLocationQuery, *params.ToDate); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params.XClientName != nil {
		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Client-Name", runtime.ParamLocationHeader, *params.XClientName)
		if err != nil {
			return nil, err
		}

		req.Header.Set("X-Client-Name", headerParam0)
	}

	if params.XClientVersion != nil {
		var headerParam1 string

		headerParam1, err = runtime.StyleParamWithLocation("simple", false, "X-Client-Version", runtime.ParamLocationHeader, *params.XClientVersion)
		if err != nil {
			return nil, err
		}

		req.Header.Set("X-Client-Version", headerParam1)
	}

	if params.XAccessKey != nil {
		var headerParam2 string

		headerParam2, err = runtime.StyleParamWithLocation("simple", false, "X-Access-Key", runtime.ParamLocationHeader, *params.XAccessKey)
		if err != nil {
			return nil, err
		}

		req.Header.Set("X-Access-Key", headerParam2)
	}

	var headerParam3 string

	headerParam3, err = runtime.StyleParamWithLocation("simple", false, "X-License-Key", runtime.ParamLocationHeader, params.XLicenseKey)
	if err != nil {
		return nil, err
	}

	req.Header.Set("X-License-Key", headerParam3)

	return req, nil
}

// NewGoOfflineActionApiV1CashRegistersGoOfflinePostRequest calls the generic GoOfflineActionApiV1CashRegistersGoOfflinePost builder with application/json body
func NewGoOfflineActionApiV1CashRegistersGoOfflinePostRequest(server string, params *GoOfflineActionApiV1CashRegistersGoOfflinePostParams, body GoOfflineActionApiV1CashRegistersGoOfflinePostJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewGoOfflineActionApiV1CashRegistersGoOfflinePostRequestWithBody(server, params, "application/json", bodyReader)
}

// NewGoOfflineActionApiV1CashRegistersGoOfflinePostRequestWithBody generates requests for GoOfflineActionApiV1CashRegistersGoOfflinePost with any type of body
func NewGoOfflineActionApiV1CashRegistersGoOfflinePostRequestWithBody(server string, params *GoOfflineActionApiV1CashRegistersGoOfflinePostParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/cash-registers/go-offline")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params.XClientName != nil {
		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Client-Name", runtime.ParamLocationHeader, *params.XClientName)
		if err != nil {
			return nil, err
		}

		req.Header.Set("X-Client-Name", headerParam0)
	}

	if params.XClientVersion != nil {
		var headerParam1 string

		headerParam1, err = runtime.StyleParamWithLocation("simple", false, "X-Client-Version", runtime.ParamLocationHeader, *params.XClientVersion)
		if err != nil {
			return nil, err
		}

		req.Header.Set("X-Client-Version", headerParam1)
	}

	if params.XAccessKey != nil {
		var headerParam2 string

		headerParam2, err = runtime.StyleParamWithLocation("simple", false, "X-Access-Key", runtime.ParamLocationHeader, *params.XAccessKey)
		if err != nil {
			return nil, err
		}

		req.Header.Set("X-Access-Key", headerParam2)
	}

	if params.XDeviceID != nil {
		var headerParam3 string

		headerParam3, err = runtime.StyleParamWithLocation("simple", false, "X-Device-ID", runtime.ParamLocationHeader, *params.XDeviceID)
		if err != nil {
			return nil, err
		}

		req.Header.Set("X-Device-ID", headerParam3)
	}

	if params.XLicenseKey != nil {
		var headerParam4 string

		headerParam4, err = runtime.StyleParamWithLocation("simple", false, "X-License-Key", runtime.ParamLocationHeader, *params.XLicenseKey)
		if err != nil {
			return nil, err
		}

		req.Header.Set("X-License-Key", headerParam4)
	}

	return req, nil
}

// NewGoOnlineActionApiV1CashRegistersGoOnlinePostRequest generates requests for GoOnlineActionApiV1CashRegistersGoOnlinePost
func NewGoOnlineActionApiV1CashRegistersGoOnlinePostRequest(server string, params *GoOnlineActionApiV1CashRegistersGoOnlinePostParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/cash-registers/go-online")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params.XClientName != nil {
		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Client-Name", runtime.ParamLocationHeader, *params.XClientName)
		if err != nil {
			return nil, err
		}

		req.Header.Set("X-Client-Name", headerParam0)
	}

	if params.XClientVersion != nil {
		var headerParam1 string

		headerParam1, err = runtime.StyleParamWithLocation("simple", false, "X-Client-Version", runtime.ParamLocationHeader, *params.XClientVersion)
		if err != nil {
			return nil, err
		}

		req.Header.Set("X-Client-Version", headerParam1)
	}

	if params.XAccessKey != nil {
		var headerParam2 string

		headerParam2, err = runtime.StyleParamWithLocation("simple", false, "X-Access-Key", runtime.ParamLocationHeader, *params.XAccessKey)
		if err != nil {
			return nil, err
		}

		req.Header.Set("X-Access-Key", headerParam2)
	}

	if params.XDeviceID != nil {
		var headerParam3 string

		headerParam3, err = runtime.StyleParamWithLocation("simple", false, "X-Device-ID", runtime.ParamLocationHeader, *params.XDeviceID)
		if err != nil {
			return nil, err
		}

		req.Header.Set("X-Device-ID", headerParam3)
	}

	if params.XLicenseKey != nil {
		var headerParam4 string

		headerParam4, err = runtime.StyleParamWithLocation("simple", false, "X-License-Key", runtime.ParamLocationHeader, *params.XLicenseKey)
		if err != nil {
			return nil, err
		}

		req.Header.Set("X-License-Key", headerParam4)
	}

	return req, nil
}

// NewGetCashRegisterInfoApiV1CashRegistersInfoGetRequest generates requests for GetCashRegisterInfoApiV1CashRegistersInfoGet
func NewGetCashRegisterInfoApiV1CashRegistersInfoGetRequest(server string, params *GetCashRegisterInfoApiV1CashRegistersInfoGetParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/cash-registers/info")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params.XClientName != nil {
		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Client-Name", runtime.ParamLocationHeader, *params.XClientName)
		if err != nil {
			return nil, err
		}

		req.Header.Set("X-Client-Name", headerParam0)
	}

	if params.XClientVersion != nil {
		var headerParam1 string

		headerParam1, err = runtime.StyleParamWithLocation("simple", false, "X-Client-Version", runtime.ParamLocationHeader, *params.XClientVersion)
		if err != nil {
			return nil, err
		}

		req.Header.Set("X-Client-Version", headerParam1)
	}

	if params.XAccessKey != nil {
		var headerParam2 string

		headerParam2, err = runtime.StyleParamWithLocation("simple", false, "X-Access-Key", runtime.ParamLocationHeader, *params.XAccessKey)
		if err != nil {
			return nil, err
		}

		req.Header.Set("X-Access-Key", headerParam2)
	}

	var headerParam3 string

	headerParam3, err = runtime.StyleParamWithLocation("simple", false, "X-License-Key", runtime.ParamLocationHeader, params.XLicenseKey)
	if err != nil {
		return nil, err
	}

	req.Header.Set("X-License-Key", headerParam3)

	return req, nil
}

// NewPingTaxServiceActionApiV1CashRegistersPingTaxServicePostRequest generates requests for PingTaxServiceActionApiV1CashRegistersPingTaxServicePost
func NewPingTaxServiceActionApiV1CashRegistersPingTaxServicePostRequest(server string, params *PingTaxServiceActionApiV1CashRegistersPingTaxServicePostParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/cash-registers/ping-tax-service")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params.XClientName != nil {
		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Client-Name", runtime.ParamLocationHeader, *params.XClientName)
		if err != nil {
			return nil, err
		}

		req.Header.Set("X-Client-Name", headerParam0)
	}

	if params.XClientVersion != nil {
		var headerParam1 string

		headerParam1, err = runtime.StyleParamWithLocation("simple", false, "X-Client-Version", runtime.ParamLocationHeader, *params.XClientVersion)
		if err != nil {
			return nil, err
		}

		req.Header.Set("X-Client-Version", headerParam1)
	}

	if params.XAccessKey != nil {
		var headerParam2 string

		headerParam2, err = runtime.StyleParamWithLocation("simple", false, "X-Access-Key", runtime.ParamLocationHeader, *params.XAccessKey)
		if err != nil {
			return nil, err
		}

		req.Header.Set("X-Access-Key", headerParam2)
	}

	var headerParam3 string

	headerParam3, err = runtime.StyleParamWithLocation("simple", false, "X-License-Key", runtime.ParamLocationHeader, params.XLicenseKey)
	if err != nil {
		return nil, err
	}

	req.Header.Set("X-License-Key", headerParam3)

	return req, nil
}

// NewGetCashRegisterApiV1CashRegistersCashRegisterIdGetRequest generates requests for GetCashRegisterApiV1CashRegistersCashRegisterIdGet
func NewGetCashRegisterApiV1CashRegistersCashRegisterIdGetRequest(server string, cashRegisterId openapi_types.UUID, params *GetCashRegisterApiV1CashRegistersCashRegisterIdGetParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "cash_register_id", runtime.ParamLocationPath, cashRegisterId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/cash-registers/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params.XClientName != nil {
		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Client-Name", runtime.ParamLocationHeader, *params.XClientName)
		if err != nil {
			return nil, err
		}

		req.Header.Set("X-Client-Name", headerParam0)
	}

	if params.XClientVersion != nil {
		var headerParam1 string

		headerParam1, err = runtime.StyleParamWithLocation("simple", false, "X-Client-Version", runtime.ParamLocationHeader, *params.XClientVersion)
		if err != nil {
			return nil, err
		}

		req.Header.Set("X-Client-Version", headerParam1)
	}

	if params.XAccessKey != nil {
		var headerParam2 string

		headerParam2, err = runtime.StyleParamWithLocation("simple", false, "X-Access-Key", runtime.ParamLocationHeader, *params.XAccessKey)
		if err != nil {
			return nil, err
		}

		req.Header.Set("X-Access-Key", headerParam2)
	}

	return req, nil
}

// NewCheckSignatureApiV1CashierCheckSignatureGetRequest generates requests for CheckSignatureApiV1CashierCheckSignatureGet
func NewCheckSignatureApiV1CashierCheckSignatureGetRequest(server string, params *CheckSignatureApiV1CashierCheckSignatureGetParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/cashier/check-signature")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params.XClientName != nil {
		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Client-Name", runtime.ParamLocationHeader, *params.XClientName)
		if err != nil {
			return nil, err
		}

		req.Header.Set("X-Client-Name", headerParam0)
	}

	if params.XClientVersion != nil {
		var headerParam1 string

		headerParam1, err = runtime.StyleParamWithLocation("simple", false, "X-Client-Version", runtime.ParamLocationHeader, *params.XClientVersion)
		if err != nil {
			return nil, err
		}

		req.Header.Set("X-Client-Version", headerParam1)
	}

	if params.XAccessKey != nil {
		var headerParam2 string

		headerParam2, err = runtime.StyleParamWithLocation("simple", false, "X-Access-Key", runtime.ParamLocationHeader, *params.XAccessKey)
		if err != nil {
			return nil, err
		}

		req.Header.Set("X-Access-Key", headerParam2)
	}

	return req, nil
}

// NewGetCashierProfileApiV1CashierMeGetRequest generates requests for GetCashierProfileApiV1CashierMeGet
func NewGetCashierProfileApiV1CashierMeGetRequest(server string, params *GetCashierProfileApiV1CashierMeGetParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/cashier/me")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params.XClientName != nil {
		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Client-Name", runtime.ParamLocationHeader, *params.XClientName)
		if err != nil {
			return nil, err
		}

		req.Header.Set("X-Client-Name", headerParam0)
	}

	if params.XClientVersion != nil {
		var headerParam1 string

		headerParam1, err = runtime.StyleParamWithLocation("simple", false, "X-Client-Version", runtime.ParamLocationHeader, *params.XClientVersion)
		if err != nil {
			return nil, err
		}

		req.Header.Set("X-Client-Version", headerParam1)
	}

	if params.XAccessKey != nil {
		var headerParam2 string

		headerParam2, err = runtime.StyleParamWithLocation("simple", false, "X-Access-Key", runtime.ParamLocationHeader, *params.XAccessKey)
		if err != nil {
			return nil, err
		}

		req.Header.Set("X-Access-Key", headerParam2)
	}

	if params.XDeviceID != nil {
		var headerParam3 string

		headerParam3, err = runtime.StyleParamWithLocation("simple", false, "X-Device-ID", runtime.ParamLocationHeader, *params.XDeviceID)
		if err != nil {
			return nil, err
		}

		req.Header.Set("X-Device-ID", headerParam3)
	}

	return req, nil
}

// NewGetCashierShiftApiV1CashierShiftGetRequest generates requests for GetCashierShiftApiV1CashierShiftGet
func NewGetCashierShiftApiV1CashierShiftGetRequest(server string, params *GetCashierShiftApiV1CashierShiftGetParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/cashier/shift")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params.XClientName != nil {
		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Client-Name", runtime.ParamLocationHeader, *params.XClientName)
		if err != nil {
			return nil, err
		}

		req.Header.Set("X-Client-Name", headerParam0)
	}

	if params.XClientVersion != nil {
		var headerParam1 string

		headerParam1, err = runtime.StyleParamWithLocation("simple", false, "X-Client-Version", runtime.ParamLocationHeader, *params.XClientVersion)
		if err != nil {
			return nil, err
		}

		req.Header.Set("X-Client-Version", headerParam1)
	}

	if params.XAccessKey != nil {
		var headerParam2 string

		headerParam2, err = runtime.StyleParamWithLocation("simple", false, "X-Access-Key", runtime.ParamLocationHeader, *params.XAccessKey)
		if err != nil {
			return nil, err
		}

		req.Header.Set("X-Access-Key", headerParam2)
	}

	if params.XDeviceID != nil {
		var headerParam3 string

		headerParam3, err = runtime.StyleParamWithLocation("simple", false, "X-Device-ID", runtime.ParamLocationHeader, *params.XDeviceID)
		if err != nil {
			return nil, err
		}

		req.Header.Set("X-Device-ID", headerParam3)
	}

	return req, nil
}

// NewSignInCashierApiV1CashierSigninPostRequest calls the generic SignInCashierApiV1CashierSigninPost builder with application/json body
func NewSignInCashierApiV1CashierSigninPostRequest(server string, params *SignInCashierApiV1CashierSigninPostParams, body SignInCashierApiV1CashierSigninPostJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewSignInCashierApiV1CashierSigninPostRequestWithBody(server, params, "application/json", bodyReader)
}

// NewSignInCashierApiV1CashierSigninPostRequestWithBody generates requests for SignInCashierApiV1CashierSigninPost with any type of body
func NewSignInCashierApiV1CashierSigninPostRequestWithBody(server string, params *SignInCashierApiV1CashierSigninPostParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/cashier/signin")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params.XClientName != nil {
		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Client-Name", runtime.ParamLocationHeader, *params.XClientName)
		if err != nil {
			return nil, err
		}

		req.Header.Set("X-Client-Name", headerParam0)
	}

	if params.XClientVersion != nil {
		var headerParam1 string

		headerParam1, err = runtime.StyleParamWithLocation("simple", false, "X-Client-Version", runtime.ParamLocationHeader, *params.XClientVersion)
		if err != nil {
			return nil, err
		}

		req.Header.Set("X-Client-Version", headerParam1)
	}

	if params.XAccessKey != nil {
		var headerParam2 string

		headerParam2, err = runtime.StyleParamWithLocation("simple", false, "X-Access-Key", runtime.ParamLocationHeader, *params.XAccessKey)
		if err != nil {
			return nil, err
		}

		req.Header.Set("X-Access-Key", headerParam2)
	}

	if params.XDeviceID != nil {
		var headerParam3 string

		headerParam3, err = runtime.StyleParamWithLocation("simple", false, "X-Device-ID", runtime.ParamLocationHeader, *params.XDeviceID)
		if err != nil {
			return nil, err
		}

		req.Header.Set("X-Device-ID", headerParam3)
	}

	return req, nil
}

// NewSignInCashierViaPinCodeApiV1CashierSigninPinCodePostRequest calls the generic SignInCashierViaPinCodeApiV1CashierSigninPinCodePost builder with application/json body
func NewSignInCashierViaPinCodeApiV1CashierSigninPinCodePostRequest(server string, params *SignInCashierViaPinCodeApiV1CashierSigninPinCodePostParams, body SignInCashierViaPinCodeApiV1CashierSigninPinCodePostJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewSignInCashierViaPinCodeApiV1CashierSigninPinCodePostRequestWithBody(server, params, "application/json", bodyReader)
}

// NewSignInCashierViaPinCodeApiV1CashierSigninPinCodePostRequestWithBody generates requests for SignInCashierViaPinCodeApiV1CashierSigninPinCodePost with any type of body
func NewSignInCashierViaPinCodeApiV1CashierSigninPinCodePostRequestWithBody(server string, params *SignInCashierViaPinCodeApiV1CashierSigninPinCodePostParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/cashier/signinPinCode")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params.XClientName != nil {
		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Client-Name", runtime.ParamLocationHeader, *params.XClientName)
		if err != nil {
			return nil, err
		}

		req.Header.Set("X-Client-Name", headerParam0)
	}

	if params.XClientVersion != nil {
		var headerParam1 string

		headerParam1, err = runtime.StyleParamWithLocation("simple", false, "X-Client-Version", runtime.ParamLocationHeader, *params.XClientVersion)
		if err != nil {
			return nil, err
		}

		req.Header.Set("X-Client-Version", headerParam1)
	}

	if params.XAccessKey != nil {
		var headerParam2 string

		headerParam2, err = runtime.StyleParamWithLocation("simple", false, "X-Access-Key", runtime.ParamLocationHeader, *params.XAccessKey)
		if err != nil {
			return nil, err
		}

		req.Header.Set("X-Access-Key", headerParam2)
	}

	var headerParam3 string

	headerParam3, err = runtime.StyleParamWithLocation("simple", false, "X-License-Key", runtime.ParamLocationHeader, params.XLicenseKey)
	if err != nil {
		return nil, err
	}

	req.Header.Set("X-License-Key", headerParam3)

	if params.XDeviceID != nil {
		var headerParam4 string

		headerParam4, err = runtime.StyleParamWithLocation("simple", false, "X-Device-ID", runtime.ParamLocationHeader, *params.XDeviceID)
		if err != nil {
			return nil, err
		}

		req.Header.Set("X-Device-ID", headerParam4)
	}

	return req, nil
}

// NewSignOutCashierApiV1CashierSignoutPostRequest generates requests for SignOutCashierApiV1CashierSignoutPost
func NewSignOutCashierApiV1CashierSignoutPostRequest(server string, params *SignOutCashierApiV1CashierSignoutPostParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/cashier/signout")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params.XClientName != nil {
		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Client-Name", runtime.ParamLocationHeader, *params.XClientName)
		if err != nil {
			return nil, err
		}

		req.Header.Set("X-Client-Name", headerParam0)
	}

	if params.XClientVersion != nil {
		var headerParam1 string

		headerParam1, err = runtime.StyleParamWithLocation("simple", false, "X-Client-Version", runtime.ParamLocationHeader, *params.XClientVersion)
		if err != nil {
			return nil, err
		}

		req.Header.Set("X-Client-Version", headerParam1)
	}

	if params.XAccessKey != nil {
		var headerParam2 string

		headerParam2, err = runtime.StyleParamWithLocation("simple", false, "X-Access-Key", runtime.ParamLocationHeader, *params.XAccessKey)
		if err != nil {
			return nil, err
		}

		req.Header.Set("X-Access-Key", headerParam2)
	}

	if params.XDeviceID != nil {
		var headerParam3 string

		headerParam3, err = runtime.StyleParamWithLocation("simple", false, "X-Device-ID", runtime.ParamLocationHeader, *params.XDeviceID)
		if err != nil {
			return nil, err
		}

		req.Header.Set("X-Device-ID", headerParam3)
	}

	return req, nil
}

// NewGetCurrencyRatesApiV1CurrencyRateGetRequest generates requests for GetCurrencyRatesApiV1CurrencyRateGet
func NewGetCurrencyRatesApiV1CurrencyRateGetRequest(server string, params *GetCurrencyRatesApiV1CurrencyRateGetParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/currency/rate")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Active != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "active", runtime.ParamLocationQuery, *params.Active); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params.XClientName != nil {
		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Client-Name", runtime.ParamLocationHeader, *params.XClientName)
		if err != nil {
			return nil, err
		}

		req.Header.Set("X-Client-Name", headerParam0)
	}

	if params.XClientVersion != nil {
		var headerParam1 string

		headerParam1, err = runtime.StyleParamWithLocation("simple", false, "X-Client-Version", runtime.ParamLocationHeader, *params.XClientVersion)
		if err != nil {
			return nil, err
		}

		req.Header.Set("X-Client-Version", headerParam1)
	}

	if params.XAccessKey != nil {
		var headerParam2 string

		headerParam2, err = runtime.StyleParamWithLocation("simple", false, "X-Access-Key", runtime.ParamLocationHeader, *params.XAccessKey)
		if err != nil {
			return nil, err
		}

		req.Header.Set("X-Access-Key", headerParam2)
	}

	return req, nil
}

// NewSetupCurrencyRatesApiV1CurrencyRateSetupPostRequest calls the generic SetupCurrencyRatesApiV1CurrencyRateSetupPost builder with application/json body
func NewSetupCurrencyRatesApiV1CurrencyRateSetupPostRequest(server string, params *SetupCurrencyRatesApiV1CurrencyRateSetupPostParams, body SetupCurrencyRatesApiV1CurrencyRateSetupPostJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewSetupCurrencyRatesApiV1CurrencyRateSetupPostRequestWithBody(server, params, "application/json", bodyReader)
}

// NewSetupCurrencyRatesApiV1CurrencyRateSetupPostRequestWithBody generates requests for SetupCurrencyRatesApiV1CurrencyRateSetupPost with any type of body
func NewSetupCurrencyRatesApiV1CurrencyRateSetupPostRequestWithBody(server string, params *SetupCurrencyRatesApiV1CurrencyRateSetupPostParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/currency/rate/setup")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params.XClientName != nil {
		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Client-Name", runtime.ParamLocationHeader, *params.XClientName)
		if err != nil {
			return nil, err
		}

		req.Header.Set("X-Client-Name", headerParam0)
	}

	if params.XClientVersion != nil {
		var headerParam1 string

		headerParam1, err = runtime.StyleParamWithLocation("simple", false, "X-Client-Version", runtime.ParamLocationHeader, *params.XClientVersion)
		if err != nil {
			return nil, err
		}

		req.Header.Set("X-Client-Version", headerParam1)
	}

	if params.XAccessKey != nil {
		var headerParam2 string

		headerParam2, err = runtime.StyleParamWithLocation("simple", false, "X-Access-Key", runtime.ParamLocationHeader, *params.XAccessKey)
		if err != nil {
			return nil, err
		}

		req.Header.Set("X-Access-Key", headerParam2)
	}

	return req, nil
}

// NewGetCurrencyRateApiV1CurrencyRateCurrencyCodeGetRequest generates requests for GetCurrencyRateApiV1CurrencyRateCurrencyCodeGet
func NewGetCurrencyRateApiV1CurrencyRateCurrencyCodeGetRequest(server string, currencyCode string, params *GetCurrencyRateApiV1CurrencyRateCurrencyCodeGetParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "currency_code", runtime.ParamLocationPath, currencyCode)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/currency/rate/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params.XClientName != nil {
		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Client-Name", runtime.ParamLocationHeader, *params.XClientName)
		if err != nil {
			return nil, err
		}

		req.Header.Set("X-Client-Name", headerParam0)
	}

	if params.XClientVersion != nil {
		var headerParam1 string

		headerParam1, err = runtime.StyleParamWithLocation("simple", false, "X-Client-Version", runtime.ParamLocationHeader, *params.XClientVersion)
		if err != nil {
			return nil, err
		}

		req.Header.Set("X-Client-Version", headerParam1)
	}

	if params.XAccessKey != nil {
		var headerParam2 string

		headerParam2, err = runtime.StyleParamWithLocation("simple", false, "X-Access-Key", runtime.ParamLocationHeader, *params.XAccessKey)
		if err != nil {
			return nil, err
		}

		req.Header.Set("X-Access-Key", headerParam2)
	}

	return req, nil
}

// NewGoodsReportApiV1ExtendedReportsGoodsPostRequest calls the generic GoodsReportApiV1ExtendedReportsGoodsPost builder with application/json body
func NewGoodsReportApiV1ExtendedReportsGoodsPostRequest(server string, params *GoodsReportApiV1ExtendedReportsGoodsPostParams, body GoodsReportApiV1ExtendedReportsGoodsPostJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewGoodsReportApiV1ExtendedReportsGoodsPostRequestWithBody(server, params, "application/json", bodyReader)
}

// NewGoodsReportApiV1ExtendedReportsGoodsPostRequestWithBody generates requests for GoodsReportApiV1ExtendedReportsGoodsPost with any type of body
func NewGoodsReportApiV1ExtendedReportsGoodsPostRequestWithBody(server string, params *GoodsReportApiV1ExtendedReportsGoodsPostParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/extended-reports/goods")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params.XClientName != nil {
		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Client-Name", runtime.ParamLocationHeader, *params.XClientName)
		if err != nil {
			return nil, err
		}

		req.Header.Set("X-Client-Name", headerParam0)
	}

	if params.XClientVersion != nil {
		var headerParam1 string

		headerParam1, err = runtime.StyleParamWithLocation("simple", false, "X-Client-Version", runtime.ParamLocationHeader, *params.XClientVersion)
		if err != nil {
			return nil, err
		}

		req.Header.Set("X-Client-Version", headerParam1)
	}

	if params.XAccessKey != nil {
		var headerParam2 string

		headerParam2, err = runtime.StyleParamWithLocation("simple", false, "X-Access-Key", runtime.ParamLocationHeader, *params.XAccessKey)
		if err != nil {
			return nil, err
		}

		req.Header.Set("X-Access-Key", headerParam2)
	}

	return req, nil
}

// NewGetReportTaskByIdApiV1ExtendedReportsReportTaskIdGetRequest generates requests for GetReportTaskByIdApiV1ExtendedReportsReportTaskIdGet
func NewGetReportTaskByIdApiV1ExtendedReportsReportTaskIdGetRequest(server string, reportTaskId openapi_types.UUID, params *GetReportTaskByIdApiV1ExtendedReportsReportTaskIdGetParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "report_task_id", runtime.ParamLocationPath, reportTaskId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/extended-reports/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params.XClientName != nil {
		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Client-Name", runtime.ParamLocationHeader, *params.XClientName)
		if err != nil {
			return nil, err
		}

		req.Header.Set("X-Client-Name", headerParam0)
	}

	if params.XClientVersion != nil {
		var headerParam1 string

		headerParam1, err = runtime.StyleParamWithLocation("simple", false, "X-Client-Version", runtime.ParamLocationHeader, *params.XClientVersion)
		if err != nil {
			return nil, err
		}

		req.Header.Set("X-Client-Version", headerParam1)
	}

	if params.XAccessKey != nil {
		var headerParam2 string

		headerParam2, err = runtime.StyleParamWithLocation("simple", false, "X-Access-Key", runtime.ParamLocationHeader, *params.XAccessKey)
		if err != nil {
			return nil, err
		}

		req.Header.Set("X-Access-Key", headerParam2)
	}

	return req, nil
}

// NewGetReportXlsxByIdApiV1ExtendedReportsReportTaskIdReportXlsxGetRequest generates requests for GetReportXlsxByIdApiV1ExtendedReportsReportTaskIdReportXlsxGet
func NewGetReportXlsxByIdApiV1ExtendedReportsReportTaskIdReportXlsxGetRequest(server string, reportTaskId openapi_types.UUID, params *GetReportXlsxByIdApiV1ExtendedReportsReportTaskIdReportXlsxGetParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "report_task_id", runtime.ParamLocationPath, reportTaskId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/extended-reports/%s/report.xlsx", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params.XClientName != nil {
		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Client-Name", runtime.ParamLocationHeader, *params.XClientName)
		if err != nil {
			return nil, err
		}

		req.Header.Set("X-Client-Name", headerParam0)
	}

	if params.XClientVersion != nil {
		var headerParam1 string

		headerParam1, err = runtime.StyleParamWithLocation("simple", false, "X-Client-Version", runtime.ParamLocationHeader, *params.XClientVersion)
		if err != nil {
			return nil, err
		}

		req.Header.Set("X-Client-Version", headerParam1)
	}

	if params.XAccessKey != nil {
		var headerParam2 string

		headerParam2, err = runtime.StyleParamWithLocation("simple", false, "X-Access-Key", runtime.ParamLocationHeader, *params.XAccessKey)
		if err != nil {
			return nil, err
		}

		req.Header.Set("X-Access-Key", headerParam2)
	}

	return req, nil
}

// NewGetGoodsApiV1GoodsGetRequest generates requests for GetGoodsApiV1GoodsGet
func NewGetGoodsApiV1GoodsGetRequest(server string, params *GetGoodsApiV1GoodsGetParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/goods")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Name != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "name", runtime.ParamLocationQuery, *params.Name); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Barcode != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "barcode", runtime.ParamLocationQuery, *params.Barcode); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Query != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "query", runtime.ParamLocationQuery, *params.Query); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.OrderByName != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "order_by_name", runtime.ParamLocationQuery, *params.OrderByName); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.OrderByCode != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "order_by_code", runtime.ParamLocationQuery, *params.OrderByCode); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.OrderByPosition != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "order_by_position", runtime.ParamLocationQuery, *params.OrderByPosition); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Limit != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Offset != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params.XClientName != nil {
		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Client-Name", runtime.ParamLocationHeader, *params.XClientName)
		if err != nil {
			return nil, err
		}

		req.Header.Set("X-Client-Name", headerParam0)
	}

	if params.XClientVersion != nil {
		var headerParam1 string

		headerParam1, err = runtime.StyleParamWithLocation("simple", false, "X-Client-Version", runtime.ParamLocationHeader, *params.XClientVersion)
		if err != nil {
			return nil, err
		}

		req.Header.Set("X-Client-Version", headerParam1)
	}

	if params.XAccessKey != nil {
		var headerParam2 string

		headerParam2, err = runtime.StyleParamWithLocation("simple", false, "X-Access-Key", runtime.ParamLocationHeader, *params.XAccessKey)
		if err != nil {
			return nil, err
		}

		req.Header.Set("X-Access-Key", headerParam2)
	}

	return req, nil
}

// NewExportGoodsFileApiV1GoodsExportFileTaskIdGetRequest generates requests for ExportGoodsFileApiV1GoodsExportFileTaskIdGet
func NewExportGoodsFileApiV1GoodsExportFileTaskIdGetRequest(server string, taskId openapi_types.UUID, params *ExportGoodsFileApiV1GoodsExportFileTaskIdGetParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "task_id", runtime.ParamLocationPath, taskId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/goods/export/file/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.ChunkNumber != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "chunk_number", runtime.ParamLocationQuery, *params.ChunkNumber); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params.XClientName != nil {
		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Client-Name", runtime.ParamLocationHeader, *params.XClientName)
		if err != nil {
			return nil, err
		}

		req.Header.Set("X-Client-Name", headerParam0)
	}

	if params.XClientVersion != nil {
		var headerParam1 string

		headerParam1, err = runtime.StyleParamWithLocation("simple", false, "X-Client-Version", runtime.ParamLocationHeader, *params.XClientVersion)
		if err != nil {
			return nil, err
		}

		req.Header.Set("X-Client-Version", headerParam1)
	}

	if params.XAccessKey != nil {
		var headerParam2 string

		headerParam2, err = runtime.StyleParamWithLocation("simple", false, "X-Access-Key", runtime.ParamLocationHeader, *params.XAccessKey)
		if err != nil {
			return nil, err
		}

		req.Header.Set("X-Access-Key", headerParam2)
	}

	return req, nil
}

// NewExportGoodsTaskStatusApiV1GoodsExportTaskStatusTaskIdGetRequest generates requests for ExportGoodsTaskStatusApiV1GoodsExportTaskStatusTaskIdGet
func NewExportGoodsTaskStatusApiV1GoodsExportTaskStatusTaskIdGetRequest(server string, taskId openapi_types.UUID, params *ExportGoodsTaskStatusApiV1GoodsExportTaskStatusTaskIdGetParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "task_id", runtime.ParamLocationPath, taskId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/goods/export/task_status/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params.XClientName != nil {
		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Client-Name", runtime.ParamLocationHeader, *params.XClientName)
		if err != nil {
			return nil, err
		}

		req.Header.Set("X-Client-Name", headerParam0)
	}

	if params.XClientVersion != nil {
		var headerParam1 string

		headerParam1, err = runtime.StyleParamWithLocation("simple", false, "X-Client-Version", runtime.ParamLocationHeader, *params.XClientVersion)
		if err != nil {
			return nil, err
		}

		req.Header.Set("X-Client-Version", headerParam1)
	}

	if params.XAccessKey != nil {
		var headerParam2 string

		headerParam2, err = runtime.StyleParamWithLocation("simple", false, "X-Access-Key", runtime.ParamLocationHeader, *params.XAccessKey)
		if err != nil {
			return nil, err
		}

		req.Header.Set("X-Access-Key", headerParam2)
	}

	return req, nil
}

// NewExportGoodsApiV1GoodsExportExportExtensionGetRequest generates requests for ExportGoodsApiV1GoodsExportExportExtensionGet
func NewExportGoodsApiV1GoodsExportExportExtensionGetRequest(server string, exportExtension ExportExtensionType, params *ExportGoodsApiV1GoodsExportExportExtensionGetParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "export_extension", runtime.ParamLocationPath, exportExtension)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/goods/export/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params.XClientName != nil {
		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Client-Name", runtime.ParamLocationHeader, *params.XClientName)
		if err != nil {
			return nil, err
		}

		req.Header.Set("X-Client-Name", headerParam0)
	}

	if params.XClientVersion != nil {
		var headerParam1 string

		headerParam1, err = runtime.StyleParamWithLocation("simple", false, "X-Client-Version", runtime.ParamLocationHeader, *params.XClientVersion)
		if err != nil {
			return nil, err
		}

		req.Header.Set("X-Client-Version", headerParam1)
	}

	if params.XAccessKey != nil {
		var headerParam2 string

		headerParam2, err = runtime.StyleParamWithLocation("simple", false, "X-Access-Key", runtime.ParamLocationHeader, *params.XAccessKey)
		if err != nil {
			return nil, err
		}

		req.Header.Set("X-Access-Key", headerParam2)
	}

	return req, nil
}

// NewImportGoodsApplyChangesApiV1GoodsImportApplyChangesTaskIdPostRequest generates requests for ImportGoodsApplyChangesApiV1GoodsImportApplyChangesTaskIdPost
func NewImportGoodsApplyChangesApiV1GoodsImportApplyChangesTaskIdPostRequest(server string, taskId openapi_types.UUID, params *ImportGoodsApplyChangesApiV1GoodsImportApplyChangesTaskIdPostParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "task_id", runtime.ParamLocationPath, taskId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/goods/import/apply_changes/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params.XClientName != nil {
		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Client-Name", runtime.ParamLocationHeader, *params.XClientName)
		if err != nil {
			return nil, err
		}

		req.Header.Set("X-Client-Name", headerParam0)
	}

	if params.XClientVersion != nil {
		var headerParam1 string

		headerParam1, err = runtime.StyleParamWithLocation("simple", false, "X-Client-Version", runtime.ParamLocationHeader, *params.XClientVersion)
		if err != nil {
			return nil, err
		}

		req.Header.Set("X-Client-Version", headerParam1)
	}

	if params.XAccessKey != nil {
		var headerParam2 string

		headerParam2, err = runtime.StyleParamWithLocation("simple", false, "X-Access-Key", runtime.ParamLocationHeader, *params.XAccessKey)
		if err != nil {
			return nil, err
		}

		req.Header.Set("X-Access-Key", headerParam2)
	}

	return req, nil
}

// NewImportGoodsTaskStatusApiV1GoodsImportTaskStatusTaskIdGetRequest generates requests for ImportGoodsTaskStatusApiV1GoodsImportTaskStatusTaskIdGet
func NewImportGoodsTaskStatusApiV1GoodsImportTaskStatusTaskIdGetRequest(server string, taskId openapi_types.UUID, params *ImportGoodsTaskStatusApiV1GoodsImportTaskStatusTaskIdGetParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "task_id", runtime.ParamLocationPath, taskId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/goods/import/task_status/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params.XClientName != nil {
		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Client-Name", runtime.ParamLocationHeader, *params.XClientName)
		if err != nil {
			return nil, err
		}

		req.Header.Set("X-Client-Name", headerParam0)
	}

	if params.XClientVersion != nil {
		var headerParam1 string

		headerParam1, err = runtime.StyleParamWithLocation("simple", false, "X-Client-Version", runtime.ParamLocationHeader, *params.XClientVersion)
		if err != nil {
			return nil, err
		}

		req.Header.Set("X-Client-Version", headerParam1)
	}

	if params.XAccessKey != nil {
		var headerParam2 string

		headerParam2, err = runtime.StyleParamWithLocation("simple", false, "X-Access-Key", runtime.ParamLocationHeader, *params.XAccessKey)
		if err != nil {
			return nil, err
		}

		req.Header.Set("X-Access-Key", headerParam2)
	}

	return req, nil
}

// NewImportGoodsFromFileApiV1GoodsImportUploadPostRequestWithBody generates requests for ImportGoodsFromFileApiV1GoodsImportUploadPost with any type of body
func NewImportGoodsFromFileApiV1GoodsImportUploadPostRequestWithBody(server string, params *ImportGoodsFromFileApiV1GoodsImportUploadPostParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/goods/import/upload")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params.XClientName != nil {
		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Client-Name", runtime.ParamLocationHeader, *params.XClientName)
		if err != nil {
			return nil, err
		}

		req.Header.Set("X-Client-Name", headerParam0)
	}

	if params.XClientVersion != nil {
		var headerParam1 string

		headerParam1, err = runtime.StyleParamWithLocation("simple", false, "X-Client-Version", runtime.ParamLocationHeader, *params.XClientVersion)
		if err != nil {
			return nil, err
		}

		req.Header.Set("X-Client-Version", headerParam1)
	}

	if params.XAccessKey != nil {
		var headerParam2 string

		headerParam2, err = runtime.StyleParamWithLocation("simple", false, "X-Access-Key", runtime.ParamLocationHeader, *params.XAccessKey)
		if err != nil {
			return nil, err
		}

		req.Header.Set("X-Access-Key", headerParam2)
	}

	return req, nil
}

// NewGetGoodApiV1GoodsGoodIdGetRequest generates requests for GetGoodApiV1GoodsGoodIdGet
func NewGetGoodApiV1GoodsGoodIdGetRequest(server string, goodId openapi_types.UUID, params *GetGoodApiV1GoodsGoodIdGetParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "good_id", runtime.ParamLocationPath, goodId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/goods/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params.XClientName != nil {
		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Client-Name", runtime.ParamLocationHeader, *params.XClientName)
		if err != nil {
			return nil, err
		}

		req.Header.Set("X-Client-Name", headerParam0)
	}

	if params.XClientVersion != nil {
		var headerParam1 string

		headerParam1, err = runtime.StyleParamWithLocation("simple", false, "X-Client-Version", runtime.ParamLocationHeader, *params.XClientVersion)
		if err != nil {
			return nil, err
		}

		req.Header.Set("X-Client-Version", headerParam1)
	}

	if params.XAccessKey != nil {
		var headerParam2 string

		headerParam2, err = runtime.StyleParamWithLocation("simple", false, "X-Access-Key", runtime.ParamLocationHeader, *params.XAccessKey)
		if err != nil {
			return nil, err
		}

		req.Header.Set("X-Access-Key", headerParam2)
	}

	return req, nil
}

// NewGetOrdersApiV1OrdersGetRequest generates requests for GetOrdersApiV1OrdersGet
func NewGetOrdersApiV1OrdersGetRequest(server string, params *GetOrdersApiV1OrdersGetParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/orders")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Desc != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "desc", runtime.ParamLocationQuery, *params.Desc); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Status != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "status", runtime.ParamLocationQuery, *params.Status); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.StockCode != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "stock_code", runtime.ParamLocationQuery, *params.StockCode); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Limit != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Offset != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params.XClientName != nil {
		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Client-Name", runtime.ParamLocationHeader, *params.XClientName)
		if err != nil {
			return nil, err
		}

		req.Header.Set("X-Client-Name", headerParam0)
	}

	if params.XClientVersion != nil {
		var headerParam1 string

		headerParam1, err = runtime.StyleParamWithLocation("simple", false, "X-Client-Version", runtime.ParamLocationHeader, *params.XClientVersion)
		if err != nil {
			return nil, err
		}

		req.Header.Set("X-Client-Version", headerParam1)
	}

	if params.XAccessKey != nil {
		var headerParam2 string

		headerParam2, err = runtime.StyleParamWithLocation("simple", false, "X-Access-Key", runtime.ParamLocationHeader, *params.XAccessKey)
		if err != nil {
			return nil, err
		}

		req.Header.Set("X-Access-Key", headerParam2)
	}

	return req, nil
}

// NewAddOrdersApiV1OrdersPostRequest calls the generic AddOrdersApiV1OrdersPost builder with application/json body
func NewAddOrdersApiV1OrdersPostRequest(server string, params *AddOrdersApiV1OrdersPostParams, body AddOrdersApiV1OrdersPostJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewAddOrdersApiV1OrdersPostRequestWithBody(server, params, "application/json", bodyReader)
}

// NewAddOrdersApiV1OrdersPostRequestWithBody generates requests for AddOrdersApiV1OrdersPost with any type of body
func NewAddOrdersApiV1OrdersPostRequestWithBody(server string, params *AddOrdersApiV1OrdersPostParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/orders")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params.XClientName != nil {
		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Client-Name", runtime.ParamLocationHeader, *params.XClientName)
		if err != nil {
			return nil, err
		}

		req.Header.Set("X-Client-Name", headerParam0)
	}

	if params.XClientVersion != nil {
		var headerParam1 string

		headerParam1, err = runtime.StyleParamWithLocation("simple", false, "X-Client-Version", runtime.ParamLocationHeader, *params.XClientVersion)
		if err != nil {
			return nil, err
		}

		req.Header.Set("X-Client-Version", headerParam1)
	}

	if params.XAccessKey != nil {
		var headerParam2 string

		headerParam2, err = runtime.StyleParamWithLocation("simple", false, "X-Access-Key", runtime.ParamLocationHeader, *params.XAccessKey)
		if err != nil {
			return nil, err
		}

		req.Header.Set("X-Access-Key", headerParam2)
	}

	return req, nil
}

// NewCloseNotFiscalizeOrderApiV1OrdersClosePatchRequest generates requests for CloseNotFiscalizeOrderApiV1OrdersClosePatch
func NewCloseNotFiscalizeOrderApiV1OrdersClosePatchRequest(server string, params *CloseNotFiscalizeOrderApiV1OrdersClosePatchParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/orders/close")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "order_id", runtime.ParamLocationQuery, params.OrderId); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("PATCH", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params.XClientName != nil {
		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Client-Name", runtime.ParamLocationHeader, *params.XClientName)
		if err != nil {
			return nil, err
		}

		req.Header.Set("X-Client-Name", headerParam0)
	}

	if params.XClientVersion != nil {
		var headerParam1 string

		headerParam1, err = runtime.StyleParamWithLocation("simple", false, "X-Client-Version", runtime.ParamLocationHeader, *params.XClientVersion)
		if err != nil {
			return nil, err
		}

		req.Header.Set("X-Client-Version", headerParam1)
	}

	if params.XAccessKey != nil {
		var headerParam2 string

		headerParam2, err = runtime.StyleParamWithLocation("simple", false, "X-Access-Key", runtime.ParamLocationHeader, *params.XAccessKey)
		if err != nil {
			return nil, err
		}

		req.Header.Set("X-Access-Key", headerParam2)
	}

	return req, nil
}

// NewUpdateCustomOrderStatusApiV1OrdersCustomStatusOrderIdPatchRequest generates requests for UpdateCustomOrderStatusApiV1OrdersCustomStatusOrderIdPatch
func NewUpdateCustomOrderStatusApiV1OrdersCustomStatusOrderIdPatchRequest(server string, orderId openapi_types.UUID, params *UpdateCustomOrderStatusApiV1OrdersCustomStatusOrderIdPatchParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "order_id", runtime.ParamLocationPath, orderId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/orders/custom_status/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "new_status", runtime.ParamLocationQuery, params.NewStatus); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("PATCH", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params.XClientName != nil {
		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Client-Name", runtime.ParamLocationHeader, *params.XClientName)
		if err != nil {
			return nil, err
		}

		req.Header.Set("X-Client-Name", headerParam0)
	}

	if params.XClientVersion != nil {
		var headerParam1 string

		headerParam1, err = runtime.StyleParamWithLocation("simple", false, "X-Client-Version", runtime.ParamLocationHeader, *params.XClientVersion)
		if err != nil {
			return nil, err
		}

		req.Header.Set("X-Client-Version", headerParam1)
	}

	if params.XAccessKey != nil {
		var headerParam2 string

		headerParam2, err = runtime.StyleParamWithLocation("simple", false, "X-Access-Key", runtime.ParamLocationHeader, *params.XAccessKey)
		if err != nil {
			return nil, err
		}

		req.Header.Set("X-Access-Key", headerParam2)
	}

	return req, nil
}

// NewDeleteIntegrationApiV1OrdersIntegrationDeleteRequest generates requests for DeleteIntegrationApiV1OrdersIntegrationDelete
func NewDeleteIntegrationApiV1OrdersIntegrationDeleteRequest(server string, params *DeleteIntegrationApiV1OrdersIntegrationDeleteParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/orders/integration")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params.XClientName != nil {
		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Client-Name", runtime.ParamLocationHeader, *params.XClientName)
		if err != nil {
			return nil, err
		}

		req.Header.Set("X-Client-Name", headerParam0)
	}

	if params.XClientVersion != nil {
		var headerParam1 string

		headerParam1, err = runtime.StyleParamWithLocation("simple", false, "X-Client-Version", runtime.ParamLocationHeader, *params.XClientVersion)
		if err != nil {
			return nil, err
		}

		req.Header.Set("X-Client-Version", headerParam1)
	}

	if params.XAccessKey != nil {
		var headerParam2 string

		headerParam2, err = runtime.StyleParamWithLocation("simple", false, "X-Access-Key", runtime.ParamLocationHeader, *params.XAccessKey)
		if err != nil {
			return nil, err
		}

		req.Header.Set("X-Access-Key", headerParam2)
	}

	return req, nil
}

// NewGetIntegrationApiV1OrdersIntegrationGetRequest generates requests for GetIntegrationApiV1OrdersIntegrationGet
func NewGetIntegrationApiV1OrdersIntegrationGetRequest(server string, params *GetIntegrationApiV1OrdersIntegrationGetParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/orders/integration")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params.XClientName != nil {
		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Client-Name", runtime.ParamLocationHeader, *params.XClientName)
		if err != nil {
			return nil, err
		}

		req.Header.Set("X-Client-Name", headerParam0)
	}

	if params.XClientVersion != nil {
		var headerParam1 string

		headerParam1, err = runtime.StyleParamWithLocation("simple", false, "X-Client-Version", runtime.ParamLocationHeader, *params.XClientVersion)
		if err != nil {
			return nil, err
		}

		req.Header.Set("X-Client-Version", headerParam1)
	}

	if params.XAccessKey != nil {
		var headerParam2 string

		headerParam2, err = runtime.StyleParamWithLocation("simple", false, "X-Access-Key", runtime.ParamLocationHeader, *params.XAccessKey)
		if err != nil {
			return nil, err
		}

		req.Header.Set("X-Access-Key", headerParam2)
	}

	return req, nil
}

// NewSetIntegrationApiV1OrdersIntegrationPostRequest calls the generic SetIntegrationApiV1OrdersIntegrationPost builder with application/json body
func NewSetIntegrationApiV1OrdersIntegrationPostRequest(server string, params *SetIntegrationApiV1OrdersIntegrationPostParams, body SetIntegrationApiV1OrdersIntegrationPostJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewSetIntegrationApiV1OrdersIntegrationPostRequestWithBody(server, params, "application/json", bodyReader)
}

// NewSetIntegrationApiV1OrdersIntegrationPostRequestWithBody generates requests for SetIntegrationApiV1OrdersIntegrationPost with any type of body
func NewSetIntegrationApiV1OrdersIntegrationPostRequestWithBody(server string, params *SetIntegrationApiV1OrdersIntegrationPostParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/orders/integration")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params.XClientName != nil {
		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Client-Name", runtime.ParamLocationHeader, *params.XClientName)
		if err != nil {
			return nil, err
		}

		req.Header.Set("X-Client-Name", headerParam0)
	}

	if params.XClientVersion != nil {
		var headerParam1 string

		headerParam1, err = runtime.StyleParamWithLocation("simple", false, "X-Client-Version", runtime.ParamLocationHeader, *params.XClientVersion)
		if err != nil {
			return nil, err
		}

		req.Header.Set("X-Client-Version", headerParam1)
	}

	if params.XAccessKey != nil {
		var headerParam2 string

		headerParam2, err = runtime.StyleParamWithLocation("simple", false, "X-Access-Key", runtime.ParamLocationHeader, *params.XAccessKey)
		if err != nil {
			return nil, err
		}

		req.Header.Set("X-Access-Key", headerParam2)
	}

	return req, nil
}

// NewEditOrderApiV1OrdersIntegrationEditOrderPostRequest calls the generic EditOrderApiV1OrdersIntegrationEditOrderPost builder with application/json body
func NewEditOrderApiV1OrdersIntegrationEditOrderPostRequest(server string, params *EditOrderApiV1OrdersIntegrationEditOrderPostParams, body EditOrderApiV1OrdersIntegrationEditOrderPostJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewEditOrderApiV1OrdersIntegrationEditOrderPostRequestWithBody(server, params, "application/json", bodyReader)
}

// NewEditOrderApiV1OrdersIntegrationEditOrderPostRequestWithBody generates requests for EditOrderApiV1OrdersIntegrationEditOrderPost with any type of body
func NewEditOrderApiV1OrdersIntegrationEditOrderPostRequestWithBody(server string, params *EditOrderApiV1OrdersIntegrationEditOrderPostParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/orders/integration/edit-order")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params.XClientName != nil {
		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Client-Name", runtime.ParamLocationHeader, *params.XClientName)
		if err != nil {
			return nil, err
		}

		req.Header.Set("X-Client-Name", headerParam0)
	}

	if params.XClientVersion != nil {
		var headerParam1 string

		headerParam1, err = runtime.StyleParamWithLocation("simple", false, "X-Client-Version", runtime.ParamLocationHeader, *params.XClientVersion)
		if err != nil {
			return nil, err
		}

		req.Header.Set("X-Client-Version", headerParam1)
	}

	if params.XAccessKey != nil {
		var headerParam2 string

		headerParam2, err = runtime.StyleParamWithLocation("simple", false, "X-Access-Key", runtime.ParamLocationHeader, *params.XAccessKey)
		if err != nil {
			return nil, err
		}

		req.Header.Set("X-Access-Key", headerParam2)
	}

	return req, nil
}

// NewRunOrdersSynchronizationApiV1OrdersSyncPostRequest generates requests for RunOrdersSynchronizationApiV1OrdersSyncPost
func NewRunOrdersSynchronizationApiV1OrdersSyncPostRequest(server string, params *RunOrdersSynchronizationApiV1OrdersSyncPostParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/orders/sync")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params.XClientName != nil {
		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Client-Name", runtime.ParamLocationHeader, *params.XClientName)
		if err != nil {
			return nil, err
		}

		req.Header.Set("X-Client-Name", headerParam0)
	}

	if params.XClientVersion != nil {
		var headerParam1 string

		headerParam1, err = runtime.StyleParamWithLocation("simple", false, "X-Client-Version", runtime.ParamLocationHeader, *params.XClientVersion)
		if err != nil {
			return nil, err
		}

		req.Header.Set("X-Client-Version", headerParam1)
	}

	if params.XAccessKey != nil {
		var headerParam2 string

		headerParam2, err = runtime.StyleParamWithLocation("simple", false, "X-Access-Key", runtime.ParamLocationHeader, *params.XAccessKey)
		if err != nil {
			return nil, err
		}

		req.Header.Set("X-Access-Key", headerParam2)
	}

	return req, nil
}

// NewGetOrderApiV1OrdersOrderIdGetRequest generates requests for GetOrderApiV1OrdersOrderIdGet
func NewGetOrderApiV1OrdersOrderIdGetRequest(server string, orderId openapi_types.UUID, params *GetOrderApiV1OrdersOrderIdGetParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "order_id", runtime.ParamLocationPath, orderId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/orders/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params.XClientName != nil {
		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Client-Name", runtime.ParamLocationHeader, *params.XClientName)
		if err != nil {
			return nil, err
		}

		req.Header.Set("X-Client-Name", headerParam0)
	}

	if params.XClientVersion != nil {
		var headerParam1 string

		headerParam1, err = runtime.StyleParamWithLocation("simple", false, "X-Client-Version", runtime.ParamLocationHeader, *params.XClientVersion)
		if err != nil {
			return nil, err
		}

		req.Header.Set("X-Client-Version", headerParam1)
	}

	if params.XAccessKey != nil {
		var headerParam2 string

		headerParam2, err = runtime.StyleParamWithLocation("simple", false, "X-Access-Key", runtime.ParamLocationHeader, *params.XAccessKey)
		if err != nil {
			return nil, err
		}

		req.Header.Set("X-Access-Key", headerParam2)
	}

	return req, nil
}

// NewCancelOrderApiV1OrdersOrderIdPatchRequest generates requests for CancelOrderApiV1OrdersOrderIdPatch
func NewCancelOrderApiV1OrdersOrderIdPatchRequest(server string, orderId openapi_types.UUID, params *CancelOrderApiV1OrdersOrderIdPatchParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "order_id", runtime.ParamLocationPath, orderId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/orders/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params.XClientName != nil {
		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Client-Name", runtime.ParamLocationHeader, *params.XClientName)
		if err != nil {
			return nil, err
		}

		req.Header.Set("X-Client-Name", headerParam0)
	}

	if params.XClientVersion != nil {
		var headerParam1 string

		headerParam1, err = runtime.StyleParamWithLocation("simple", false, "X-Client-Version", runtime.ParamLocationHeader, *params.XClientVersion)
		if err != nil {
			return nil, err
		}

		req.Header.Set("X-Client-Version", headerParam1)
	}

	if params.XAccessKey != nil {
		var headerParam2 string

		headerParam2, err = runtime.StyleParamWithLocation("simple", false, "X-Access-Key", runtime.ParamLocationHeader, *params.XAccessKey)
		if err != nil {
			return nil, err
		}

		req.Header.Set("X-Access-Key", headerParam2)
	}

	return req, nil
}

// NewGetCurrentOrganizationLogoApiV1OrganizationLogoPngGetRequest generates requests for GetCurrentOrganizationLogoApiV1OrganizationLogoPngGet
func NewGetCurrentOrganizationLogoApiV1OrganizationLogoPngGetRequest(server string, params *GetCurrentOrganizationLogoApiV1OrganizationLogoPngGetParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/organization/logo.png")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params.XClientName != nil {
		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Client-Name", runtime.ParamLocationHeader, *params.XClientName)
		if err != nil {
			return nil, err
		}

		req.Header.Set("X-Client-Name", headerParam0)
	}

	if params.XClientVersion != nil {
		var headerParam1 string

		headerParam1, err = runtime.StyleParamWithLocation("simple", false, "X-Client-Version", runtime.ParamLocationHeader, *params.XClientVersion)
		if err != nil {
			return nil, err
		}

		req.Header.Set("X-Client-Version", headerParam1)
	}

	if params.XAccessKey != nil {
		var headerParam2 string

		headerParam2, err = runtime.StyleParamWithLocation("simple", false, "X-Access-Key", runtime.ParamLocationHeader, *params.XAccessKey)
		if err != nil {
			return nil, err
		}

		req.Header.Set("X-Access-Key", headerParam2)
	}

	return req, nil
}

// NewGetCurrentOrganizationReceiptSettingsApiV1OrganizationReceiptConfigGetRequest generates requests for GetCurrentOrganizationReceiptSettingsApiV1OrganizationReceiptConfigGet
func NewGetCurrentOrganizationReceiptSettingsApiV1OrganizationReceiptConfigGetRequest(server string, params *GetCurrentOrganizationReceiptSettingsApiV1OrganizationReceiptConfigGetParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/organization/receipt-config")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params.XClientName != nil {
		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Client-Name", runtime.ParamLocationHeader, *params.XClientName)
		if err != nil {
			return nil, err
		}

		req.Header.Set("X-Client-Name", headerParam0)
	}

	if params.XClientVersion != nil {
		var headerParam1 string

		headerParam1, err = runtime.StyleParamWithLocation("simple", false, "X-Client-Version", runtime.ParamLocationHeader, *params.XClientVersion)
		if err != nil {
			return nil, err
		}

		req.Header.Set("X-Client-Version", headerParam1)
	}

	if params.XAccessKey != nil {
		var headerParam2 string

		headerParam2, err = runtime.StyleParamWithLocation("simple", false, "X-Access-Key", runtime.ParamLocationHeader, *params.XAccessKey)
		if err != nil {
			return nil, err
		}

		req.Header.Set("X-Access-Key", headerParam2)
	}

	return req, nil
}

// NewGetCurrentOrganizationSmsBillingBalanceApiV1OrganizationSmsBillingGetRequest generates requests for GetCurrentOrganizationSmsBillingBalanceApiV1OrganizationSmsBillingGet
func NewGetCurrentOrganizationSmsBillingBalanceApiV1OrganizationSmsBillingGetRequest(server string, params *GetCurrentOrganizationSmsBillingBalanceApiV1OrganizationSmsBillingGetParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/organization/sms-billing")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params.XClientName != nil {
		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Client-Name", runtime.ParamLocationHeader, *params.XClientName)
		if err != nil {
			return nil, err
		}

		req.Header.Set("X-Client-Name", headerParam0)
	}

	if params.XClientVersion != nil {
		var headerParam1 string

		headerParam1, err = runtime.StyleParamWithLocation("simple", false, "X-Client-Version", runtime.ParamLocationHeader, *params.XClientVersion)
		if err != nil {
			return nil, err
		}

		req.Header.Set("X-Client-Version", headerParam1)
	}

	if params.XAccessKey != nil {
		var headerParam2 string

		headerParam2, err = runtime.StyleParamWithLocation("simple", false, "X-Access-Key", runtime.ParamLocationHeader, *params.XAccessKey)
		if err != nil {
			return nil, err
		}

		req.Header.Set("X-Access-Key", headerParam2)
	}

	return req, nil
}

// NewGetCurrentOrganizationTextLogoApiV1OrganizationTextLogoPngGetRequest generates requests for GetCurrentOrganizationTextLogoApiV1OrganizationTextLogoPngGet
func NewGetCurrentOrganizationTextLogoApiV1OrganizationTextLogoPngGetRequest(server string, params *GetCurrentOrganizationTextLogoApiV1OrganizationTextLogoPngGetParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/organization/text_logo.png")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params.XClientName != nil {
		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Client-Name", runtime.ParamLocationHeader, *params.XClientName)
		if err != nil {
			return nil, err
		}

		req.Header.Set("X-Client-Name", headerParam0)
	}

	if params.XClientVersion != nil {
		var headerParam1 string

		headerParam1, err = runtime.StyleParamWithLocation("simple", false, "X-Client-Version", runtime.ParamLocationHeader, *params.XClientVersion)
		if err != nil {
			return nil, err
		}

		req.Header.Set("X-Client-Version", headerParam1)
	}

	if params.XAccessKey != nil {
		var headerParam2 string

		headerParam2, err = runtime.StyleParamWithLocation("simple", false, "X-Access-Key", runtime.ParamLocationHeader, *params.XAccessKey)
		if err != nil {
			return nil, err
		}

		req.Header.Set("X-Access-Key", headerParam2)
	}

	return req, nil
}

// NewGetReceiptsApiV1ReceiptsGetRequest generates requests for GetReceiptsApiV1ReceiptsGet
func NewGetReceiptsApiV1ReceiptsGetRequest(server string, params *GetReceiptsApiV1ReceiptsGetParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/receipts")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.FiscalCode != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "fiscal_code", runtime.ParamLocationQuery, *params.FiscalCode); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Serial != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "serial", runtime.ParamLocationQuery, *params.Serial); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Desc != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "desc", runtime.ParamLocationQuery, *params.Desc); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Limit != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Offset != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params.XClientName != nil {
		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Client-Name", runtime.ParamLocationHeader, *params.XClientName)
		if err != nil {
			return nil, err
		}

		req.Header.Set("X-Client-Name", headerParam0)
	}

	if params.XClientVersion != nil {
		var headerParam1 string

		headerParam1, err = runtime.StyleParamWithLocation("simple", false, "X-Client-Version", runtime.ParamLocationHeader, *params.XClientVersion)
		if err != nil {
			return nil, err
		}

		req.Header.Set("X-Client-Version", headerParam1)
	}

	if params.XAccessKey != nil {
		var headerParam2 string

		headerParam2, err = runtime.StyleParamWithLocation("simple", false, "X-Access-Key", runtime.ParamLocationHeader, *params.XAccessKey)
		if err != nil {
			return nil, err
		}

		req.Header.Set("X-Access-Key", headerParam2)
	}

	return req, nil
}

// NewAddExternalReceiptApiV1ReceiptsAddExternalPostRequest calls the generic AddExternalReceiptApiV1ReceiptsAddExternalPost builder with application/json body
func NewAddExternalReceiptApiV1ReceiptsAddExternalPostRequest(server string, params *AddExternalReceiptApiV1ReceiptsAddExternalPostParams, body AddExternalReceiptApiV1ReceiptsAddExternalPostJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewAddExternalReceiptApiV1ReceiptsAddExternalPostRequestWithBody(server, params, "application/json", bodyReader)
}

// NewAddExternalReceiptApiV1ReceiptsAddExternalPostRequestWithBody generates requests for AddExternalReceiptApiV1ReceiptsAddExternalPost with any type of body
func NewAddExternalReceiptApiV1ReceiptsAddExternalPostRequestWithBody(server string, params *AddExternalReceiptApiV1ReceiptsAddExternalPostParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/receipts/add-external")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params.XClientName != nil {
		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Client-Name", runtime.ParamLocationHeader, *params.XClientName)
		if err != nil {
			return nil, err
		}

		req.Header.Set("X-Client-Name", headerParam0)
	}

	if params.XClientVersion != nil {
		var headerParam1 string

		headerParam1, err = runtime.StyleParamWithLocation("simple", false, "X-Client-Version", runtime.ParamLocationHeader, *params.XClientVersion)
		if err != nil {
			return nil, err
		}

		req.Header.Set("X-Client-Version", headerParam1)
	}

	if params.XAccessKey != nil {
		var headerParam2 string

		headerParam2, err = runtime.StyleParamWithLocation("simple", false, "X-Access-Key", runtime.ParamLocationHeader, *params.XAccessKey)
		if err != nil {
			return nil, err
		}

		req.Header.Set("X-Access-Key", headerParam2)
	}

	if params.XDeviceID != nil {
		var headerParam3 string

		headerParam3, err = runtime.StyleParamWithLocation("simple", false, "X-Device-ID", runtime.ParamLocationHeader, *params.XDeviceID)
		if err != nil {
			return nil, err
		}

		req.Header.Set("X-Device-ID", headerParam3)
	}

	return req, nil
}

// NewCashWithdrawalApiV1ReceiptsCashWithdrawalPostRequest calls the generic CashWithdrawalApiV1ReceiptsCashWithdrawalPost builder with application/json body
func NewCashWithdrawalApiV1ReceiptsCashWithdrawalPostRequest(server string, params *CashWithdrawalApiV1ReceiptsCashWithdrawalPostParams, body CashWithdrawalApiV1ReceiptsCashWithdrawalPostJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCashWithdrawalApiV1ReceiptsCashWithdrawalPostRequestWithBody(server, params, "application/json", bodyReader)
}

// NewCashWithdrawalApiV1ReceiptsCashWithdrawalPostRequestWithBody generates requests for CashWithdrawalApiV1ReceiptsCashWithdrawalPost with any type of body
func NewCashWithdrawalApiV1ReceiptsCashWithdrawalPostRequestWithBody(server string, params *CashWithdrawalApiV1ReceiptsCashWithdrawalPostParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/receipts/cash-withdrawal")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params.XClientName != nil {
		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Client-Name", runtime.ParamLocationHeader, *params.XClientName)
		if err != nil {
			return nil, err
		}

		req.Header.Set("X-Client-Name", headerParam0)
	}

	if params.XClientVersion != nil {
		var headerParam1 string

		headerParam1, err = runtime.StyleParamWithLocation("simple", false, "X-Client-Version", runtime.ParamLocationHeader, *params.XClientVersion)
		if err != nil {
			return nil, err
		}

		req.Header.Set("X-Client-Version", headerParam1)
	}

	if params.XAccessKey != nil {
		var headerParam2 string

		headerParam2, err = runtime.StyleParamWithLocation("simple", false, "X-Access-Key", runtime.ParamLocationHeader, *params.XAccessKey)
		if err != nil {
			return nil, err
		}

		req.Header.Set("X-Access-Key", headerParam2)
	}

	if params.XDeviceID != nil {
		var headerParam3 string

		headerParam3, err = runtime.StyleParamWithLocation("simple", false, "X-Device-ID", runtime.ParamLocationHeader, *params.XDeviceID)
		if err != nil {
			return nil, err
		}

		req.Header.Set("X-Device-ID", headerParam3)
	}

	return req, nil
}

// NewExchangeApiV1ReceiptsCurrencyExchangePostRequest calls the generic ExchangeApiV1ReceiptsCurrencyExchangePost builder with application/json body
func NewExchangeApiV1ReceiptsCurrencyExchangePostRequest(server string, params *ExchangeApiV1ReceiptsCurrencyExchangePostParams, body ExchangeApiV1ReceiptsCurrencyExchangePostJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewExchangeApiV1ReceiptsCurrencyExchangePostRequestWithBody(server, params, "application/json", bodyReader)
}

// NewExchangeApiV1ReceiptsCurrencyExchangePostRequestWithBody generates requests for ExchangeApiV1ReceiptsCurrencyExchangePost with any type of body
func NewExchangeApiV1ReceiptsCurrencyExchangePostRequestWithBody(server string, params *ExchangeApiV1ReceiptsCurrencyExchangePostParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/receipts/currency-exchange")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params.XClientName != nil {
		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Client-Name", runtime.ParamLocationHeader, *params.XClientName)
		if err != nil {
			return nil, err
		}

		req.Header.Set("X-Client-Name", headerParam0)
	}

	if params.XClientVersion != nil {
		var headerParam1 string

		headerParam1, err = runtime.StyleParamWithLocation("simple", false, "X-Client-Version", runtime.ParamLocationHeader, *params.XClientVersion)
		if err != nil {
			return nil, err
		}

		req.Header.Set("X-Client-Version", headerParam1)
	}

	if params.XAccessKey != nil {
		var headerParam2 string

		headerParam2, err = runtime.StyleParamWithLocation("simple", false, "X-Access-Key", runtime.ParamLocationHeader, *params.XAccessKey)
		if err != nil {
			return nil, err
		}

		req.Header.Set("X-Access-Key", headerParam2)
	}

	return req, nil
}

// NewGetReceiptsSearchApiV1ReceiptsSearchGetRequest generates requests for GetReceiptsSearchApiV1ReceiptsSearchGet
func NewGetReceiptsSearchApiV1ReceiptsSearchGetRequest(server string, params *GetReceiptsSearchApiV1ReceiptsSearchGetParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/receipts/search")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.FiscalCode != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "fiscal_code", runtime.ParamLocationQuery, *params.FiscalCode); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Barcode != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "barcode", runtime.ParamLocationQuery, *params.Barcode); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.ShiftId != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "shift_id", runtime.ParamLocationQuery, *params.ShiftId); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.BranchId != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "branch_id", runtime.ParamLocationQuery, *params.BranchId); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.CashRegisterId != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "cash_register_id", runtime.ParamLocationQuery, *params.CashRegisterId); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.FromDate != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "from_date", runtime.ParamLocationQuery, *params.FromDate); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.ToDate != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "to_date", runtime.ParamLocationQuery, *params.ToDate); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Desc != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "desc", runtime.ParamLocationQuery, *params.Desc); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.SelfReceipts != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "self_receipts", runtime.ParamLocationQuery, *params.SelfReceipts); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Limit != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Offset != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params.XClientName != nil {
		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Client-Name", runtime.ParamLocationHeader, *params.XClientName)
		if err != nil {
			return nil, err
		}

		req.Header.Set("X-Client-Name", headerParam0)
	}

	if params.XClientVersion != nil {
		var headerParam1 string

		headerParam1, err = runtime.StyleParamWithLocation("simple", false, "X-Client-Version", runtime.ParamLocationHeader, *params.XClientVersion)
		if err != nil {
			return nil, err
		}

		req.Header.Set("X-Client-Version", headerParam1)
	}

	if params.XAccessKey != nil {
		var headerParam2 string

		headerParam2, err = runtime.StyleParamWithLocation("simple", false, "X-Access-Key", runtime.ParamLocationHeader, *params.XAccessKey)
		if err != nil {
			return nil, err
		}

		req.Header.Set("X-Access-Key", headerParam2)
	}

	return req, nil
}

// NewCreateReceiptApiV1ReceiptsSellPostRequest calls the generic CreateReceiptApiV1ReceiptsSellPost builder with application/json body
func NewCreateReceiptApiV1ReceiptsSellPostRequest(server string, params *CreateReceiptApiV1ReceiptsSellPostParams, body CreateReceiptApiV1ReceiptsSellPostJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateReceiptApiV1ReceiptsSellPostRequestWithBody(server, params, "application/json", bodyReader)
}

// NewCreateReceiptApiV1ReceiptsSellPostRequestWithBody generates requests for CreateReceiptApiV1ReceiptsSellPost with any type of body
func NewCreateReceiptApiV1ReceiptsSellPostRequestWithBody(server string, params *CreateReceiptApiV1ReceiptsSellPostParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/receipts/sell")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params.XClientName != nil {
		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Client-Name", runtime.ParamLocationHeader, *params.XClientName)
		if err != nil {
			return nil, err
		}

		req.Header.Set("X-Client-Name", headerParam0)
	}

	if params.XClientVersion != nil {
		var headerParam1 string

		headerParam1, err = runtime.StyleParamWithLocation("simple", false, "X-Client-Version", runtime.ParamLocationHeader, *params.XClientVersion)
		if err != nil {
			return nil, err
		}

		req.Header.Set("X-Client-Version", headerParam1)
	}

	if params.XAccessKey != nil {
		var headerParam2 string

		headerParam2, err = runtime.StyleParamWithLocation("simple", false, "X-Access-Key", runtime.ParamLocationHeader, *params.XAccessKey)
		if err != nil {
			return nil, err
		}

		req.Header.Set("X-Access-Key", headerParam2)
	}

	if params.XDeviceID != nil {
		var headerParam3 string

		headerParam3, err = runtime.StyleParamWithLocation("simple", false, "X-Device-ID", runtime.ParamLocationHeader, *params.XDeviceID)
		if err != nil {
			return nil, err
		}

		req.Header.Set("X-Device-ID", headerParam3)
	}

	return req, nil
}

// NewCreateOfflineReceiptApiV1ReceiptsSellOfflinePostRequest calls the generic CreateOfflineReceiptApiV1ReceiptsSellOfflinePost builder with application/json body
func NewCreateOfflineReceiptApiV1ReceiptsSellOfflinePostRequest(server string, params *CreateOfflineReceiptApiV1ReceiptsSellOfflinePostParams, body CreateOfflineReceiptApiV1ReceiptsSellOfflinePostJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateOfflineReceiptApiV1ReceiptsSellOfflinePostRequestWithBody(server, params, "application/json", bodyReader)
}

// NewCreateOfflineReceiptApiV1ReceiptsSellOfflinePostRequestWithBody generates requests for CreateOfflineReceiptApiV1ReceiptsSellOfflinePost with any type of body
func NewCreateOfflineReceiptApiV1ReceiptsSellOfflinePostRequestWithBody(server string, params *CreateOfflineReceiptApiV1ReceiptsSellOfflinePostParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/receipts/sell-offline")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params.XClientName != nil {
		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Client-Name", runtime.ParamLocationHeader, *params.XClientName)
		if err != nil {
			return nil, err
		}

		req.Header.Set("X-Client-Name", headerParam0)
	}

	if params.XClientVersion != nil {
		var headerParam1 string

		headerParam1, err = runtime.StyleParamWithLocation("simple", false, "X-Client-Version", runtime.ParamLocationHeader, *params.XClientVersion)
		if err != nil {
			return nil, err
		}

		req.Header.Set("X-Client-Version", headerParam1)
	}

	if params.XAccessKey != nil {
		var headerParam2 string

		headerParam2, err = runtime.StyleParamWithLocation("simple", false, "X-Access-Key", runtime.ParamLocationHeader, *params.XAccessKey)
		if err != nil {
			return nil, err
		}

		req.Header.Set("X-Access-Key", headerParam2)
	}

	if params.XDeviceID != nil {
		var headerParam3 string

		headerParam3, err = runtime.StyleParamWithLocation("simple", false, "X-Device-ID", runtime.ParamLocationHeader, *params.XDeviceID)
		if err != nil {
			return nil, err
		}

		req.Header.Set("X-Device-ID", headerParam3)
	}

	return req, nil
}

// NewCreateServiceReceiptApiV1ReceiptsServicePostRequest calls the generic CreateServiceReceiptApiV1ReceiptsServicePost builder with application/json body
func NewCreateServiceReceiptApiV1ReceiptsServicePostRequest(server string, params *CreateServiceReceiptApiV1ReceiptsServicePostParams, body CreateServiceReceiptApiV1ReceiptsServicePostJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateServiceReceiptApiV1ReceiptsServicePostRequestWithBody(server, params, "application/json", bodyReader)
}

// NewCreateServiceReceiptApiV1ReceiptsServicePostRequestWithBody generates requests for CreateServiceReceiptApiV1ReceiptsServicePost with any type of body
func NewCreateServiceReceiptApiV1ReceiptsServicePostRequestWithBody(server string, params *CreateServiceReceiptApiV1ReceiptsServicePostParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/receipts/service")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params.XClientName != nil {
		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Client-Name", runtime.ParamLocationHeader, *params.XClientName)
		if err != nil {
			return nil, err
		}

		req.Header.Set("X-Client-Name", headerParam0)
	}

	if params.XClientVersion != nil {
		var headerParam1 string

		headerParam1, err = runtime.StyleParamWithLocation("simple", false, "X-Client-Version", runtime.ParamLocationHeader, *params.XClientVersion)
		if err != nil {
			return nil, err
		}

		req.Header.Set("X-Client-Version", headerParam1)
	}

	if params.XAccessKey != nil {
		var headerParam2 string

		headerParam2, err = runtime.StyleParamWithLocation("simple", false, "X-Access-Key", runtime.ParamLocationHeader, *params.XAccessKey)
		if err != nil {
			return nil, err
		}

		req.Header.Set("X-Access-Key", headerParam2)
	}

	if params.XDeviceID != nil {
		var headerParam3 string

		headerParam3, err = runtime.StyleParamWithLocation("simple", false, "X-Device-ID", runtime.ParamLocationHeader, *params.XDeviceID)
		if err != nil {
			return nil, err
		}

		req.Header.Set("X-Device-ID", headerParam3)
	}

	return req, nil
}

// NewCreateServiceCurrencyReceiptApiV1ReceiptsServiceCurrencyPostRequest calls the generic CreateServiceCurrencyReceiptApiV1ReceiptsServiceCurrencyPost builder with application/json body
func NewCreateServiceCurrencyReceiptApiV1ReceiptsServiceCurrencyPostRequest(server string, params *CreateServiceCurrencyReceiptApiV1ReceiptsServiceCurrencyPostParams, body CreateServiceCurrencyReceiptApiV1ReceiptsServiceCurrencyPostJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateServiceCurrencyReceiptApiV1ReceiptsServiceCurrencyPostRequestWithBody(server, params, "application/json", bodyReader)
}

// NewCreateServiceCurrencyReceiptApiV1ReceiptsServiceCurrencyPostRequestWithBody generates requests for CreateServiceCurrencyReceiptApiV1ReceiptsServiceCurrencyPost with any type of body
func NewCreateServiceCurrencyReceiptApiV1ReceiptsServiceCurrencyPostRequestWithBody(server string, params *CreateServiceCurrencyReceiptApiV1ReceiptsServiceCurrencyPostParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/receipts/service-currency")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params.XClientName != nil {
		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Client-Name", runtime.ParamLocationHeader, *params.XClientName)
		if err != nil {
			return nil, err
		}

		req.Header.Set("X-Client-Name", headerParam0)
	}

	if params.XClientVersion != nil {
		var headerParam1 string

		headerParam1, err = runtime.StyleParamWithLocation("simple", false, "X-Client-Version", runtime.ParamLocationHeader, *params.XClientVersion)
		if err != nil {
			return nil, err
		}

		req.Header.Set("X-Client-Version", headerParam1)
	}

	if params.XAccessKey != nil {
		var headerParam2 string

		headerParam2, err = runtime.StyleParamWithLocation("simple", false, "X-Access-Key", runtime.ParamLocationHeader, *params.XAccessKey)
		if err != nil {
			return nil, err
		}

		req.Header.Set("X-Access-Key", headerParam2)
	}

	return req, nil
}

// NewGetReceiptApiV1ReceiptsReceiptIdGetRequest generates requests for GetReceiptApiV1ReceiptsReceiptIdGet
func NewGetReceiptApiV1ReceiptsReceiptIdGetRequest(server string, receiptId struct {
	union json.RawMessage
}, params *GetReceiptApiV1ReceiptsReceiptIdGetParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "receipt_id", runtime.ParamLocationPath, receiptId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/receipts/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params.XClientName != nil {
		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Client-Name", runtime.ParamLocationHeader, *params.XClientName)
		if err != nil {
			return nil, err
		}

		req.Header.Set("X-Client-Name", headerParam0)
	}

	if params.XClientVersion != nil {
		var headerParam1 string

		headerParam1, err = runtime.StyleParamWithLocation("simple", false, "X-Client-Version", runtime.ParamLocationHeader, *params.XClientVersion)
		if err != nil {
			return nil, err
		}

		req.Header.Set("X-Client-Version", headerParam1)
	}

	if params.XAccessKey != nil {
		var headerParam2 string

		headerParam2, err = runtime.StyleParamWithLocation("simple", false, "X-Access-Key", runtime.ParamLocationHeader, *params.XAccessKey)
		if err != nil {
			return nil, err
		}

		req.Header.Set("X-Access-Key", headerParam2)
	}

	return req, nil
}

// NewSendReceiptToEmailApiV1ReceiptsReceiptIdEmailPostRequest calls the generic SendReceiptToEmailApiV1ReceiptsReceiptIdEmailPost builder with application/json body
func NewSendReceiptToEmailApiV1ReceiptsReceiptIdEmailPostRequest(server string, receiptId struct {
	union json.RawMessage
}, params *SendReceiptToEmailApiV1ReceiptsReceiptIdEmailPostParams, body SendReceiptToEmailApiV1ReceiptsReceiptIdEmailPostJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewSendReceiptToEmailApiV1ReceiptsReceiptIdEmailPostRequestWithBody(server, receiptId, params, "application/json", bodyReader)
}

// NewSendReceiptToEmailApiV1ReceiptsReceiptIdEmailPostRequestWithBody generates requests for SendReceiptToEmailApiV1ReceiptsReceiptIdEmailPost with any type of body
func NewSendReceiptToEmailApiV1ReceiptsReceiptIdEmailPostRequestWithBody(server string, receiptId struct {
	union json.RawMessage
}, params *SendReceiptToEmailApiV1ReceiptsReceiptIdEmailPostParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "receipt_id", runtime.ParamLocationPath, receiptId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/receipts/%s/email", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params.XClientName != nil {
		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Client-Name", runtime.ParamLocationHeader, *params.XClientName)
		if err != nil {
			return nil, err
		}

		req.Header.Set("X-Client-Name", headerParam0)
	}

	if params.XClientVersion != nil {
		var headerParam1 string

		headerParam1, err = runtime.StyleParamWithLocation("simple", false, "X-Client-Version", runtime.ParamLocationHeader, *params.XClientVersion)
		if err != nil {
			return nil, err
		}

		req.Header.Set("X-Client-Version", headerParam1)
	}

	if params.XAccessKey != nil {
		var headerParam2 string

		headerParam2, err = runtime.StyleParamWithLocation("simple", false, "X-Access-Key", runtime.ParamLocationHeader, *params.XAccessKey)
		if err != nil {
			return nil, err
		}

		req.Header.Set("X-Access-Key", headerParam2)
	}

	return req, nil
}

// NewGetReceiptHtmlApiV1ReceiptsReceiptIdHtmlGetRequest generates requests for GetReceiptHtmlApiV1ReceiptsReceiptIdHtmlGet
func NewGetReceiptHtmlApiV1ReceiptsReceiptIdHtmlGetRequest(server string, receiptId struct {
	union json.RawMessage
}, params *GetReceiptHtmlApiV1ReceiptsReceiptIdHtmlGetParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "receipt_id", runtime.ParamLocationPath, receiptId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/receipts/%s/html", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Simple != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "simple", runtime.ParamLocationQuery, *params.Simple); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params.XClientName != nil {
		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Client-Name", runtime.ParamLocationHeader, *params.XClientName)
		if err != nil {
			return nil, err
		}

		req.Header.Set("X-Client-Name", headerParam0)
	}

	if params.XClientVersion != nil {
		var headerParam1 string

		headerParam1, err = runtime.StyleParamWithLocation("simple", false, "X-Client-Version", runtime.ParamLocationHeader, *params.XClientVersion)
		if err != nil {
			return nil, err
		}

		req.Header.Set("X-Client-Version", headerParam1)
	}

	if params.XAccessKey != nil {
		var headerParam2 string

		headerParam2, err = runtime.StyleParamWithLocation("simple", false, "X-Access-Key", runtime.ParamLocationHeader, *params.XAccessKey)
		if err != nil {
			return nil, err
		}

		req.Header.Set("X-Access-Key", headerParam2)
	}

	return req, nil
}

// NewGetReceiptPdfApiV1ReceiptsReceiptIdPdfGetRequest generates requests for GetReceiptPdfApiV1ReceiptsReceiptIdPdfGet
func NewGetReceiptPdfApiV1ReceiptsReceiptIdPdfGetRequest(server string, receiptId struct {
	union json.RawMessage
}, params *GetReceiptPdfApiV1ReceiptsReceiptIdPdfGetParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "receipt_id", runtime.ParamLocationPath, receiptId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/receipts/%s/pdf", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params.XClientName != nil {
		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Client-Name", runtime.ParamLocationHeader, *params.XClientName)
		if err != nil {
			return nil, err
		}

		req.Header.Set("X-Client-Name", headerParam0)
	}

	if params.XClientVersion != nil {
		var headerParam1 string

		headerParam1, err = runtime.StyleParamWithLocation("simple", false, "X-Client-Version", runtime.ParamLocationHeader, *params.XClientVersion)
		if err != nil {
			return nil, err
		}

		req.Header.Set("X-Client-Version", headerParam1)
	}

	if params.XAccessKey != nil {
		var headerParam2 string

		headerParam2, err = runtime.StyleParamWithLocation("simple", false, "X-Access-Key", runtime.ParamLocationHeader, *params.XAccessKey)
		if err != nil {
			return nil, err
		}

		req.Header.Set("X-Access-Key", headerParam2)
	}

	return req, nil
}

// NewGetReceiptPngApiV1ReceiptsReceiptIdPngGetRequest generates requests for GetReceiptPngApiV1ReceiptsReceiptIdPngGet
func NewGetReceiptPngApiV1ReceiptsReceiptIdPngGetRequest(server string, receiptId struct {
	union json.RawMessage
}, params *GetReceiptPngApiV1ReceiptsReceiptIdPngGetParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "receipt_id", runtime.ParamLocationPath, receiptId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/receipts/%s/png", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Width != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "width", runtime.ParamLocationQuery, *params.Width); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.PaperWidth != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "paper_width", runtime.ParamLocationQuery, *params.PaperWidth); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.QrcodeScale != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "qrcode_scale", runtime.ParamLocationQuery, *params.QrcodeScale); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params.XClientName != nil {
		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Client-Name", runtime.ParamLocationHeader, *params.XClientName)
		if err != nil {
			return nil, err
		}

		req.Header.Set("X-Client-Name", headerParam0)
	}

	if params.XClientVersion != nil {
		var headerParam1 string

		headerParam1, err = runtime.StyleParamWithLocation("simple", false, "X-Client-Version", runtime.ParamLocationHeader, *params.XClientVersion)
		if err != nil {
			return nil, err
		}

		req.Header.Set("X-Client-Version", headerParam1)
	}

	if params.XAccessKey != nil {
		var headerParam2 string

		headerParam2, err = runtime.StyleParamWithLocation("simple", false, "X-Access-Key", runtime.ParamLocationHeader, *params.XAccessKey)
		if err != nil {
			return nil, err
		}

		req.Header.Set("X-Access-Key", headerParam2)
	}

	return req, nil
}

// NewGetReceiptQrCodeImageApiV1ReceiptsReceiptIdQrcodeGetRequest generates requests for GetReceiptQrCodeImageApiV1ReceiptsReceiptIdQrcodeGet
func NewGetReceiptQrCodeImageApiV1ReceiptsReceiptIdQrcodeGetRequest(server string, receiptId struct {
	union json.RawMessage
}, params *GetReceiptQrCodeImageApiV1ReceiptsReceiptIdQrcodeGetParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "receipt_id", runtime.ParamLocationPath, receiptId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/receipts/%s/qrcode", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params.XClientName != nil {
		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Client-Name", runtime.ParamLocationHeader, *params.XClientName)
		if err != nil {
			return nil, err
		}

		req.Header.Set("X-Client-Name", headerParam0)
	}

	if params.XClientVersion != nil {
		var headerParam1 string

		headerParam1, err = runtime.StyleParamWithLocation("simple", false, "X-Client-Version", runtime.ParamLocationHeader, *params.XClientVersion)
		if err != nil {
			return nil, err
		}

		req.Header.Set("X-Client-Version", headerParam1)
	}

	if params.XAccessKey != nil {
		var headerParam2 string

		headerParam2, err = runtime.StyleParamWithLocation("simple", false, "X-Access-Key", runtime.ParamLocationHeader, *params.XAccessKey)
		if err != nil {
			return nil, err
		}

		req.Header.Set("X-Access-Key", headerParam2)
	}

	return req, nil
}

// NewSendReceiptViaSmsApiV1ReceiptsReceiptIdSmsPostRequest calls the generic SendReceiptViaSmsApiV1ReceiptsReceiptIdSmsPost builder with application/json body
func NewSendReceiptViaSmsApiV1ReceiptsReceiptIdSmsPostRequest(server string, receiptId struct {
	union json.RawMessage
}, params *SendReceiptViaSmsApiV1ReceiptsReceiptIdSmsPostParams, body SendReceiptViaSmsApiV1ReceiptsReceiptIdSmsPostJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewSendReceiptViaSmsApiV1ReceiptsReceiptIdSmsPostRequestWithBody(server, receiptId, params, "application/json", bodyReader)
}

// NewSendReceiptViaSmsApiV1ReceiptsReceiptIdSmsPostRequestWithBody generates requests for SendReceiptViaSmsApiV1ReceiptsReceiptIdSmsPost with any type of body
func NewSendReceiptViaSmsApiV1ReceiptsReceiptIdSmsPostRequestWithBody(server string, receiptId struct {
	union json.RawMessage
}, params *SendReceiptViaSmsApiV1ReceiptsReceiptIdSmsPostParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "receipt_id", runtime.ParamLocationPath, receiptId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/receipts/%s/sms", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params.XClientName != nil {
		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Client-Name", runtime.ParamLocationHeader, *params.XClientName)
		if err != nil {
			return nil, err
		}

		req.Header.Set("X-Client-Name", headerParam0)
	}

	if params.XClientVersion != nil {
		var headerParam1 string

		headerParam1, err = runtime.StyleParamWithLocation("simple", false, "X-Client-Version", runtime.ParamLocationHeader, *params.XClientVersion)
		if err != nil {
			return nil, err
		}

		req.Header.Set("X-Client-Version", headerParam1)
	}

	if params.XAccessKey != nil {
		var headerParam2 string

		headerParam2, err = runtime.StyleParamWithLocation("simple", false, "X-Access-Key", runtime.ParamLocationHeader, *params.XAccessKey)
		if err != nil {
			return nil, err
		}

		req.Header.Set("X-Access-Key", headerParam2)
	}

	return req, nil
}

// NewGetReceiptTextApiV1ReceiptsReceiptIdTextGetRequest generates requests for GetReceiptTextApiV1ReceiptsReceiptIdTextGet
func NewGetReceiptTextApiV1ReceiptsReceiptIdTextGetRequest(server string, receiptId struct {
	union json.RawMessage
}, params *GetReceiptTextApiV1ReceiptsReceiptIdTextGetParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "receipt_id", runtime.ParamLocationPath, receiptId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/receipts/%s/text", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Width != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "width", runtime.ParamLocationQuery, *params.Width); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params.XClientName != nil {
		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Client-Name", runtime.ParamLocationHeader, *params.XClientName)
		if err != nil {
			return nil, err
		}

		req.Header.Set("X-Client-Name", headerParam0)
	}

	if params.XClientVersion != nil {
		var headerParam1 string

		headerParam1, err = runtime.StyleParamWithLocation("simple", false, "X-Client-Version", runtime.ParamLocationHeader, *params.XClientVersion)
		if err != nil {
			return nil, err
		}

		req.Header.Set("X-Client-Version", headerParam1)
	}

	if params.XAccessKey != nil {
		var headerParam2 string

		headerParam2, err = runtime.StyleParamWithLocation("simple", false, "X-Access-Key", runtime.ParamLocationHeader, *params.XAccessKey)
		if err != nil {
			return nil, err
		}

		req.Header.Set("X-Access-Key", headerParam2)
	}

	return req, nil
}

// NewGetReceiptXmlApiV1ReceiptsReceiptIdXmlGetRequest generates requests for GetReceiptXmlApiV1ReceiptsReceiptIdXmlGet
func NewGetReceiptXmlApiV1ReceiptsReceiptIdXmlGetRequest(server string, receiptId struct {
	union json.RawMessage
}, params *GetReceiptXmlApiV1ReceiptsReceiptIdXmlGetParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "receipt_id", runtime.ParamLocationPath, receiptId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/receipts/%s/xml", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params.XClientName != nil {
		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Client-Name", runtime.ParamLocationHeader, *params.XClientName)
		if err != nil {
			return nil, err
		}

		req.Header.Set("X-Client-Name", headerParam0)
	}

	if params.XClientVersion != nil {
		var headerParam1 string

		headerParam1, err = runtime.StyleParamWithLocation("simple", false, "X-Client-Version", runtime.ParamLocationHeader, *params.XClientVersion)
		if err != nil {
			return nil, err
		}

		req.Header.Set("X-Client-Version", headerParam1)
	}

	if params.XAccessKey != nil {
		var headerParam2 string

		headerParam2, err = runtime.StyleParamWithLocation("simple", false, "X-Access-Key", runtime.ParamLocationHeader, *params.XAccessKey)
		if err != nil {
			return nil, err
		}

		req.Header.Set("X-Access-Key", headerParam2)
	}

	return req, nil
}

// NewGetReportsApiV1ReportsGetRequest generates requests for GetReportsApiV1ReportsGet
func NewGetReportsApiV1ReportsGetRequest(server string, params *GetReportsApiV1ReportsGetParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/reports")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.FromDate != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "from_date", runtime.ParamLocationQuery, *params.FromDate); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.ToDate != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "to_date", runtime.ParamLocationQuery, *params.ToDate); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.ShiftId != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "shift_id", runtime.ParamLocationQuery, *params.ShiftId); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Serial != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "serial", runtime.ParamLocationQuery, *params.Serial); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.IsZReport != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "is_z_report", runtime.ParamLocationQuery, *params.IsZReport); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Desc != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "desc", runtime.ParamLocationQuery, *params.Desc); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Limit != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Offset != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params.XClientName != nil {
		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Client-Name", runtime.ParamLocationHeader, *params.XClientName)
		if err != nil {
			return nil, err
		}

		req.Header.Set("X-Client-Name", headerParam0)
	}

	if params.XClientVersion != nil {
		var headerParam1 string

		headerParam1, err = runtime.StyleParamWithLocation("simple", false, "X-Client-Version", runtime.ParamLocationHeader, *params.XClientVersion)
		if err != nil {
			return nil, err
		}

		req.Header.Set("X-Client-Version", headerParam1)
	}

	if params.XAccessKey != nil {
		var headerParam2 string

		headerParam2, err = runtime.StyleParamWithLocation("simple", false, "X-Access-Key", runtime.ParamLocationHeader, *params.XAccessKey)
		if err != nil {
			return nil, err
		}

		req.Header.Set("X-Access-Key", headerParam2)
	}

	return req, nil
}

// NewCreateXReportApiV1ReportsPostRequest generates requests for CreateXReportApiV1ReportsPost
func NewCreateXReportApiV1ReportsPostRequest(server string, params *CreateXReportApiV1ReportsPostParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/reports")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params.XClientName != nil {
		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Client-Name", runtime.ParamLocationHeader, *params.XClientName)
		if err != nil {
			return nil, err
		}

		req.Header.Set("X-Client-Name", headerParam0)
	}

	if params.XClientVersion != nil {
		var headerParam1 string

		headerParam1, err = runtime.StyleParamWithLocation("simple", false, "X-Client-Version", runtime.ParamLocationHeader, *params.XClientVersion)
		if err != nil {
			return nil, err
		}

		req.Header.Set("X-Client-Version", headerParam1)
	}

	if params.XAccessKey != nil {
		var headerParam2 string

		headerParam2, err = runtime.StyleParamWithLocation("simple", false, "X-Access-Key", runtime.ParamLocationHeader, *params.XAccessKey)
		if err != nil {
			return nil, err
		}

		req.Header.Set("X-Access-Key", headerParam2)
	}

	return req, nil
}

// NewAddExternalReportApiV1ReportsAddExternalPostRequest calls the generic AddExternalReportApiV1ReportsAddExternalPost builder with application/json body
func NewAddExternalReportApiV1ReportsAddExternalPostRequest(server string, params *AddExternalReportApiV1ReportsAddExternalPostParams, body AddExternalReportApiV1ReportsAddExternalPostJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewAddExternalReportApiV1ReportsAddExternalPostRequestWithBody(server, params, "application/json", bodyReader)
}

// NewAddExternalReportApiV1ReportsAddExternalPostRequestWithBody generates requests for AddExternalReportApiV1ReportsAddExternalPost with any type of body
func NewAddExternalReportApiV1ReportsAddExternalPostRequestWithBody(server string, params *AddExternalReportApiV1ReportsAddExternalPostParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/reports/add-external")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params.XClientName != nil {
		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Client-Name", runtime.ParamLocationHeader, *params.XClientName)
		if err != nil {
			return nil, err
		}

		req.Header.Set("X-Client-Name", headerParam0)
	}

	if params.XClientVersion != nil {
		var headerParam1 string

		headerParam1, err = runtime.StyleParamWithLocation("simple", false, "X-Client-Version", runtime.ParamLocationHeader, *params.XClientVersion)
		if err != nil {
			return nil, err
		}

		req.Header.Set("X-Client-Version", headerParam1)
	}

	if params.XAccessKey != nil {
		var headerParam2 string

		headerParam2, err = runtime.StyleParamWithLocation("simple", false, "X-Access-Key", runtime.ParamLocationHeader, *params.XAccessKey)
		if err != nil {
			return nil, err
		}

		req.Header.Set("X-Access-Key", headerParam2)
	}

	return req, nil
}

// NewGetPeriodicalReportApiV1ReportsPeriodicalGetRequest generates requests for GetPeriodicalReportApiV1ReportsPeriodicalGet
func NewGetPeriodicalReportApiV1ReportsPeriodicalGetRequest(server string, params *GetPeriodicalReportApiV1ReportsPeriodicalGetParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/reports/periodical")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "from_date", runtime.ParamLocationQuery, params.FromDate); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "to_date", runtime.ParamLocationQuery, params.ToDate); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	if params.Width != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "width", runtime.ParamLocationQuery, *params.Width); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params.XClientName != nil {
		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Client-Name", runtime.ParamLocationHeader, *params.XClientName)
		if err != nil {
			return nil, err
		}

		req.Header.Set("X-Client-Name", headerParam0)
	}

	if params.XClientVersion != nil {
		var headerParam1 string

		headerParam1, err = runtime.StyleParamWithLocation("simple", false, "X-Client-Version", runtime.ParamLocationHeader, *params.XClientVersion)
		if err != nil {
			return nil, err
		}

		req.Header.Set("X-Client-Version", headerParam1)
	}

	if params.XAccessKey != nil {
		var headerParam2 string

		headerParam2, err = runtime.StyleParamWithLocation("simple", false, "X-Access-Key", runtime.ParamLocationHeader, *params.XAccessKey)
		if err != nil {
			return nil, err
		}

		req.Header.Set("X-Access-Key", headerParam2)
	}

	var headerParam3 string

	headerParam3, err = runtime.StyleParamWithLocation("simple", false, "X-License-Key", runtime.ParamLocationHeader, params.XLicenseKey)
	if err != nil {
		return nil, err
	}

	req.Header.Set("X-License-Key", headerParam3)

	return req, nil
}

// NewGetSearchReportsApiV1ReportsSearchGetRequest generates requests for GetSearchReportsApiV1ReportsSearchGet
func NewGetSearchReportsApiV1ReportsSearchGetRequest(server string, params *GetSearchReportsApiV1ReportsSearchGetParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/reports/search")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.FromDate != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "from_date", runtime.ParamLocationQuery, *params.FromDate); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.ToDate != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "to_date", runtime.ParamLocationQuery, *params.ToDate); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.ShiftId != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "shift_id", runtime.ParamLocationQuery, *params.ShiftId); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Serial != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "serial", runtime.ParamLocationQuery, *params.Serial); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.IsZReport != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "is_z_report", runtime.ParamLocationQuery, *params.IsZReport); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Desc != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "desc", runtime.ParamLocationQuery, *params.Desc); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.CashRegisterId != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "cash_register_id", runtime.ParamLocationQuery, *params.CashRegisterId); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Limit != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Offset != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params.XClientName != nil {
		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Client-Name", runtime.ParamLocationHeader, *params.XClientName)
		if err != nil {
			return nil, err
		}

		req.Header.Set("X-Client-Name", headerParam0)
	}

	if params.XClientVersion != nil {
		var headerParam1 string

		headerParam1, err = runtime.StyleParamWithLocation("simple", false, "X-Client-Version", runtime.ParamLocationHeader, *params.XClientVersion)
		if err != nil {
			return nil, err
		}

		req.Header.Set("X-Client-Version", headerParam1)
	}

	if params.XAccessKey != nil {
		var headerParam2 string

		headerParam2, err = runtime.StyleParamWithLocation("simple", false, "X-Access-Key", runtime.ParamLocationHeader, *params.XAccessKey)
		if err != nil {
			return nil, err
		}

		req.Header.Set("X-Access-Key", headerParam2)
	}

	return req, nil
}

// NewGetReportApiV1ReportsReportIdGetRequest generates requests for GetReportApiV1ReportsReportIdGet
func NewGetReportApiV1ReportsReportIdGetRequest(server string, reportId openapi_types.UUID, params *GetReportApiV1ReportsReportIdGetParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "report_id", runtime.ParamLocationPath, reportId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/reports/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params.XClientName != nil {
		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Client-Name", runtime.ParamLocationHeader, *params.XClientName)
		if err != nil {
			return nil, err
		}

		req.Header.Set("X-Client-Name", headerParam0)
	}

	if params.XClientVersion != nil {
		var headerParam1 string

		headerParam1, err = runtime.StyleParamWithLocation("simple", false, "X-Client-Version", runtime.ParamLocationHeader, *params.XClientVersion)
		if err != nil {
			return nil, err
		}

		req.Header.Set("X-Client-Version", headerParam1)
	}

	if params.XAccessKey != nil {
		var headerParam2 string

		headerParam2, err = runtime.StyleParamWithLocation("simple", false, "X-Access-Key", runtime.ParamLocationHeader, *params.XAccessKey)
		if err != nil {
			return nil, err
		}

		req.Header.Set("X-Access-Key", headerParam2)
	}

	return req, nil
}

// NewGetReportTextApiV1ReportsReportIdTextGetRequest generates requests for GetReportTextApiV1ReportsReportIdTextGet
func NewGetReportTextApiV1ReportsReportIdTextGetRequest(server string, reportId openapi_types.UUID, params *GetReportTextApiV1ReportsReportIdTextGetParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "report_id", runtime.ParamLocationPath, reportId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/reports/%s/text", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Width != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "width", runtime.ParamLocationQuery, *params.Width); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params.XClientName != nil {
		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Client-Name", runtime.ParamLocationHeader, *params.XClientName)
		if err != nil {
			return nil, err
		}

		req.Header.Set("X-Client-Name", headerParam0)
	}

	if params.XClientVersion != nil {
		var headerParam1 string

		headerParam1, err = runtime.StyleParamWithLocation("simple", false, "X-Client-Version", runtime.ParamLocationHeader, *params.XClientVersion)
		if err != nil {
			return nil, err
		}

		req.Header.Set("X-Client-Version", headerParam1)
	}

	if params.XAccessKey != nil {
		var headerParam2 string

		headerParam2, err = runtime.StyleParamWithLocation("simple", false, "X-Access-Key", runtime.ParamLocationHeader, *params.XAccessKey)
		if err != nil {
			return nil, err
		}

		req.Header.Set("X-Access-Key", headerParam2)
	}

	return req, nil
}

// NewGetShiftsApiV1ShiftsGetRequest generates requests for GetShiftsApiV1ShiftsGet
func NewGetShiftsApiV1ShiftsGetRequest(server string, params *GetShiftsApiV1ShiftsGetParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/shifts")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Statuses != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "statuses", runtime.ParamLocationQuery, *params.Statuses); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Desc != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "desc", runtime.ParamLocationQuery, *params.Desc); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Limit != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Offset != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params.XClientName != nil {
		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Client-Name", runtime.ParamLocationHeader, *params.XClientName)
		if err != nil {
			return nil, err
		}

		req.Header.Set("X-Client-Name", headerParam0)
	}

	if params.XClientVersion != nil {
		var headerParam1 string

		headerParam1, err = runtime.StyleParamWithLocation("simple", false, "X-Client-Version", runtime.ParamLocationHeader, *params.XClientVersion)
		if err != nil {
			return nil, err
		}

		req.Header.Set("X-Client-Version", headerParam1)
	}

	if params.XAccessKey != nil {
		var headerParam2 string

		headerParam2, err = runtime.StyleParamWithLocation("simple", false, "X-Access-Key", runtime.ParamLocationHeader, *params.XAccessKey)
		if err != nil {
			return nil, err
		}

		req.Header.Set("X-Access-Key", headerParam2)
	}

	return req, nil
}

// NewCreateShiftApiV1ShiftsPostRequest calls the generic CreateShiftApiV1ShiftsPost builder with application/json body
func NewCreateShiftApiV1ShiftsPostRequest(server string, params *CreateShiftApiV1ShiftsPostParams, body CreateShiftApiV1ShiftsPostJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateShiftApiV1ShiftsPostRequestWithBody(server, params, "application/json", bodyReader)
}

// NewCreateShiftApiV1ShiftsPostRequestWithBody generates requests for CreateShiftApiV1ShiftsPost with any type of body
func NewCreateShiftApiV1ShiftsPostRequestWithBody(server string, params *CreateShiftApiV1ShiftsPostParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/shifts")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params.XClientName != nil {
		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Client-Name", runtime.ParamLocationHeader, *params.XClientName)
		if err != nil {
			return nil, err
		}

		req.Header.Set("X-Client-Name", headerParam0)
	}

	if params.XClientVersion != nil {
		var headerParam1 string

		headerParam1, err = runtime.StyleParamWithLocation("simple", false, "X-Client-Version", runtime.ParamLocationHeader, *params.XClientVersion)
		if err != nil {
			return nil, err
		}

		req.Header.Set("X-Client-Version", headerParam1)
	}

	if params.XAccessKey != nil {
		var headerParam2 string

		headerParam2, err = runtime.StyleParamWithLocation("simple", false, "X-Access-Key", runtime.ParamLocationHeader, *params.XAccessKey)
		if err != nil {
			return nil, err
		}

		req.Header.Set("X-Access-Key", headerParam2)
	}

	if params.XDeviceID != nil {
		var headerParam3 string

		headerParam3, err = runtime.StyleParamWithLocation("simple", false, "X-Device-ID", runtime.ParamLocationHeader, *params.XDeviceID)
		if err != nil {
			return nil, err
		}

		req.Header.Set("X-Device-ID", headerParam3)
	}

	var headerParam4 string

	headerParam4, err = runtime.StyleParamWithLocation("simple", false, "X-License-Key", runtime.ParamLocationHeader, params.XLicenseKey)
	if err != nil {
		return nil, err
	}

	req.Header.Set("X-License-Key", headerParam4)

	return req, nil
}

// NewCloseShiftApiV1ShiftsClosePostRequest calls the generic CloseShiftApiV1ShiftsClosePost builder with application/json body
func NewCloseShiftApiV1ShiftsClosePostRequest(server string, params *CloseShiftApiV1ShiftsClosePostParams, body CloseShiftApiV1ShiftsClosePostJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCloseShiftApiV1ShiftsClosePostRequestWithBody(server, params, "application/json", bodyReader)
}

// NewCloseShiftApiV1ShiftsClosePostRequestWithBody generates requests for CloseShiftApiV1ShiftsClosePost with any type of body
func NewCloseShiftApiV1ShiftsClosePostRequestWithBody(server string, params *CloseShiftApiV1ShiftsClosePostParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/shifts/close")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params.XClientName != nil {
		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Client-Name", runtime.ParamLocationHeader, *params.XClientName)
		if err != nil {
			return nil, err
		}

		req.Header.Set("X-Client-Name", headerParam0)
	}

	if params.XClientVersion != nil {
		var headerParam1 string

		headerParam1, err = runtime.StyleParamWithLocation("simple", false, "X-Client-Version", runtime.ParamLocationHeader, *params.XClientVersion)
		if err != nil {
			return nil, err
		}

		req.Header.Set("X-Client-Version", headerParam1)
	}

	if params.XAccessKey != nil {
		var headerParam2 string

		headerParam2, err = runtime.StyleParamWithLocation("simple", false, "X-Access-Key", runtime.ParamLocationHeader, *params.XAccessKey)
		if err != nil {
			return nil, err
		}

		req.Header.Set("X-Access-Key", headerParam2)
	}

	if params.XDeviceID != nil {
		var headerParam3 string

		headerParam3, err = runtime.StyleParamWithLocation("simple", false, "X-Device-ID", runtime.ParamLocationHeader, *params.XDeviceID)
		if err != nil {
			return nil, err
		}

		req.Header.Set("X-Device-ID", headerParam3)
	}

	return req, nil
}

// NewGetShiftApiV1ShiftsShiftIdGetRequest generates requests for GetShiftApiV1ShiftsShiftIdGet
func NewGetShiftApiV1ShiftsShiftIdGetRequest(server string, shiftId openapi_types.UUID, params *GetShiftApiV1ShiftsShiftIdGetParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "shift_id", runtime.ParamLocationPath, shiftId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/shifts/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params.XClientName != nil {
		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Client-Name", runtime.ParamLocationHeader, *params.XClientName)
		if err != nil {
			return nil, err
		}

		req.Header.Set("X-Client-Name", headerParam0)
	}

	if params.XClientVersion != nil {
		var headerParam1 string

		headerParam1, err = runtime.StyleParamWithLocation("simple", false, "X-Client-Version", runtime.ParamLocationHeader, *params.XClientVersion)
		if err != nil {
			return nil, err
		}

		req.Header.Set("X-Client-Version", headerParam1)
	}

	if params.XAccessKey != nil {
		var headerParam2 string

		headerParam2, err = runtime.StyleParamWithLocation("simple", false, "X-Access-Key", runtime.ParamLocationHeader, *params.XAccessKey)
		if err != nil {
			return nil, err
		}

		req.Header.Set("X-Access-Key", headerParam2)
	}

	return req, nil
}

// NewCloseShiftBySeniorCashierApiV1ShiftsShiftIdClosePostRequest calls the generic CloseShiftBySeniorCashierApiV1ShiftsShiftIdClosePost builder with application/json body
func NewCloseShiftBySeniorCashierApiV1ShiftsShiftIdClosePostRequest(server string, shiftId openapi_types.UUID, params *CloseShiftBySeniorCashierApiV1ShiftsShiftIdClosePostParams, body CloseShiftBySeniorCashierApiV1ShiftsShiftIdClosePostJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCloseShiftBySeniorCashierApiV1ShiftsShiftIdClosePostRequestWithBody(server, shiftId, params, "application/json", bodyReader)
}

// NewCloseShiftBySeniorCashierApiV1ShiftsShiftIdClosePostRequestWithBody generates requests for CloseShiftBySeniorCashierApiV1ShiftsShiftIdClosePost with any type of body
func NewCloseShiftBySeniorCashierApiV1ShiftsShiftIdClosePostRequestWithBody(server string, shiftId openapi_types.UUID, params *CloseShiftBySeniorCashierApiV1ShiftsShiftIdClosePostParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "shift_id", runtime.ParamLocationPath, shiftId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/shifts/%s/close", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params.XClientName != nil {
		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Client-Name", runtime.ParamLocationHeader, *params.XClientName)
		if err != nil {
			return nil, err
		}

		req.Header.Set("X-Client-Name", headerParam0)
	}

	if params.XClientVersion != nil {
		var headerParam1 string

		headerParam1, err = runtime.StyleParamWithLocation("simple", false, "X-Client-Version", runtime.ParamLocationHeader, *params.XClientVersion)
		if err != nil {
			return nil, err
		}

		req.Header.Set("X-Client-Version", headerParam1)
	}

	if params.XAccessKey != nil {
		var headerParam2 string

		headerParam2, err = runtime.StyleParamWithLocation("simple", false, "X-Access-Key", runtime.ParamLocationHeader, *params.XAccessKey)
		if err != nil {
			return nil, err
		}

		req.Header.Set("X-Access-Key", headerParam2)
	}

	var headerParam3 string

	headerParam3, err = runtime.StyleParamWithLocation("simple", false, "X-License-Key", runtime.ParamLocationHeader, params.XLicenseKey)
	if err != nil {
		return nil, err
	}

	req.Header.Set("X-License-Key", headerParam3)

	return req, nil
}

// NewGetAllTaxesApiV1TaxGetRequest generates requests for GetAllTaxesApiV1TaxGet
func NewGetAllTaxesApiV1TaxGetRequest(server string, params *GetAllTaxesApiV1TaxGetParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/tax")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params.XClientName != nil {
		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Client-Name", runtime.ParamLocationHeader, *params.XClientName)
		if err != nil {
			return nil, err
		}

		req.Header.Set("X-Client-Name", headerParam0)
	}

	if params.XClientVersion != nil {
		var headerParam1 string

		headerParam1, err = runtime.StyleParamWithLocation("simple", false, "X-Client-Version", runtime.ParamLocationHeader, *params.XClientVersion)
		if err != nil {
			return nil, err
		}

		req.Header.Set("X-Client-Version", headerParam1)
	}

	if params.XAccessKey != nil {
		var headerParam2 string

		headerParam2, err = runtime.StyleParamWithLocation("simple", false, "X-Access-Key", runtime.ParamLocationHeader, *params.XAccessKey)
		if err != nil {
			return nil, err
		}

		req.Header.Set("X-Access-Key", headerParam2)
	}

	var headerParam3 string

	headerParam3, err = runtime.StyleParamWithLocation("simple", false, "X-License-Key", runtime.ParamLocationHeader, params.XLicenseKey)
	if err != nil {
		return nil, err
	}

	req.Header.Set("X-License-Key", headerParam3)

	return req, nil
}

// NewGetTransactionsApiV1TransactionsGetRequest generates requests for GetTransactionsApiV1TransactionsGet
func NewGetTransactionsApiV1TransactionsGetRequest(server string, params *GetTransactionsApiV1TransactionsGetParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/transactions")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Status != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "status", runtime.ParamLocationQuery, *params.Status); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Type != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "type", runtime.ParamLocationQuery, *params.Type); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Limit != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Offset != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params.XClientName != nil {
		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Client-Name", runtime.ParamLocationHeader, *params.XClientName)
		if err != nil {
			return nil, err
		}

		req.Header.Set("X-Client-Name", headerParam0)
	}

	if params.XClientVersion != nil {
		var headerParam1 string

		headerParam1, err = runtime.StyleParamWithLocation("simple", false, "X-Client-Version", runtime.ParamLocationHeader, *params.XClientVersion)
		if err != nil {
			return nil, err
		}

		req.Header.Set("X-Client-Version", headerParam1)
	}

	if params.XAccessKey != nil {
		var headerParam2 string

		headerParam2, err = runtime.StyleParamWithLocation("simple", false, "X-Access-Key", runtime.ParamLocationHeader, *params.XAccessKey)
		if err != nil {
			return nil, err
		}

		req.Header.Set("X-Access-Key", headerParam2)
	}

	return req, nil
}

// NewGetTransactionApiV1TransactionsTransactionIdGetRequest generates requests for GetTransactionApiV1TransactionsTransactionIdGet
func NewGetTransactionApiV1TransactionsTransactionIdGetRequest(server string, transactionId openapi_types.UUID, params *GetTransactionApiV1TransactionsTransactionIdGetParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "transaction_id", runtime.ParamLocationPath, transactionId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/transactions/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params.XClientName != nil {
		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Client-Name", runtime.ParamLocationHeader, *params.XClientName)
		if err != nil {
			return nil, err
		}

		req.Header.Set("X-Client-Name", headerParam0)
	}

	if params.XClientVersion != nil {
		var headerParam1 string

		headerParam1, err = runtime.StyleParamWithLocation("simple", false, "X-Client-Version", runtime.ParamLocationHeader, *params.XClientVersion)
		if err != nil {
			return nil, err
		}

		req.Header.Set("X-Client-Version", headerParam1)
	}

	if params.XAccessKey != nil {
		var headerParam2 string

		headerParam2, err = runtime.StyleParamWithLocation("simple", false, "X-Access-Key", runtime.ParamLocationHeader, *params.XAccessKey)
		if err != nil {
			return nil, err
		}

		req.Header.Set("X-Access-Key", headerParam2)
	}

	return req, nil
}

// NewUpdateTransactionApiV1TransactionsTransactionIdPatchRequest calls the generic UpdateTransactionApiV1TransactionsTransactionIdPatch builder with application/json body
func NewUpdateTransactionApiV1TransactionsTransactionIdPatchRequest(server string, transactionId openapi_types.UUID, params *UpdateTransactionApiV1TransactionsTransactionIdPatchParams, body UpdateTransactionApiV1TransactionsTransactionIdPatchJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateTransactionApiV1TransactionsTransactionIdPatchRequestWithBody(server, transactionId, params, "application/json", bodyReader)
}

// NewUpdateTransactionApiV1TransactionsTransactionIdPatchRequestWithBody generates requests for UpdateTransactionApiV1TransactionsTransactionIdPatch with any type of body
func NewUpdateTransactionApiV1TransactionsTransactionIdPatchRequestWithBody(server string, transactionId openapi_types.UUID, params *UpdateTransactionApiV1TransactionsTransactionIdPatchParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "transaction_id", runtime.ParamLocationPath, transactionId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/transactions/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params.XClientName != nil {
		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Client-Name", runtime.ParamLocationHeader, *params.XClientName)
		if err != nil {
			return nil, err
		}

		req.Header.Set("X-Client-Name", headerParam0)
	}

	if params.XClientVersion != nil {
		var headerParam1 string

		headerParam1, err = runtime.StyleParamWithLocation("simple", false, "X-Client-Version", runtime.ParamLocationHeader, *params.XClientVersion)
		if err != nil {
			return nil, err
		}

		req.Header.Set("X-Client-Version", headerParam1)
	}

	if params.XAccessKey != nil {
		var headerParam2 string

		headerParam2, err = runtime.StyleParamWithLocation("simple", false, "X-Access-Key", runtime.ParamLocationHeader, *params.XAccessKey)
		if err != nil {
			return nil, err
		}

		req.Header.Set("X-Access-Key", headerParam2)
	}

	return req, nil
}

// NewDeleteWebhookApiV1WebhookDeleteRequest generates requests for DeleteWebhookApiV1WebhookDelete
func NewDeleteWebhookApiV1WebhookDeleteRequest(server string, params *DeleteWebhookApiV1WebhookDeleteParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/webhook")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params.XClientName != nil {
		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Client-Name", runtime.ParamLocationHeader, *params.XClientName)
		if err != nil {
			return nil, err
		}

		req.Header.Set("X-Client-Name", headerParam0)
	}

	if params.XClientVersion != nil {
		var headerParam1 string

		headerParam1, err = runtime.StyleParamWithLocation("simple", false, "X-Client-Version", runtime.ParamLocationHeader, *params.XClientVersion)
		if err != nil {
			return nil, err
		}

		req.Header.Set("X-Client-Version", headerParam1)
	}

	if params.XAccessKey != nil {
		var headerParam2 string

		headerParam2, err = runtime.StyleParamWithLocation("simple", false, "X-Access-Key", runtime.ParamLocationHeader, *params.XAccessKey)
		if err != nil {
			return nil, err
		}

		req.Header.Set("X-Access-Key", headerParam2)
	}

	var headerParam3 string

	headerParam3, err = runtime.StyleParamWithLocation("simple", false, "X-License-Key", runtime.ParamLocationHeader, params.XLicenseKey)
	if err != nil {
		return nil, err
	}

	req.Header.Set("X-License-Key", headerParam3)

	return req, nil
}

// NewGetWebhookInfoApiV1WebhookGetRequest generates requests for GetWebhookInfoApiV1WebhookGet
func NewGetWebhookInfoApiV1WebhookGetRequest(server string, params *GetWebhookInfoApiV1WebhookGetParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/webhook")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params.XClientName != nil {
		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Client-Name", runtime.ParamLocationHeader, *params.XClientName)
		if err != nil {
			return nil, err
		}

		req.Header.Set("X-Client-Name", headerParam0)
	}

	if params.XClientVersion != nil {
		var headerParam1 string

		headerParam1, err = runtime.StyleParamWithLocation("simple", false, "X-Client-Version", runtime.ParamLocationHeader, *params.XClientVersion)
		if err != nil {
			return nil, err
		}

		req.Header.Set("X-Client-Version", headerParam1)
	}

	if params.XAccessKey != nil {
		var headerParam2 string

		headerParam2, err = runtime.StyleParamWithLocation("simple", false, "X-Access-Key", runtime.ParamLocationHeader, *params.XAccessKey)
		if err != nil {
			return nil, err
		}

		req.Header.Set("X-Access-Key", headerParam2)
	}

	var headerParam3 string

	headerParam3, err = runtime.StyleParamWithLocation("simple", false, "X-License-Key", runtime.ParamLocationHeader, params.XLicenseKey)
	if err != nil {
		return nil, err
	}

	req.Header.Set("X-License-Key", headerParam3)

	return req, nil
}

// NewSetWebhookApiV1WebhookPostRequest calls the generic SetWebhookApiV1WebhookPost builder with application/json body
func NewSetWebhookApiV1WebhookPostRequest(server string, params *SetWebhookApiV1WebhookPostParams, body SetWebhookApiV1WebhookPostJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewSetWebhookApiV1WebhookPostRequestWithBody(server, params, "application/json", bodyReader)
}

// NewSetWebhookApiV1WebhookPostRequestWithBody generates requests for SetWebhookApiV1WebhookPost with any type of body
func NewSetWebhookApiV1WebhookPostRequestWithBody(server string, params *SetWebhookApiV1WebhookPostParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/webhook")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params.XClientName != nil {
		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Client-Name", runtime.ParamLocationHeader, *params.XClientName)
		if err != nil {
			return nil, err
		}

		req.Header.Set("X-Client-Name", headerParam0)
	}

	if params.XClientVersion != nil {
		var headerParam1 string

		headerParam1, err = runtime.StyleParamWithLocation("simple", false, "X-Client-Version", runtime.ParamLocationHeader, *params.XClientVersion)
		if err != nil {
			return nil, err
		}

		req.Header.Set("X-Client-Version", headerParam1)
	}

	if params.XAccessKey != nil {
		var headerParam2 string

		headerParam2, err = runtime.StyleParamWithLocation("simple", false, "X-Access-Key", runtime.ParamLocationHeader, *params.XAccessKey)
		if err != nil {
			return nil, err
		}

		req.Header.Set("X-Access-Key", headerParam2)
	}

	var headerParam3 string

	headerParam3, err = runtime.StyleParamWithLocation("simple", false, "X-License-Key", runtime.ParamLocationHeader, params.XLicenseKey)
	if err != nil {
		return nil, err
	}

	req.Header.Set("X-License-Key", headerParam3)

	return req, nil
}

func (c *Client) applyEditors(ctx context.Context, req *http.Request, additionalEditors []RequestEditorFn) error {
	for _, r := range c.RequestEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	for _, r := range additionalEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	return nil
}

// ClientWithResponses builds on ClientInterface to offer response payloads
type ClientWithResponses struct {
	ClientInterface
}

// NewClientWithResponses creates a new ClientWithResponses, which wraps
// Client with return type handling
func NewClientWithResponses(server string, opts ...ClientOption) (*ClientWithResponses, error) {
	client, err := NewClient(server, opts...)
	if err != nil {
		return nil, err
	}
	return &ClientWithResponses{client}, nil
}

// WithBaseURL overrides the baseURL.
func WithBaseURL(baseURL string) ClientOption {
	return func(c *Client) error {
		newBaseURL, err := url.Parse(baseURL)
		if err != nil {
			return err
		}
		c.Server = newBaseURL.String()
		return nil
	}
}

// ClientWithResponsesInterface is the interface specification for the client with responses above.
type ClientWithResponsesInterface interface {
	// GetCashRegistersApiV1CashRegistersGet request
	GetCashRegistersApiV1CashRegistersGetWithResponse(ctx context.Context, params *GetCashRegistersApiV1CashRegistersGetParams, reqEditors ...RequestEditorFn) (*GetCashRegistersApiV1CashRegistersGetResponse, error)

	// AskOfflineCodesApiV1CashRegistersAskOfflineCodesGet request
	AskOfflineCodesApiV1CashRegistersAskOfflineCodesGetWithResponse(ctx context.Context, params *AskOfflineCodesApiV1CashRegistersAskOfflineCodesGetParams, reqEditors ...RequestEditorFn) (*AskOfflineCodesApiV1CashRegistersAskOfflineCodesGetResponse, error)

	// GetOfflineCodesApiV1CashRegistersGetOfflineCodesGet request
	GetOfflineCodesApiV1CashRegistersGetOfflineCodesGetWithResponse(ctx context.Context, params *GetOfflineCodesApiV1CashRegistersGetOfflineCodesGetParams, reqEditors ...RequestEditorFn) (*GetOfflineCodesApiV1CashRegistersGetOfflineCodesGetResponse, error)

	// GetOfflineCodesCountApiV1CashRegistersGetOfflineCodesCountGet request
	GetOfflineCodesCountApiV1CashRegistersGetOfflineCodesCountGetWithResponse(ctx context.Context, params *GetOfflineCodesCountApiV1CashRegistersGetOfflineCodesCountGetParams, reqEditors ...RequestEditorFn) (*GetOfflineCodesCountApiV1CashRegistersGetOfflineCodesCountGetResponse, error)

	// GetOfflineTimeApiV1CashRegistersGetOfflineTimeGet request
	GetOfflineTimeApiV1CashRegistersGetOfflineTimeGetWithResponse(ctx context.Context, params *GetOfflineTimeApiV1CashRegistersGetOfflineTimeGetParams, reqEditors ...RequestEditorFn) (*GetOfflineTimeApiV1CashRegistersGetOfflineTimeGetResponse, error)

	// GoOfflineActionApiV1CashRegistersGoOfflinePost request with any body
	GoOfflineActionApiV1CashRegistersGoOfflinePostWithBodyWithResponse(ctx context.Context, params *GoOfflineActionApiV1CashRegistersGoOfflinePostParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*GoOfflineActionApiV1CashRegistersGoOfflinePostResponse, error)

	GoOfflineActionApiV1CashRegistersGoOfflinePostWithResponse(ctx context.Context, params *GoOfflineActionApiV1CashRegistersGoOfflinePostParams, body GoOfflineActionApiV1CashRegistersGoOfflinePostJSONRequestBody, reqEditors ...RequestEditorFn) (*GoOfflineActionApiV1CashRegistersGoOfflinePostResponse, error)

	// GoOnlineActionApiV1CashRegistersGoOnlinePost request
	GoOnlineActionApiV1CashRegistersGoOnlinePostWithResponse(ctx context.Context, params *GoOnlineActionApiV1CashRegistersGoOnlinePostParams, reqEditors ...RequestEditorFn) (*GoOnlineActionApiV1CashRegistersGoOnlinePostResponse, error)

	// GetCashRegisterInfoApiV1CashRegistersInfoGet request
	GetCashRegisterInfoApiV1CashRegistersInfoGetWithResponse(ctx context.Context, params *GetCashRegisterInfoApiV1CashRegistersInfoGetParams, reqEditors ...RequestEditorFn) (*GetCashRegisterInfoApiV1CashRegistersInfoGetResponse, error)

	// PingTaxServiceActionApiV1CashRegistersPingTaxServicePost request
	PingTaxServiceActionApiV1CashRegistersPingTaxServicePostWithResponse(ctx context.Context, params *PingTaxServiceActionApiV1CashRegistersPingTaxServicePostParams, reqEditors ...RequestEditorFn) (*PingTaxServiceActionApiV1CashRegistersPingTaxServicePostResponse, error)

	// GetCashRegisterApiV1CashRegistersCashRegisterIdGet request
	GetCashRegisterApiV1CashRegistersCashRegisterIdGetWithResponse(ctx context.Context, cashRegisterId openapi_types.UUID, params *GetCashRegisterApiV1CashRegistersCashRegisterIdGetParams, reqEditors ...RequestEditorFn) (*GetCashRegisterApiV1CashRegistersCashRegisterIdGetResponse, error)

	// CheckSignatureApiV1CashierCheckSignatureGet request
	CheckSignatureApiV1CashierCheckSignatureGetWithResponse(ctx context.Context, params *CheckSignatureApiV1CashierCheckSignatureGetParams, reqEditors ...RequestEditorFn) (*CheckSignatureApiV1CashierCheckSignatureGetResponse, error)

	// GetCashierProfileApiV1CashierMeGet request
	GetCashierProfileApiV1CashierMeGetWithResponse(ctx context.Context, params *GetCashierProfileApiV1CashierMeGetParams, reqEditors ...RequestEditorFn) (*GetCashierProfileApiV1CashierMeGetResponse, error)

	// GetCashierShiftApiV1CashierShiftGet request
	GetCashierShiftApiV1CashierShiftGetWithResponse(ctx context.Context, params *GetCashierShiftApiV1CashierShiftGetParams, reqEditors ...RequestEditorFn) (*GetCashierShiftApiV1CashierShiftGetResponse, error)

	// SignInCashierApiV1CashierSigninPost request with any body
	SignInCashierApiV1CashierSigninPostWithBodyWithResponse(ctx context.Context, params *SignInCashierApiV1CashierSigninPostParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SignInCashierApiV1CashierSigninPostResponse, error)

	SignInCashierApiV1CashierSigninPostWithResponse(ctx context.Context, params *SignInCashierApiV1CashierSigninPostParams, body SignInCashierApiV1CashierSigninPostJSONRequestBody, reqEditors ...RequestEditorFn) (*SignInCashierApiV1CashierSigninPostResponse, error)

	// SignInCashierViaPinCodeApiV1CashierSigninPinCodePost request with any body
	SignInCashierViaPinCodeApiV1CashierSigninPinCodePostWithBodyWithResponse(ctx context.Context, params *SignInCashierViaPinCodeApiV1CashierSigninPinCodePostParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SignInCashierViaPinCodeApiV1CashierSigninPinCodePostResponse, error)

	SignInCashierViaPinCodeApiV1CashierSigninPinCodePostWithResponse(ctx context.Context, params *SignInCashierViaPinCodeApiV1CashierSigninPinCodePostParams, body SignInCashierViaPinCodeApiV1CashierSigninPinCodePostJSONRequestBody, reqEditors ...RequestEditorFn) (*SignInCashierViaPinCodeApiV1CashierSigninPinCodePostResponse, error)

	// SignOutCashierApiV1CashierSignoutPost request
	SignOutCashierApiV1CashierSignoutPostWithResponse(ctx context.Context, params *SignOutCashierApiV1CashierSignoutPostParams, reqEditors ...RequestEditorFn) (*SignOutCashierApiV1CashierSignoutPostResponse, error)

	// GetCurrencyRatesApiV1CurrencyRateGet request
	GetCurrencyRatesApiV1CurrencyRateGetWithResponse(ctx context.Context, params *GetCurrencyRatesApiV1CurrencyRateGetParams, reqEditors ...RequestEditorFn) (*GetCurrencyRatesApiV1CurrencyRateGetResponse, error)

	// SetupCurrencyRatesApiV1CurrencyRateSetupPost request with any body
	SetupCurrencyRatesApiV1CurrencyRateSetupPostWithBodyWithResponse(ctx context.Context, params *SetupCurrencyRatesApiV1CurrencyRateSetupPostParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SetupCurrencyRatesApiV1CurrencyRateSetupPostResponse, error)

	SetupCurrencyRatesApiV1CurrencyRateSetupPostWithResponse(ctx context.Context, params *SetupCurrencyRatesApiV1CurrencyRateSetupPostParams, body SetupCurrencyRatesApiV1CurrencyRateSetupPostJSONRequestBody, reqEditors ...RequestEditorFn) (*SetupCurrencyRatesApiV1CurrencyRateSetupPostResponse, error)

	// GetCurrencyRateApiV1CurrencyRateCurrencyCodeGet request
	GetCurrencyRateApiV1CurrencyRateCurrencyCodeGetWithResponse(ctx context.Context, currencyCode string, params *GetCurrencyRateApiV1CurrencyRateCurrencyCodeGetParams, reqEditors ...RequestEditorFn) (*GetCurrencyRateApiV1CurrencyRateCurrencyCodeGetResponse, error)

	// GoodsReportApiV1ExtendedReportsGoodsPost request with any body
	GoodsReportApiV1ExtendedReportsGoodsPostWithBodyWithResponse(ctx context.Context, params *GoodsReportApiV1ExtendedReportsGoodsPostParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*GoodsReportApiV1ExtendedReportsGoodsPostResponse, error)

	GoodsReportApiV1ExtendedReportsGoodsPostWithResponse(ctx context.Context, params *GoodsReportApiV1ExtendedReportsGoodsPostParams, body GoodsReportApiV1ExtendedReportsGoodsPostJSONRequestBody, reqEditors ...RequestEditorFn) (*GoodsReportApiV1ExtendedReportsGoodsPostResponse, error)

	// GetReportTaskByIdApiV1ExtendedReportsReportTaskIdGet request
	GetReportTaskByIdApiV1ExtendedReportsReportTaskIdGetWithResponse(ctx context.Context, reportTaskId openapi_types.UUID, params *GetReportTaskByIdApiV1ExtendedReportsReportTaskIdGetParams, reqEditors ...RequestEditorFn) (*GetReportTaskByIdApiV1ExtendedReportsReportTaskIdGetResponse, error)

	// GetReportXlsxByIdApiV1ExtendedReportsReportTaskIdReportXlsxGet request
	GetReportXlsxByIdApiV1ExtendedReportsReportTaskIdReportXlsxGetWithResponse(ctx context.Context, reportTaskId openapi_types.UUID, params *GetReportXlsxByIdApiV1ExtendedReportsReportTaskIdReportXlsxGetParams, reqEditors ...RequestEditorFn) (*GetReportXlsxByIdApiV1ExtendedReportsReportTaskIdReportXlsxGetResponse, error)

	// GetGoodsApiV1GoodsGet request
	GetGoodsApiV1GoodsGetWithResponse(ctx context.Context, params *GetGoodsApiV1GoodsGetParams, reqEditors ...RequestEditorFn) (*GetGoodsApiV1GoodsGetResponse, error)

	// ExportGoodsFileApiV1GoodsExportFileTaskIdGet request
	ExportGoodsFileApiV1GoodsExportFileTaskIdGetWithResponse(ctx context.Context, taskId openapi_types.UUID, params *ExportGoodsFileApiV1GoodsExportFileTaskIdGetParams, reqEditors ...RequestEditorFn) (*ExportGoodsFileApiV1GoodsExportFileTaskIdGetResponse, error)

	// ExportGoodsTaskStatusApiV1GoodsExportTaskStatusTaskIdGet request
	ExportGoodsTaskStatusApiV1GoodsExportTaskStatusTaskIdGetWithResponse(ctx context.Context, taskId openapi_types.UUID, params *ExportGoodsTaskStatusApiV1GoodsExportTaskStatusTaskIdGetParams, reqEditors ...RequestEditorFn) (*ExportGoodsTaskStatusApiV1GoodsExportTaskStatusTaskIdGetResponse, error)

	// ExportGoodsApiV1GoodsExportExportExtensionGet request
	ExportGoodsApiV1GoodsExportExportExtensionGetWithResponse(ctx context.Context, exportExtension ExportExtensionType, params *ExportGoodsApiV1GoodsExportExportExtensionGetParams, reqEditors ...RequestEditorFn) (*ExportGoodsApiV1GoodsExportExportExtensionGetResponse, error)

	// ImportGoodsApplyChangesApiV1GoodsImportApplyChangesTaskIdPost request
	ImportGoodsApplyChangesApiV1GoodsImportApplyChangesTaskIdPostWithResponse(ctx context.Context, taskId openapi_types.UUID, params *ImportGoodsApplyChangesApiV1GoodsImportApplyChangesTaskIdPostParams, reqEditors ...RequestEditorFn) (*ImportGoodsApplyChangesApiV1GoodsImportApplyChangesTaskIdPostResponse, error)

	// ImportGoodsTaskStatusApiV1GoodsImportTaskStatusTaskIdGet request
	ImportGoodsTaskStatusApiV1GoodsImportTaskStatusTaskIdGetWithResponse(ctx context.Context, taskId openapi_types.UUID, params *ImportGoodsTaskStatusApiV1GoodsImportTaskStatusTaskIdGetParams, reqEditors ...RequestEditorFn) (*ImportGoodsTaskStatusApiV1GoodsImportTaskStatusTaskIdGetResponse, error)

	// ImportGoodsFromFileApiV1GoodsImportUploadPost request with any body
	ImportGoodsFromFileApiV1GoodsImportUploadPostWithBodyWithResponse(ctx context.Context, params *ImportGoodsFromFileApiV1GoodsImportUploadPostParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ImportGoodsFromFileApiV1GoodsImportUploadPostResponse, error)

	// GetGoodApiV1GoodsGoodIdGet request
	GetGoodApiV1GoodsGoodIdGetWithResponse(ctx context.Context, goodId openapi_types.UUID, params *GetGoodApiV1GoodsGoodIdGetParams, reqEditors ...RequestEditorFn) (*GetGoodApiV1GoodsGoodIdGetResponse, error)

	// GetOrdersApiV1OrdersGet request
	GetOrdersApiV1OrdersGetWithResponse(ctx context.Context, params *GetOrdersApiV1OrdersGetParams, reqEditors ...RequestEditorFn) (*GetOrdersApiV1OrdersGetResponse, error)

	// AddOrdersApiV1OrdersPost request with any body
	AddOrdersApiV1OrdersPostWithBodyWithResponse(ctx context.Context, params *AddOrdersApiV1OrdersPostParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AddOrdersApiV1OrdersPostResponse, error)

	AddOrdersApiV1OrdersPostWithResponse(ctx context.Context, params *AddOrdersApiV1OrdersPostParams, body AddOrdersApiV1OrdersPostJSONRequestBody, reqEditors ...RequestEditorFn) (*AddOrdersApiV1OrdersPostResponse, error)

	// CloseNotFiscalizeOrderApiV1OrdersClosePatch request
	CloseNotFiscalizeOrderApiV1OrdersClosePatchWithResponse(ctx context.Context, params *CloseNotFiscalizeOrderApiV1OrdersClosePatchParams, reqEditors ...RequestEditorFn) (*CloseNotFiscalizeOrderApiV1OrdersClosePatchResponse, error)

	// UpdateCustomOrderStatusApiV1OrdersCustomStatusOrderIdPatch request
	UpdateCustomOrderStatusApiV1OrdersCustomStatusOrderIdPatchWithResponse(ctx context.Context, orderId openapi_types.UUID, params *UpdateCustomOrderStatusApiV1OrdersCustomStatusOrderIdPatchParams, reqEditors ...RequestEditorFn) (*UpdateCustomOrderStatusApiV1OrdersCustomStatusOrderIdPatchResponse, error)

	// DeleteIntegrationApiV1OrdersIntegrationDelete request
	DeleteIntegrationApiV1OrdersIntegrationDeleteWithResponse(ctx context.Context, params *DeleteIntegrationApiV1OrdersIntegrationDeleteParams, reqEditors ...RequestEditorFn) (*DeleteIntegrationApiV1OrdersIntegrationDeleteResponse, error)

	// GetIntegrationApiV1OrdersIntegrationGet request
	GetIntegrationApiV1OrdersIntegrationGetWithResponse(ctx context.Context, params *GetIntegrationApiV1OrdersIntegrationGetParams, reqEditors ...RequestEditorFn) (*GetIntegrationApiV1OrdersIntegrationGetResponse, error)

	// SetIntegrationApiV1OrdersIntegrationPost request with any body
	SetIntegrationApiV1OrdersIntegrationPostWithBodyWithResponse(ctx context.Context, params *SetIntegrationApiV1OrdersIntegrationPostParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SetIntegrationApiV1OrdersIntegrationPostResponse, error)

	SetIntegrationApiV1OrdersIntegrationPostWithResponse(ctx context.Context, params *SetIntegrationApiV1OrdersIntegrationPostParams, body SetIntegrationApiV1OrdersIntegrationPostJSONRequestBody, reqEditors ...RequestEditorFn) (*SetIntegrationApiV1OrdersIntegrationPostResponse, error)

	// EditOrderApiV1OrdersIntegrationEditOrderPost request with any body
	EditOrderApiV1OrdersIntegrationEditOrderPostWithBodyWithResponse(ctx context.Context, params *EditOrderApiV1OrdersIntegrationEditOrderPostParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*EditOrderApiV1OrdersIntegrationEditOrderPostResponse, error)

	EditOrderApiV1OrdersIntegrationEditOrderPostWithResponse(ctx context.Context, params *EditOrderApiV1OrdersIntegrationEditOrderPostParams, body EditOrderApiV1OrdersIntegrationEditOrderPostJSONRequestBody, reqEditors ...RequestEditorFn) (*EditOrderApiV1OrdersIntegrationEditOrderPostResponse, error)

	// RunOrdersSynchronizationApiV1OrdersSyncPost request
	RunOrdersSynchronizationApiV1OrdersSyncPostWithResponse(ctx context.Context, params *RunOrdersSynchronizationApiV1OrdersSyncPostParams, reqEditors ...RequestEditorFn) (*RunOrdersSynchronizationApiV1OrdersSyncPostResponse, error)

	// GetOrderApiV1OrdersOrderIdGet request
	GetOrderApiV1OrdersOrderIdGetWithResponse(ctx context.Context, orderId openapi_types.UUID, params *GetOrderApiV1OrdersOrderIdGetParams, reqEditors ...RequestEditorFn) (*GetOrderApiV1OrdersOrderIdGetResponse, error)

	// CancelOrderApiV1OrdersOrderIdPatch request
	CancelOrderApiV1OrdersOrderIdPatchWithResponse(ctx context.Context, orderId openapi_types.UUID, params *CancelOrderApiV1OrdersOrderIdPatchParams, reqEditors ...RequestEditorFn) (*CancelOrderApiV1OrdersOrderIdPatchResponse, error)

	// GetCurrentOrganizationLogoApiV1OrganizationLogoPngGet request
	GetCurrentOrganizationLogoApiV1OrganizationLogoPngGetWithResponse(ctx context.Context, params *GetCurrentOrganizationLogoApiV1OrganizationLogoPngGetParams, reqEditors ...RequestEditorFn) (*GetCurrentOrganizationLogoApiV1OrganizationLogoPngGetResponse, error)

	// GetCurrentOrganizationReceiptSettingsApiV1OrganizationReceiptConfigGet request
	GetCurrentOrganizationReceiptSettingsApiV1OrganizationReceiptConfigGetWithResponse(ctx context.Context, params *GetCurrentOrganizationReceiptSettingsApiV1OrganizationReceiptConfigGetParams, reqEditors ...RequestEditorFn) (*GetCurrentOrganizationReceiptSettingsApiV1OrganizationReceiptConfigGetResponse, error)

	// GetCurrentOrganizationSmsBillingBalanceApiV1OrganizationSmsBillingGet request
	GetCurrentOrganizationSmsBillingBalanceApiV1OrganizationSmsBillingGetWithResponse(ctx context.Context, params *GetCurrentOrganizationSmsBillingBalanceApiV1OrganizationSmsBillingGetParams, reqEditors ...RequestEditorFn) (*GetCurrentOrganizationSmsBillingBalanceApiV1OrganizationSmsBillingGetResponse, error)

	// GetCurrentOrganizationTextLogoApiV1OrganizationTextLogoPngGet request
	GetCurrentOrganizationTextLogoApiV1OrganizationTextLogoPngGetWithResponse(ctx context.Context, params *GetCurrentOrganizationTextLogoApiV1OrganizationTextLogoPngGetParams, reqEditors ...RequestEditorFn) (*GetCurrentOrganizationTextLogoApiV1OrganizationTextLogoPngGetResponse, error)

	// GetReceiptsApiV1ReceiptsGet request
	GetReceiptsApiV1ReceiptsGetWithResponse(ctx context.Context, params *GetReceiptsApiV1ReceiptsGetParams, reqEditors ...RequestEditorFn) (*GetReceiptsApiV1ReceiptsGetResponse, error)

	// AddExternalReceiptApiV1ReceiptsAddExternalPost request with any body
	AddExternalReceiptApiV1ReceiptsAddExternalPostWithBodyWithResponse(ctx context.Context, params *AddExternalReceiptApiV1ReceiptsAddExternalPostParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AddExternalReceiptApiV1ReceiptsAddExternalPostResponse, error)

	AddExternalReceiptApiV1ReceiptsAddExternalPostWithResponse(ctx context.Context, params *AddExternalReceiptApiV1ReceiptsAddExternalPostParams, body AddExternalReceiptApiV1ReceiptsAddExternalPostJSONRequestBody, reqEditors ...RequestEditorFn) (*AddExternalReceiptApiV1ReceiptsAddExternalPostResponse, error)

	// CashWithdrawalApiV1ReceiptsCashWithdrawalPost request with any body
	CashWithdrawalApiV1ReceiptsCashWithdrawalPostWithBodyWithResponse(ctx context.Context, params *CashWithdrawalApiV1ReceiptsCashWithdrawalPostParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CashWithdrawalApiV1ReceiptsCashWithdrawalPostResponse, error)

	CashWithdrawalApiV1ReceiptsCashWithdrawalPostWithResponse(ctx context.Context, params *CashWithdrawalApiV1ReceiptsCashWithdrawalPostParams, body CashWithdrawalApiV1ReceiptsCashWithdrawalPostJSONRequestBody, reqEditors ...RequestEditorFn) (*CashWithdrawalApiV1ReceiptsCashWithdrawalPostResponse, error)

	// ExchangeApiV1ReceiptsCurrencyExchangePost request with any body
	ExchangeApiV1ReceiptsCurrencyExchangePostWithBodyWithResponse(ctx context.Context, params *ExchangeApiV1ReceiptsCurrencyExchangePostParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ExchangeApiV1ReceiptsCurrencyExchangePostResponse, error)

	ExchangeApiV1ReceiptsCurrencyExchangePostWithResponse(ctx context.Context, params *ExchangeApiV1ReceiptsCurrencyExchangePostParams, body ExchangeApiV1ReceiptsCurrencyExchangePostJSONRequestBody, reqEditors ...RequestEditorFn) (*ExchangeApiV1ReceiptsCurrencyExchangePostResponse, error)

	// GetReceiptsSearchApiV1ReceiptsSearchGet request
	GetReceiptsSearchApiV1ReceiptsSearchGetWithResponse(ctx context.Context, params *GetReceiptsSearchApiV1ReceiptsSearchGetParams, reqEditors ...RequestEditorFn) (*GetReceiptsSearchApiV1ReceiptsSearchGetResponse, error)

	// CreateReceiptApiV1ReceiptsSellPost request with any body
	CreateReceiptApiV1ReceiptsSellPostWithBodyWithResponse(ctx context.Context, params *CreateReceiptApiV1ReceiptsSellPostParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateReceiptApiV1ReceiptsSellPostResponse, error)

	CreateReceiptApiV1ReceiptsSellPostWithResponse(ctx context.Context, params *CreateReceiptApiV1ReceiptsSellPostParams, body CreateReceiptApiV1ReceiptsSellPostJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateReceiptApiV1ReceiptsSellPostResponse, error)

	// CreateOfflineReceiptApiV1ReceiptsSellOfflinePost request with any body
	CreateOfflineReceiptApiV1ReceiptsSellOfflinePostWithBodyWithResponse(ctx context.Context, params *CreateOfflineReceiptApiV1ReceiptsSellOfflinePostParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateOfflineReceiptApiV1ReceiptsSellOfflinePostResponse, error)

	CreateOfflineReceiptApiV1ReceiptsSellOfflinePostWithResponse(ctx context.Context, params *CreateOfflineReceiptApiV1ReceiptsSellOfflinePostParams, body CreateOfflineReceiptApiV1ReceiptsSellOfflinePostJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateOfflineReceiptApiV1ReceiptsSellOfflinePostResponse, error)

	// CreateServiceReceiptApiV1ReceiptsServicePost request with any body
	CreateServiceReceiptApiV1ReceiptsServicePostWithBodyWithResponse(ctx context.Context, params *CreateServiceReceiptApiV1ReceiptsServicePostParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateServiceReceiptApiV1ReceiptsServicePostResponse, error)

	CreateServiceReceiptApiV1ReceiptsServicePostWithResponse(ctx context.Context, params *CreateServiceReceiptApiV1ReceiptsServicePostParams, body CreateServiceReceiptApiV1ReceiptsServicePostJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateServiceReceiptApiV1ReceiptsServicePostResponse, error)

	// CreateServiceCurrencyReceiptApiV1ReceiptsServiceCurrencyPost request with any body
	CreateServiceCurrencyReceiptApiV1ReceiptsServiceCurrencyPostWithBodyWithResponse(ctx context.Context, params *CreateServiceCurrencyReceiptApiV1ReceiptsServiceCurrencyPostParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateServiceCurrencyReceiptApiV1ReceiptsServiceCurrencyPostResponse, error)

	CreateServiceCurrencyReceiptApiV1ReceiptsServiceCurrencyPostWithResponse(ctx context.Context, params *CreateServiceCurrencyReceiptApiV1ReceiptsServiceCurrencyPostParams, body CreateServiceCurrencyReceiptApiV1ReceiptsServiceCurrencyPostJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateServiceCurrencyReceiptApiV1ReceiptsServiceCurrencyPostResponse, error)

	// GetReceiptApiV1ReceiptsReceiptIdGet request
	GetReceiptApiV1ReceiptsReceiptIdGetWithResponse(ctx context.Context, receiptId struct {
		union json.RawMessage
	}, params *GetReceiptApiV1ReceiptsReceiptIdGetParams, reqEditors ...RequestEditorFn) (*GetReceiptApiV1ReceiptsReceiptIdGetResponse, error)

	// SendReceiptToEmailApiV1ReceiptsReceiptIdEmailPost request with any body
	SendReceiptToEmailApiV1ReceiptsReceiptIdEmailPostWithBodyWithResponse(ctx context.Context, receiptId struct {
		union json.RawMessage
	}, params *SendReceiptToEmailApiV1ReceiptsReceiptIdEmailPostParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SendReceiptToEmailApiV1ReceiptsReceiptIdEmailPostResponse, error)

	SendReceiptToEmailApiV1ReceiptsReceiptIdEmailPostWithResponse(ctx context.Context, receiptId struct {
		union json.RawMessage
	}, params *SendReceiptToEmailApiV1ReceiptsReceiptIdEmailPostParams, body SendReceiptToEmailApiV1ReceiptsReceiptIdEmailPostJSONRequestBody, reqEditors ...RequestEditorFn) (*SendReceiptToEmailApiV1ReceiptsReceiptIdEmailPostResponse, error)

	// GetReceiptHtmlApiV1ReceiptsReceiptIdHtmlGet request
	GetReceiptHtmlApiV1ReceiptsReceiptIdHtmlGetWithResponse(ctx context.Context, receiptId struct {
		union json.RawMessage
	}, params *GetReceiptHtmlApiV1ReceiptsReceiptIdHtmlGetParams, reqEditors ...RequestEditorFn) (*GetReceiptHtmlApiV1ReceiptsReceiptIdHtmlGetResponse, error)

	// GetReceiptPdfApiV1ReceiptsReceiptIdPdfGet request
	GetReceiptPdfApiV1ReceiptsReceiptIdPdfGetWithResponse(ctx context.Context, receiptId struct {
		union json.RawMessage
	}, params *GetReceiptPdfApiV1ReceiptsReceiptIdPdfGetParams, reqEditors ...RequestEditorFn) (*GetReceiptPdfApiV1ReceiptsReceiptIdPdfGetResponse, error)

	// GetReceiptPngApiV1ReceiptsReceiptIdPngGet request
	GetReceiptPngApiV1ReceiptsReceiptIdPngGetWithResponse(ctx context.Context, receiptId struct {
		union json.RawMessage
	}, params *GetReceiptPngApiV1ReceiptsReceiptIdPngGetParams, reqEditors ...RequestEditorFn) (*GetReceiptPngApiV1ReceiptsReceiptIdPngGetResponse, error)

	// GetReceiptQrCodeImageApiV1ReceiptsReceiptIdQrcodeGet request
	GetReceiptQrCodeImageApiV1ReceiptsReceiptIdQrcodeGetWithResponse(ctx context.Context, receiptId struct {
		union json.RawMessage
	}, params *GetReceiptQrCodeImageApiV1ReceiptsReceiptIdQrcodeGetParams, reqEditors ...RequestEditorFn) (*GetReceiptQrCodeImageApiV1ReceiptsReceiptIdQrcodeGetResponse, error)

	// SendReceiptViaSmsApiV1ReceiptsReceiptIdSmsPost request with any body
	SendReceiptViaSmsApiV1ReceiptsReceiptIdSmsPostWithBodyWithResponse(ctx context.Context, receiptId struct {
		union json.RawMessage
	}, params *SendReceiptViaSmsApiV1ReceiptsReceiptIdSmsPostParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SendReceiptViaSmsApiV1ReceiptsReceiptIdSmsPostResponse, error)

	SendReceiptViaSmsApiV1ReceiptsReceiptIdSmsPostWithResponse(ctx context.Context, receiptId struct {
		union json.RawMessage
	}, params *SendReceiptViaSmsApiV1ReceiptsReceiptIdSmsPostParams, body SendReceiptViaSmsApiV1ReceiptsReceiptIdSmsPostJSONRequestBody, reqEditors ...RequestEditorFn) (*SendReceiptViaSmsApiV1ReceiptsReceiptIdSmsPostResponse, error)

	// GetReceiptTextApiV1ReceiptsReceiptIdTextGet request
	GetReceiptTextApiV1ReceiptsReceiptIdTextGetWithResponse(ctx context.Context, receiptId struct {
		union json.RawMessage
	}, params *GetReceiptTextApiV1ReceiptsReceiptIdTextGetParams, reqEditors ...RequestEditorFn) (*GetReceiptTextApiV1ReceiptsReceiptIdTextGetResponse, error)

	// GetReceiptXmlApiV1ReceiptsReceiptIdXmlGet request
	GetReceiptXmlApiV1ReceiptsReceiptIdXmlGetWithResponse(ctx context.Context, receiptId struct {
		union json.RawMessage
	}, params *GetReceiptXmlApiV1ReceiptsReceiptIdXmlGetParams, reqEditors ...RequestEditorFn) (*GetReceiptXmlApiV1ReceiptsReceiptIdXmlGetResponse, error)

	// GetReportsApiV1ReportsGet request
	GetReportsApiV1ReportsGetWithResponse(ctx context.Context, params *GetReportsApiV1ReportsGetParams, reqEditors ...RequestEditorFn) (*GetReportsApiV1ReportsGetResponse, error)

	// CreateXReportApiV1ReportsPost request
	CreateXReportApiV1ReportsPostWithResponse(ctx context.Context, params *CreateXReportApiV1ReportsPostParams, reqEditors ...RequestEditorFn) (*CreateXReportApiV1ReportsPostResponse, error)

	// AddExternalReportApiV1ReportsAddExternalPost request with any body
	AddExternalReportApiV1ReportsAddExternalPostWithBodyWithResponse(ctx context.Context, params *AddExternalReportApiV1ReportsAddExternalPostParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AddExternalReportApiV1ReportsAddExternalPostResponse, error)

	AddExternalReportApiV1ReportsAddExternalPostWithResponse(ctx context.Context, params *AddExternalReportApiV1ReportsAddExternalPostParams, body AddExternalReportApiV1ReportsAddExternalPostJSONRequestBody, reqEditors ...RequestEditorFn) (*AddExternalReportApiV1ReportsAddExternalPostResponse, error)

	// GetPeriodicalReportApiV1ReportsPeriodicalGet request
	GetPeriodicalReportApiV1ReportsPeriodicalGetWithResponse(ctx context.Context, params *GetPeriodicalReportApiV1ReportsPeriodicalGetParams, reqEditors ...RequestEditorFn) (*GetPeriodicalReportApiV1ReportsPeriodicalGetResponse, error)

	// GetSearchReportsApiV1ReportsSearchGet request
	GetSearchReportsApiV1ReportsSearchGetWithResponse(ctx context.Context, params *GetSearchReportsApiV1ReportsSearchGetParams, reqEditors ...RequestEditorFn) (*GetSearchReportsApiV1ReportsSearchGetResponse, error)

	// GetReportApiV1ReportsReportIdGet request
	GetReportApiV1ReportsReportIdGetWithResponse(ctx context.Context, reportId openapi_types.UUID, params *GetReportApiV1ReportsReportIdGetParams, reqEditors ...RequestEditorFn) (*GetReportApiV1ReportsReportIdGetResponse, error)

	// GetReportTextApiV1ReportsReportIdTextGet request
	GetReportTextApiV1ReportsReportIdTextGetWithResponse(ctx context.Context, reportId openapi_types.UUID, params *GetReportTextApiV1ReportsReportIdTextGetParams, reqEditors ...RequestEditorFn) (*GetReportTextApiV1ReportsReportIdTextGetResponse, error)

	// GetShiftsApiV1ShiftsGet request
	GetShiftsApiV1ShiftsGetWithResponse(ctx context.Context, params *GetShiftsApiV1ShiftsGetParams, reqEditors ...RequestEditorFn) (*GetShiftsApiV1ShiftsGetResponse, error)

	// CreateShiftApiV1ShiftsPost request with any body
	CreateShiftApiV1ShiftsPostWithBodyWithResponse(ctx context.Context, params *CreateShiftApiV1ShiftsPostParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateShiftApiV1ShiftsPostResponse, error)

	CreateShiftApiV1ShiftsPostWithResponse(ctx context.Context, params *CreateShiftApiV1ShiftsPostParams, body CreateShiftApiV1ShiftsPostJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateShiftApiV1ShiftsPostResponse, error)

	// CloseShiftApiV1ShiftsClosePost request with any body
	CloseShiftApiV1ShiftsClosePostWithBodyWithResponse(ctx context.Context, params *CloseShiftApiV1ShiftsClosePostParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CloseShiftApiV1ShiftsClosePostResponse, error)

	CloseShiftApiV1ShiftsClosePostWithResponse(ctx context.Context, params *CloseShiftApiV1ShiftsClosePostParams, body CloseShiftApiV1ShiftsClosePostJSONRequestBody, reqEditors ...RequestEditorFn) (*CloseShiftApiV1ShiftsClosePostResponse, error)

	// GetShiftApiV1ShiftsShiftIdGet request
	GetShiftApiV1ShiftsShiftIdGetWithResponse(ctx context.Context, shiftId openapi_types.UUID, params *GetShiftApiV1ShiftsShiftIdGetParams, reqEditors ...RequestEditorFn) (*GetShiftApiV1ShiftsShiftIdGetResponse, error)

	// CloseShiftBySeniorCashierApiV1ShiftsShiftIdClosePost request with any body
	CloseShiftBySeniorCashierApiV1ShiftsShiftIdClosePostWithBodyWithResponse(ctx context.Context, shiftId openapi_types.UUID, params *CloseShiftBySeniorCashierApiV1ShiftsShiftIdClosePostParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CloseShiftBySeniorCashierApiV1ShiftsShiftIdClosePostResponse, error)

	CloseShiftBySeniorCashierApiV1ShiftsShiftIdClosePostWithResponse(ctx context.Context, shiftId openapi_types.UUID, params *CloseShiftBySeniorCashierApiV1ShiftsShiftIdClosePostParams, body CloseShiftBySeniorCashierApiV1ShiftsShiftIdClosePostJSONRequestBody, reqEditors ...RequestEditorFn) (*CloseShiftBySeniorCashierApiV1ShiftsShiftIdClosePostResponse, error)

	// GetAllTaxesApiV1TaxGet request
	GetAllTaxesApiV1TaxGetWithResponse(ctx context.Context, params *GetAllTaxesApiV1TaxGetParams, reqEditors ...RequestEditorFn) (*GetAllTaxesApiV1TaxGetResponse, error)

	// GetTransactionsApiV1TransactionsGet request
	GetTransactionsApiV1TransactionsGetWithResponse(ctx context.Context, params *GetTransactionsApiV1TransactionsGetParams, reqEditors ...RequestEditorFn) (*GetTransactionsApiV1TransactionsGetResponse, error)

	// GetTransactionApiV1TransactionsTransactionIdGet request
	GetTransactionApiV1TransactionsTransactionIdGetWithResponse(ctx context.Context, transactionId openapi_types.UUID, params *GetTransactionApiV1TransactionsTransactionIdGetParams, reqEditors ...RequestEditorFn) (*GetTransactionApiV1TransactionsTransactionIdGetResponse, error)

	// UpdateTransactionApiV1TransactionsTransactionIdPatch request with any body
	UpdateTransactionApiV1TransactionsTransactionIdPatchWithBodyWithResponse(ctx context.Context, transactionId openapi_types.UUID, params *UpdateTransactionApiV1TransactionsTransactionIdPatchParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateTransactionApiV1TransactionsTransactionIdPatchResponse, error)

	UpdateTransactionApiV1TransactionsTransactionIdPatchWithResponse(ctx context.Context, transactionId openapi_types.UUID, params *UpdateTransactionApiV1TransactionsTransactionIdPatchParams, body UpdateTransactionApiV1TransactionsTransactionIdPatchJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateTransactionApiV1TransactionsTransactionIdPatchResponse, error)

	// DeleteWebhookApiV1WebhookDelete request
	DeleteWebhookApiV1WebhookDeleteWithResponse(ctx context.Context, params *DeleteWebhookApiV1WebhookDeleteParams, reqEditors ...RequestEditorFn) (*DeleteWebhookApiV1WebhookDeleteResponse, error)

	// GetWebhookInfoApiV1WebhookGet request
	GetWebhookInfoApiV1WebhookGetWithResponse(ctx context.Context, params *GetWebhookInfoApiV1WebhookGetParams, reqEditors ...RequestEditorFn) (*GetWebhookInfoApiV1WebhookGetResponse, error)

	// SetWebhookApiV1WebhookPost request with any body
	SetWebhookApiV1WebhookPostWithBodyWithResponse(ctx context.Context, params *SetWebhookApiV1WebhookPostParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SetWebhookApiV1WebhookPostResponse, error)

	SetWebhookApiV1WebhookPostWithResponse(ctx context.Context, params *SetWebhookApiV1WebhookPostParams, body SetWebhookApiV1WebhookPostJSONRequestBody, reqEditors ...RequestEditorFn) (*SetWebhookApiV1WebhookPostResponse, error)
}

type GetCashRegistersApiV1CashRegistersGetResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PaginatedResultDetailedCashRegisterModel
	JSON422      *HTTPValidationError
}

// Status returns HTTPResponse.Status
func (r GetCashRegistersApiV1CashRegistersGetResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetCashRegistersApiV1CashRegistersGetResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AskOfflineCodesApiV1CashRegistersAskOfflineCodesGetResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON422      *HTTPValidationError
}

// Status returns HTTPResponse.Status
func (r AskOfflineCodesApiV1CashRegistersAskOfflineCodesGetResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AskOfflineCodesApiV1CashRegistersAskOfflineCodesGetResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetOfflineCodesApiV1CashRegistersGetOfflineCodesGetResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]DetailedOfflineFiscalCodeModel
	JSON422      *HTTPValidationError
}

// Status returns HTTPResponse.Status
func (r GetOfflineCodesApiV1CashRegistersGetOfflineCodesGetResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetOfflineCodesApiV1CashRegistersGetOfflineCodesGetResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetOfflineCodesCountApiV1CashRegistersGetOfflineCodesCountGetResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *OfflineCodesCountSchema
	JSON422      *HTTPValidationError
}

// Status returns HTTPResponse.Status
func (r GetOfflineCodesCountApiV1CashRegistersGetOfflineCodesCountGetResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetOfflineCodesCountApiV1CashRegistersGetOfflineCodesCountGetResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetOfflineTimeApiV1CashRegistersGetOfflineTimeGetResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *CashRegisterOfflineTime
	JSON422      *HTTPValidationError
}

// Status returns HTTPResponse.Status
func (r GetOfflineTimeApiV1CashRegistersGetOfflineTimeGetResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetOfflineTimeApiV1CashRegistersGetOfflineTimeGetResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GoOfflineActionApiV1CashRegistersGoOfflinePostResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *interface{}
	JSON422      *HTTPValidationError
}

// Status returns HTTPResponse.Status
func (r GoOfflineActionApiV1CashRegistersGoOfflinePostResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GoOfflineActionApiV1CashRegistersGoOfflinePostResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GoOnlineActionApiV1CashRegistersGoOnlinePostResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *interface{}
	JSON422      *HTTPValidationError
}

// Status returns HTTPResponse.Status
func (r GoOnlineActionApiV1CashRegistersGoOnlinePostResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GoOnlineActionApiV1CashRegistersGoOnlinePostResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetCashRegisterInfoApiV1CashRegistersInfoGetResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *CashRegisterDeviceModel
	JSON422      *HTTPValidationError
}

// Status returns HTTPResponse.Status
func (r GetCashRegisterInfoApiV1CashRegistersInfoGetResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetCashRegisterInfoApiV1CashRegistersInfoGetResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PingTaxServiceActionApiV1CashRegistersPingTaxServicePostResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *interface{}
	JSON422      *HTTPValidationError
}

// Status returns HTTPResponse.Status
func (r PingTaxServiceActionApiV1CashRegistersPingTaxServicePostResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PingTaxServiceActionApiV1CashRegistersPingTaxServicePostResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetCashRegisterApiV1CashRegistersCashRegisterIdGetResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *DetailedCashRegisterModel
	JSON422      *HTTPValidationError
}

// Status returns HTTPResponse.Status
func (r GetCashRegisterApiV1CashRegistersCashRegisterIdGetResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetCashRegisterApiV1CashRegistersCashRegisterIdGetResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CheckSignatureApiV1CashierCheckSignatureGetResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *CashierSignatureStatus
	JSON422      *HTTPValidationError
}

// Status returns HTTPResponse.Status
func (r CheckSignatureApiV1CashierCheckSignatureGetResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CheckSignatureApiV1CashierCheckSignatureGetResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetCashierProfileApiV1CashierMeGetResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *DetailedCashierModel
	JSON422      *HTTPValidationError
}

// Status returns HTTPResponse.Status
func (r GetCashierProfileApiV1CashierMeGetResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetCashierProfileApiV1CashierMeGetResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetCashierShiftApiV1CashierShiftGetResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ShiftWithCashRegisterModel
	JSON422      *HTTPValidationError
}

// Status returns HTTPResponse.Status
func (r GetCashierShiftApiV1CashierShiftGetResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetCashierShiftApiV1CashierShiftGetResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SignInCashierApiV1CashierSigninPostResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *CashierAccessTokenResponseModel
	JSON403      *HTTPError
	JSON422      *HTTPValidationError
}

// Status returns HTTPResponse.Status
func (r SignInCashierApiV1CashierSigninPostResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SignInCashierApiV1CashierSigninPostResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SignInCashierViaPinCodeApiV1CashierSigninPinCodePostResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *CashierAccessTokenResponseModel
	JSON403      *HTTPError
	JSON422      *HTTPValidationError
}

// Status returns HTTPResponse.Status
func (r SignInCashierViaPinCodeApiV1CashierSigninPinCodePostResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SignInCashierViaPinCodeApiV1CashierSigninPinCodePostResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SignOutCashierApiV1CashierSignoutPostResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON205      *interface{}
	JSON422      *HTTPValidationError
}

// Status returns HTTPResponse.Status
func (r SignOutCashierApiV1CashierSignoutPostResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SignOutCashierApiV1CashierSignoutPostResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetCurrencyRatesApiV1CurrencyRateGetResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]CurrencyRateModel
	JSON422      *HTTPValidationError
}

// Status returns HTTPResponse.Status
func (r GetCurrencyRatesApiV1CurrencyRateGetResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetCurrencyRatesApiV1CurrencyRateGetResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SetupCurrencyRatesApiV1CurrencyRateSetupPostResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]CurrencyRateModel
	JSON422      *HTTPValidationError
}

// Status returns HTTPResponse.Status
func (r SetupCurrencyRatesApiV1CurrencyRateSetupPostResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SetupCurrencyRatesApiV1CurrencyRateSetupPostResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetCurrencyRateApiV1CurrencyRateCurrencyCodeGetResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *CurrencyRateModel
	JSON422      *HTTPValidationError
}

// Status returns HTTPResponse.Status
func (r GetCurrencyRateApiV1CurrencyRateCurrencyCodeGetResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetCurrencyRateApiV1CurrencyRateCurrencyCodeGetResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GoodsReportApiV1ExtendedReportsGoodsPostResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PublicReportTaskSchema
	JSON422      *HTTPValidationError
}

// Status returns HTTPResponse.Status
func (r GoodsReportApiV1ExtendedReportsGoodsPostResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GoodsReportApiV1ExtendedReportsGoodsPostResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetReportTaskByIdApiV1ExtendedReportsReportTaskIdGetResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PublicReportTaskSchema
	JSON422      *HTTPValidationError
}

// Status returns HTTPResponse.Status
func (r GetReportTaskByIdApiV1ExtendedReportsReportTaskIdGetResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetReportTaskByIdApiV1ExtendedReportsReportTaskIdGetResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetReportXlsxByIdApiV1ExtendedReportsReportTaskIdReportXlsxGetResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PublicReportTaskSchema
	JSON422      *HTTPValidationError
}

// Status returns HTTPResponse.Status
func (r GetReportXlsxByIdApiV1ExtendedReportsReportTaskIdReportXlsxGetResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetReportXlsxByIdApiV1ExtendedReportsReportTaskIdReportXlsxGetResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetGoodsApiV1GoodsGetResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PaginatedResultGoodModel
	JSON422      *HTTPValidationError
}

// Status returns HTTPResponse.Status
func (r GetGoodsApiV1GoodsGetResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetGoodsApiV1GoodsGetResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ExportGoodsFileApiV1GoodsExportFileTaskIdGetResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *interface{}
	JSON422      *HTTPValidationError
}

// Status returns HTTPResponse.Status
func (r ExportGoodsFileApiV1GoodsExportFileTaskIdGetResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ExportGoodsFileApiV1GoodsExportFileTaskIdGetResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ExportGoodsTaskStatusApiV1GoodsExportTaskStatusTaskIdGetResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *CheckStatusResponseSchema
	JSON422      *HTTPValidationError
}

// Status returns HTTPResponse.Status
func (r ExportGoodsTaskStatusApiV1GoodsExportTaskStatusTaskIdGetResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ExportGoodsTaskStatusApiV1GoodsExportTaskStatusTaskIdGetResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ExportGoodsApiV1GoodsExportExportExtensionGetResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *OperationBaseResponseSchema
	JSON422      *HTTPValidationError
}

// Status returns HTTPResponse.Status
func (r ExportGoodsApiV1GoodsExportExportExtensionGetResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ExportGoodsApiV1GoodsExportExportExtensionGetResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ImportGoodsApplyChangesApiV1GoodsImportApplyChangesTaskIdPostResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *OperationBaseResponseSchema
	JSON422      *HTTPValidationError
}

// Status returns HTTPResponse.Status
func (r ImportGoodsApplyChangesApiV1GoodsImportApplyChangesTaskIdPostResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ImportGoodsApplyChangesApiV1GoodsImportApplyChangesTaskIdPostResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ImportGoodsTaskStatusApiV1GoodsImportTaskStatusTaskIdGetResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *CheckStatusResponseSchema
	JSON422      *HTTPValidationError
}

// Status returns HTTPResponse.Status
func (r ImportGoodsTaskStatusApiV1GoodsImportTaskStatusTaskIdGetResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ImportGoodsTaskStatusApiV1GoodsImportTaskStatusTaskIdGetResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ImportGoodsFromFileApiV1GoodsImportUploadPostResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *OperationBaseResponseSchema
	JSON422      *HTTPValidationError
}

// Status returns HTTPResponse.Status
func (r ImportGoodsFromFileApiV1GoodsImportUploadPostResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ImportGoodsFromFileApiV1GoodsImportUploadPostResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetGoodApiV1GoodsGoodIdGetResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *SrsoSchemaGoodSchemaGoodModel
	JSON422      *HTTPValidationError
}

// Status returns HTTPResponse.Status
func (r GetGoodApiV1GoodsGoodIdGetResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetGoodApiV1GoodsGoodIdGetResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetOrdersApiV1OrdersGetResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PaginatedResultOrderModel
	JSON422      *HTTPValidationError
}

// Status returns HTTPResponse.Status
func (r GetOrdersApiV1OrdersGetResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetOrdersApiV1OrdersGetResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AddOrdersApiV1OrdersPostResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		union json.RawMessage
	}
	JSON422 *HTTPValidationError
}

// Status returns HTTPResponse.Status
func (r AddOrdersApiV1OrdersPostResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AddOrdersApiV1OrdersPostResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CloseNotFiscalizeOrderApiV1OrdersClosePatchResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *OrderModel
	JSON422      *HTTPValidationError
}

// Status returns HTTPResponse.Status
func (r CloseNotFiscalizeOrderApiV1OrdersClosePatchResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CloseNotFiscalizeOrderApiV1OrdersClosePatchResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateCustomOrderStatusApiV1OrdersCustomStatusOrderIdPatchResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *OrderModel
	JSON422      *HTTPValidationError
}

// Status returns HTTPResponse.Status
func (r UpdateCustomOrderStatusApiV1OrdersCustomStatusOrderIdPatchResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateCustomOrderStatusApiV1OrdersCustomStatusOrderIdPatchResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteIntegrationApiV1OrdersIntegrationDeleteResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *DeleteIntegrationSchema
	JSON422      *HTTPValidationError
}

// Status returns HTTPResponse.Status
func (r DeleteIntegrationApiV1OrdersIntegrationDeleteResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteIntegrationApiV1OrdersIntegrationDeleteResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetIntegrationApiV1OrdersIntegrationGetResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *IntegrationInfoSchema
	JSON422      *HTTPValidationError
}

// Status returns HTTPResponse.Status
func (r GetIntegrationApiV1OrdersIntegrationGetResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetIntegrationApiV1OrdersIntegrationGetResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SetIntegrationApiV1OrdersIntegrationPostResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *IntegrationInfoResponseSchema
	JSON422      *HTTPValidationError
}

// Status returns HTTPResponse.Status
func (r SetIntegrationApiV1OrdersIntegrationPostResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SetIntegrationApiV1OrdersIntegrationPostResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type EditOrderApiV1OrdersIntegrationEditOrderPostResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *IntegrationEditOrderReceiptSchema
	JSON422      *HTTPValidationError
}

// Status returns HTTPResponse.Status
func (r EditOrderApiV1OrdersIntegrationEditOrderPostResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r EditOrderApiV1OrdersIntegrationEditOrderPostResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RunOrdersSynchronizationApiV1OrdersSyncPostResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *interface{}
	JSON422      *HTTPValidationError
}

// Status returns HTTPResponse.Status
func (r RunOrdersSynchronizationApiV1OrdersSyncPostResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RunOrdersSynchronizationApiV1OrdersSyncPostResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetOrderApiV1OrdersOrderIdGetResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *OrderModel
	JSON422      *HTTPValidationError
}

// Status returns HTTPResponse.Status
func (r GetOrderApiV1OrdersOrderIdGetResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetOrderApiV1OrdersOrderIdGetResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CancelOrderApiV1OrdersOrderIdPatchResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *OrderModel
	JSON422      *HTTPValidationError
}

// Status returns HTTPResponse.Status
func (r CancelOrderApiV1OrdersOrderIdPatchResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CancelOrderApiV1OrdersOrderIdPatchResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetCurrentOrganizationLogoApiV1OrganizationLogoPngGetResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *interface{}
	JSON422      *HTTPValidationError
}

// Status returns HTTPResponse.Status
func (r GetCurrentOrganizationLogoApiV1OrganizationLogoPngGetResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetCurrentOrganizationLogoApiV1OrganizationLogoPngGetResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetCurrentOrganizationReceiptSettingsApiV1OrganizationReceiptConfigGetResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *OrganizationReceiptConfigSchema
	JSON422      *HTTPValidationError
}

// Status returns HTTPResponse.Status
func (r GetCurrentOrganizationReceiptSettingsApiV1OrganizationReceiptConfigGetResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetCurrentOrganizationReceiptSettingsApiV1OrganizationReceiptConfigGetResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetCurrentOrganizationSmsBillingBalanceApiV1OrganizationSmsBillingGetResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *OrganizationBillingSchema
	JSON422      *HTTPValidationError
}

// Status returns HTTPResponse.Status
func (r GetCurrentOrganizationSmsBillingBalanceApiV1OrganizationSmsBillingGetResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetCurrentOrganizationSmsBillingBalanceApiV1OrganizationSmsBillingGetResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetCurrentOrganizationTextLogoApiV1OrganizationTextLogoPngGetResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *interface{}
	JSON422      *HTTPValidationError
}

// Status returns HTTPResponse.Status
func (r GetCurrentOrganizationTextLogoApiV1OrganizationTextLogoPngGetResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetCurrentOrganizationTextLogoApiV1OrganizationTextLogoPngGetResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetReceiptsApiV1ReceiptsGetResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PaginatedResultReceiptModel
	JSON422      *HTTPValidationError
}

// Status returns HTTPResponse.Status
func (r GetReceiptsApiV1ReceiptsGetResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetReceiptsApiV1ReceiptsGetResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AddExternalReceiptApiV1ReceiptsAddExternalPostResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *ReceiptModel
	JSON422      *HTTPValidationError
}

// Status returns HTTPResponse.Status
func (r AddExternalReceiptApiV1ReceiptsAddExternalPostResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AddExternalReceiptApiV1ReceiptsAddExternalPostResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CashWithdrawalApiV1ReceiptsCashWithdrawalPostResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ReceiptModel
	JSON422      *HTTPValidationError
}

// Status returns HTTPResponse.Status
func (r CashWithdrawalApiV1ReceiptsCashWithdrawalPostResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CashWithdrawalApiV1ReceiptsCashWithdrawalPostResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ExchangeApiV1ReceiptsCurrencyExchangePostResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ReceiptModel
	JSON422      *HTTPValidationError
}

// Status returns HTTPResponse.Status
func (r ExchangeApiV1ReceiptsCurrencyExchangePostResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ExchangeApiV1ReceiptsCurrencyExchangePostResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetReceiptsSearchApiV1ReceiptsSearchGetResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PaginatedResultReceiptModel
	JSON422      *HTTPValidationError
}

// Status returns HTTPResponse.Status
func (r GetReceiptsSearchApiV1ReceiptsSearchGetResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetReceiptsSearchApiV1ReceiptsSearchGetResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateReceiptApiV1ReceiptsSellPostResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *ReceiptModel
	JSON422      *HTTPValidationError
}

// Status returns HTTPResponse.Status
func (r CreateReceiptApiV1ReceiptsSellPostResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateReceiptApiV1ReceiptsSellPostResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateOfflineReceiptApiV1ReceiptsSellOfflinePostResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *ReceiptModel
	JSON422      *HTTPValidationError
}

// Status returns HTTPResponse.Status
func (r CreateOfflineReceiptApiV1ReceiptsSellOfflinePostResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateOfflineReceiptApiV1ReceiptsSellOfflinePostResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateServiceReceiptApiV1ReceiptsServicePostResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *ReceiptModel
	JSON422      *HTTPValidationError
}

// Status returns HTTPResponse.Status
func (r CreateServiceReceiptApiV1ReceiptsServicePostResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateServiceReceiptApiV1ReceiptsServicePostResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateServiceCurrencyReceiptApiV1ReceiptsServiceCurrencyPostResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *ReceiptModel
	JSON422      *HTTPValidationError
}

// Status returns HTTPResponse.Status
func (r CreateServiceCurrencyReceiptApiV1ReceiptsServiceCurrencyPostResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateServiceCurrencyReceiptApiV1ReceiptsServiceCurrencyPostResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetReceiptApiV1ReceiptsReceiptIdGetResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ReceiptModel
	JSON422      *HTTPValidationError
}

// Status returns HTTPResponse.Status
func (r GetReceiptApiV1ReceiptsReceiptIdGetResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetReceiptApiV1ReceiptsReceiptIdGetResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SendReceiptToEmailApiV1ReceiptsReceiptIdEmailPostResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *interface{}
	JSON422      *HTTPValidationError
}

// Status returns HTTPResponse.Status
func (r SendReceiptToEmailApiV1ReceiptsReceiptIdEmailPostResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SendReceiptToEmailApiV1ReceiptsReceiptIdEmailPostResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetReceiptHtmlApiV1ReceiptsReceiptIdHtmlGetResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON422      *HTTPValidationError
}

// Status returns HTTPResponse.Status
func (r GetReceiptHtmlApiV1ReceiptsReceiptIdHtmlGetResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetReceiptHtmlApiV1ReceiptsReceiptIdHtmlGetResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetReceiptPdfApiV1ReceiptsReceiptIdPdfGetResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON422      *HTTPValidationError
}

// Status returns HTTPResponse.Status
func (r GetReceiptPdfApiV1ReceiptsReceiptIdPdfGetResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetReceiptPdfApiV1ReceiptsReceiptIdPdfGetResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetReceiptPngApiV1ReceiptsReceiptIdPngGetResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON422      *HTTPValidationError
}

// Status returns HTTPResponse.Status
func (r GetReceiptPngApiV1ReceiptsReceiptIdPngGetResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetReceiptPngApiV1ReceiptsReceiptIdPngGetResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetReceiptQrCodeImageApiV1ReceiptsReceiptIdQrcodeGetResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON422      *HTTPValidationError
}

// Status returns HTTPResponse.Status
func (r GetReceiptQrCodeImageApiV1ReceiptsReceiptIdQrcodeGetResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetReceiptQrCodeImageApiV1ReceiptsReceiptIdQrcodeGetResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SendReceiptViaSmsApiV1ReceiptsReceiptIdSmsPostResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *interface{}
	JSON422      *HTTPValidationError
}

// Status returns HTTPResponse.Status
func (r SendReceiptViaSmsApiV1ReceiptsReceiptIdSmsPostResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SendReceiptViaSmsApiV1ReceiptsReceiptIdSmsPostResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetReceiptTextApiV1ReceiptsReceiptIdTextGetResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON422      *HTTPValidationError
}

// Status returns HTTPResponse.Status
func (r GetReceiptTextApiV1ReceiptsReceiptIdTextGetResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetReceiptTextApiV1ReceiptsReceiptIdTextGetResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetReceiptXmlApiV1ReceiptsReceiptIdXmlGetResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON422      *HTTPValidationError
}

// Status returns HTTPResponse.Status
func (r GetReceiptXmlApiV1ReceiptsReceiptIdXmlGetResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetReceiptXmlApiV1ReceiptsReceiptIdXmlGetResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetReportsApiV1ReportsGetResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PaginatedResultReportModel
	JSON422      *HTTPValidationError
}

// Status returns HTTPResponse.Status
func (r GetReportsApiV1ReportsGetResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetReportsApiV1ReportsGetResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateXReportApiV1ReportsPostResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *ReportModel
	JSON422      *HTTPValidationError
}

// Status returns HTTPResponse.Status
func (r CreateXReportApiV1ReportsPostResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateXReportApiV1ReportsPostResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AddExternalReportApiV1ReportsAddExternalPostResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *ReportModel
	JSON422      *HTTPValidationError
}

// Status returns HTTPResponse.Status
func (r AddExternalReportApiV1ReportsAddExternalPostResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AddExternalReportApiV1ReportsAddExternalPostResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetPeriodicalReportApiV1ReportsPeriodicalGetResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON422      *HTTPValidationError
}

// Status returns HTTPResponse.Status
func (r GetPeriodicalReportApiV1ReportsPeriodicalGetResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetPeriodicalReportApiV1ReportsPeriodicalGetResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetSearchReportsApiV1ReportsSearchGetResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PaginatedResultReportModel
	JSON422      *HTTPValidationError
}

// Status returns HTTPResponse.Status
func (r GetSearchReportsApiV1ReportsSearchGetResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetSearchReportsApiV1ReportsSearchGetResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetReportApiV1ReportsReportIdGetResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ReportModel
	JSON422      *HTTPValidationError
}

// Status returns HTTPResponse.Status
func (r GetReportApiV1ReportsReportIdGetResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetReportApiV1ReportsReportIdGetResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetReportTextApiV1ReportsReportIdTextGetResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON422      *HTTPValidationError
}

// Status returns HTTPResponse.Status
func (r GetReportTextApiV1ReportsReportIdTextGetResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetReportTextApiV1ReportsReportIdTextGetResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetShiftsApiV1ShiftsGetResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PaginatedResultShiftWithCashRegisterModel
	JSON422      *HTTPValidationError
}

// Status returns HTTPResponse.Status
func (r GetShiftsApiV1ShiftsGetResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetShiftsApiV1ShiftsGetResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateShiftApiV1ShiftsPostResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON202      *ShiftWithCashierAndCashRegister
	JSON422      *HTTPValidationError
}

// Status returns HTTPResponse.Status
func (r CreateShiftApiV1ShiftsPostResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateShiftApiV1ShiftsPostResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CloseShiftApiV1ShiftsClosePostResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON202      *ShiftWithCashierAndCashRegister
	JSON422      *HTTPValidationError
}

// Status returns HTTPResponse.Status
func (r CloseShiftApiV1ShiftsClosePostResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CloseShiftApiV1ShiftsClosePostResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetShiftApiV1ShiftsShiftIdGetResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ShiftWithCashierAndCashRegister
	JSON422      *HTTPValidationError
}

// Status returns HTTPResponse.Status
func (r GetShiftApiV1ShiftsShiftIdGetResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetShiftApiV1ShiftsShiftIdGetResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CloseShiftBySeniorCashierApiV1ShiftsShiftIdClosePostResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ShiftWithCashierAndCashRegister
	JSON422      *HTTPValidationError
}

// Status returns HTTPResponse.Status
func (r CloseShiftBySeniorCashierApiV1ShiftsShiftIdClosePostResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CloseShiftBySeniorCashierApiV1ShiftsShiftIdClosePostResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetAllTaxesApiV1TaxGetResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]TaxModel
	JSON422      *HTTPValidationError
}

// Status returns HTTPResponse.Status
func (r GetAllTaxesApiV1TaxGetResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAllTaxesApiV1TaxGetResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetTransactionsApiV1TransactionsGetResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PaginatedResultShortTransaction
	JSON422      *HTTPValidationError
}

// Status returns HTTPResponse.Status
func (r GetTransactionsApiV1TransactionsGetResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetTransactionsApiV1TransactionsGetResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetTransactionApiV1TransactionsTransactionIdGetResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *TransactionModel
	JSON422      *HTTPValidationError
}

// Status returns HTTPResponse.Status
func (r GetTransactionApiV1TransactionsTransactionIdGetResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetTransactionApiV1TransactionsTransactionIdGetResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateTransactionApiV1TransactionsTransactionIdPatchResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON202      *TransactionModel
	JSON422      *HTTPValidationError
}

// Status returns HTTPResponse.Status
func (r UpdateTransactionApiV1TransactionsTransactionIdPatchResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateTransactionApiV1TransactionsTransactionIdPatchResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteWebhookApiV1WebhookDeleteResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *DeleteWebhookSchema
	JSON422      *HTTPValidationError
}

// Status returns HTTPResponse.Status
func (r DeleteWebhookApiV1WebhookDeleteResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteWebhookApiV1WebhookDeleteResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetWebhookInfoApiV1WebhookGetResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *WebhookInfoSchema
	JSON422      *HTTPValidationError
}

// Status returns HTTPResponse.Status
func (r GetWebhookInfoApiV1WebhookGetResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetWebhookInfoApiV1WebhookGetResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SetWebhookApiV1WebhookPostResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *WebhookInfoResponseSchema
	JSON422      *HTTPValidationError
}

// Status returns HTTPResponse.Status
func (r SetWebhookApiV1WebhookPostResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SetWebhookApiV1WebhookPostResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// GetCashRegistersApiV1CashRegistersGetWithResponse request returning *GetCashRegistersApiV1CashRegistersGetResponse
func (c *ClientWithResponses) GetCashRegistersApiV1CashRegistersGetWithResponse(ctx context.Context, params *GetCashRegistersApiV1CashRegistersGetParams, reqEditors ...RequestEditorFn) (*GetCashRegistersApiV1CashRegistersGetResponse, error) {
	rsp, err := c.GetCashRegistersApiV1CashRegistersGet(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetCashRegistersApiV1CashRegistersGetResponse(rsp)
}

// AskOfflineCodesApiV1CashRegistersAskOfflineCodesGetWithResponse request returning *AskOfflineCodesApiV1CashRegistersAskOfflineCodesGetResponse
func (c *ClientWithResponses) AskOfflineCodesApiV1CashRegistersAskOfflineCodesGetWithResponse(ctx context.Context, params *AskOfflineCodesApiV1CashRegistersAskOfflineCodesGetParams, reqEditors ...RequestEditorFn) (*AskOfflineCodesApiV1CashRegistersAskOfflineCodesGetResponse, error) {
	rsp, err := c.AskOfflineCodesApiV1CashRegistersAskOfflineCodesGet(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAskOfflineCodesApiV1CashRegistersAskOfflineCodesGetResponse(rsp)
}

// GetOfflineCodesApiV1CashRegistersGetOfflineCodesGetWithResponse request returning *GetOfflineCodesApiV1CashRegistersGetOfflineCodesGetResponse
func (c *ClientWithResponses) GetOfflineCodesApiV1CashRegistersGetOfflineCodesGetWithResponse(ctx context.Context, params *GetOfflineCodesApiV1CashRegistersGetOfflineCodesGetParams, reqEditors ...RequestEditorFn) (*GetOfflineCodesApiV1CashRegistersGetOfflineCodesGetResponse, error) {
	rsp, err := c.GetOfflineCodesApiV1CashRegistersGetOfflineCodesGet(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetOfflineCodesApiV1CashRegistersGetOfflineCodesGetResponse(rsp)
}

// GetOfflineCodesCountApiV1CashRegistersGetOfflineCodesCountGetWithResponse request returning *GetOfflineCodesCountApiV1CashRegistersGetOfflineCodesCountGetResponse
func (c *ClientWithResponses) GetOfflineCodesCountApiV1CashRegistersGetOfflineCodesCountGetWithResponse(ctx context.Context, params *GetOfflineCodesCountApiV1CashRegistersGetOfflineCodesCountGetParams, reqEditors ...RequestEditorFn) (*GetOfflineCodesCountApiV1CashRegistersGetOfflineCodesCountGetResponse, error) {
	rsp, err := c.GetOfflineCodesCountApiV1CashRegistersGetOfflineCodesCountGet(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetOfflineCodesCountApiV1CashRegistersGetOfflineCodesCountGetResponse(rsp)
}

// GetOfflineTimeApiV1CashRegistersGetOfflineTimeGetWithResponse request returning *GetOfflineTimeApiV1CashRegistersGetOfflineTimeGetResponse
func (c *ClientWithResponses) GetOfflineTimeApiV1CashRegistersGetOfflineTimeGetWithResponse(ctx context.Context, params *GetOfflineTimeApiV1CashRegistersGetOfflineTimeGetParams, reqEditors ...RequestEditorFn) (*GetOfflineTimeApiV1CashRegistersGetOfflineTimeGetResponse, error) {
	rsp, err := c.GetOfflineTimeApiV1CashRegistersGetOfflineTimeGet(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetOfflineTimeApiV1CashRegistersGetOfflineTimeGetResponse(rsp)
}

// GoOfflineActionApiV1CashRegistersGoOfflinePostWithBodyWithResponse request with arbitrary body returning *GoOfflineActionApiV1CashRegistersGoOfflinePostResponse
func (c *ClientWithResponses) GoOfflineActionApiV1CashRegistersGoOfflinePostWithBodyWithResponse(ctx context.Context, params *GoOfflineActionApiV1CashRegistersGoOfflinePostParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*GoOfflineActionApiV1CashRegistersGoOfflinePostResponse, error) {
	rsp, err := c.GoOfflineActionApiV1CashRegistersGoOfflinePostWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGoOfflineActionApiV1CashRegistersGoOfflinePostResponse(rsp)
}

func (c *ClientWithResponses) GoOfflineActionApiV1CashRegistersGoOfflinePostWithResponse(ctx context.Context, params *GoOfflineActionApiV1CashRegistersGoOfflinePostParams, body GoOfflineActionApiV1CashRegistersGoOfflinePostJSONRequestBody, reqEditors ...RequestEditorFn) (*GoOfflineActionApiV1CashRegistersGoOfflinePostResponse, error) {
	rsp, err := c.GoOfflineActionApiV1CashRegistersGoOfflinePost(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGoOfflineActionApiV1CashRegistersGoOfflinePostResponse(rsp)
}

// GoOnlineActionApiV1CashRegistersGoOnlinePostWithResponse request returning *GoOnlineActionApiV1CashRegistersGoOnlinePostResponse
func (c *ClientWithResponses) GoOnlineActionApiV1CashRegistersGoOnlinePostWithResponse(ctx context.Context, params *GoOnlineActionApiV1CashRegistersGoOnlinePostParams, reqEditors ...RequestEditorFn) (*GoOnlineActionApiV1CashRegistersGoOnlinePostResponse, error) {
	rsp, err := c.GoOnlineActionApiV1CashRegistersGoOnlinePost(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGoOnlineActionApiV1CashRegistersGoOnlinePostResponse(rsp)
}

// GetCashRegisterInfoApiV1CashRegistersInfoGetWithResponse request returning *GetCashRegisterInfoApiV1CashRegistersInfoGetResponse
func (c *ClientWithResponses) GetCashRegisterInfoApiV1CashRegistersInfoGetWithResponse(ctx context.Context, params *GetCashRegisterInfoApiV1CashRegistersInfoGetParams, reqEditors ...RequestEditorFn) (*GetCashRegisterInfoApiV1CashRegistersInfoGetResponse, error) {
	rsp, err := c.GetCashRegisterInfoApiV1CashRegistersInfoGet(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetCashRegisterInfoApiV1CashRegistersInfoGetResponse(rsp)
}

// PingTaxServiceActionApiV1CashRegistersPingTaxServicePostWithResponse request returning *PingTaxServiceActionApiV1CashRegistersPingTaxServicePostResponse
func (c *ClientWithResponses) PingTaxServiceActionApiV1CashRegistersPingTaxServicePostWithResponse(ctx context.Context, params *PingTaxServiceActionApiV1CashRegistersPingTaxServicePostParams, reqEditors ...RequestEditorFn) (*PingTaxServiceActionApiV1CashRegistersPingTaxServicePostResponse, error) {
	rsp, err := c.PingTaxServiceActionApiV1CashRegistersPingTaxServicePost(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePingTaxServiceActionApiV1CashRegistersPingTaxServicePostResponse(rsp)
}

// GetCashRegisterApiV1CashRegistersCashRegisterIdGetWithResponse request returning *GetCashRegisterApiV1CashRegistersCashRegisterIdGetResponse
func (c *ClientWithResponses) GetCashRegisterApiV1CashRegistersCashRegisterIdGetWithResponse(ctx context.Context, cashRegisterId openapi_types.UUID, params *GetCashRegisterApiV1CashRegistersCashRegisterIdGetParams, reqEditors ...RequestEditorFn) (*GetCashRegisterApiV1CashRegistersCashRegisterIdGetResponse, error) {
	rsp, err := c.GetCashRegisterApiV1CashRegistersCashRegisterIdGet(ctx, cashRegisterId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetCashRegisterApiV1CashRegistersCashRegisterIdGetResponse(rsp)
}

// CheckSignatureApiV1CashierCheckSignatureGetWithResponse request returning *CheckSignatureApiV1CashierCheckSignatureGetResponse
func (c *ClientWithResponses) CheckSignatureApiV1CashierCheckSignatureGetWithResponse(ctx context.Context, params *CheckSignatureApiV1CashierCheckSignatureGetParams, reqEditors ...RequestEditorFn) (*CheckSignatureApiV1CashierCheckSignatureGetResponse, error) {
	rsp, err := c.CheckSignatureApiV1CashierCheckSignatureGet(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCheckSignatureApiV1CashierCheckSignatureGetResponse(rsp)
}

// GetCashierProfileApiV1CashierMeGetWithResponse request returning *GetCashierProfileApiV1CashierMeGetResponse
func (c *ClientWithResponses) GetCashierProfileApiV1CashierMeGetWithResponse(ctx context.Context, params *GetCashierProfileApiV1CashierMeGetParams, reqEditors ...RequestEditorFn) (*GetCashierProfileApiV1CashierMeGetResponse, error) {
	rsp, err := c.GetCashierProfileApiV1CashierMeGet(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetCashierProfileApiV1CashierMeGetResponse(rsp)
}

// GetCashierShiftApiV1CashierShiftGetWithResponse request returning *GetCashierShiftApiV1CashierShiftGetResponse
func (c *ClientWithResponses) GetCashierShiftApiV1CashierShiftGetWithResponse(ctx context.Context, params *GetCashierShiftApiV1CashierShiftGetParams, reqEditors ...RequestEditorFn) (*GetCashierShiftApiV1CashierShiftGetResponse, error) {
	rsp, err := c.GetCashierShiftApiV1CashierShiftGet(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetCashierShiftApiV1CashierShiftGetResponse(rsp)
}

// SignInCashierApiV1CashierSigninPostWithBodyWithResponse request with arbitrary body returning *SignInCashierApiV1CashierSigninPostResponse
func (c *ClientWithResponses) SignInCashierApiV1CashierSigninPostWithBodyWithResponse(ctx context.Context, params *SignInCashierApiV1CashierSigninPostParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SignInCashierApiV1CashierSigninPostResponse, error) {
	rsp, err := c.SignInCashierApiV1CashierSigninPostWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSignInCashierApiV1CashierSigninPostResponse(rsp)
}

func (c *ClientWithResponses) SignInCashierApiV1CashierSigninPostWithResponse(ctx context.Context, params *SignInCashierApiV1CashierSigninPostParams, body SignInCashierApiV1CashierSigninPostJSONRequestBody, reqEditors ...RequestEditorFn) (*SignInCashierApiV1CashierSigninPostResponse, error) {
	rsp, err := c.SignInCashierApiV1CashierSigninPost(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSignInCashierApiV1CashierSigninPostResponse(rsp)
}

// SignInCashierViaPinCodeApiV1CashierSigninPinCodePostWithBodyWithResponse request with arbitrary body returning *SignInCashierViaPinCodeApiV1CashierSigninPinCodePostResponse
func (c *ClientWithResponses) SignInCashierViaPinCodeApiV1CashierSigninPinCodePostWithBodyWithResponse(ctx context.Context, params *SignInCashierViaPinCodeApiV1CashierSigninPinCodePostParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SignInCashierViaPinCodeApiV1CashierSigninPinCodePostResponse, error) {
	rsp, err := c.SignInCashierViaPinCodeApiV1CashierSigninPinCodePostWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSignInCashierViaPinCodeApiV1CashierSigninPinCodePostResponse(rsp)
}

func (c *ClientWithResponses) SignInCashierViaPinCodeApiV1CashierSigninPinCodePostWithResponse(ctx context.Context, params *SignInCashierViaPinCodeApiV1CashierSigninPinCodePostParams, body SignInCashierViaPinCodeApiV1CashierSigninPinCodePostJSONRequestBody, reqEditors ...RequestEditorFn) (*SignInCashierViaPinCodeApiV1CashierSigninPinCodePostResponse, error) {
	rsp, err := c.SignInCashierViaPinCodeApiV1CashierSigninPinCodePost(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSignInCashierViaPinCodeApiV1CashierSigninPinCodePostResponse(rsp)
}

// SignOutCashierApiV1CashierSignoutPostWithResponse request returning *SignOutCashierApiV1CashierSignoutPostResponse
func (c *ClientWithResponses) SignOutCashierApiV1CashierSignoutPostWithResponse(ctx context.Context, params *SignOutCashierApiV1CashierSignoutPostParams, reqEditors ...RequestEditorFn) (*SignOutCashierApiV1CashierSignoutPostResponse, error) {
	rsp, err := c.SignOutCashierApiV1CashierSignoutPost(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSignOutCashierApiV1CashierSignoutPostResponse(rsp)
}

// GetCurrencyRatesApiV1CurrencyRateGetWithResponse request returning *GetCurrencyRatesApiV1CurrencyRateGetResponse
func (c *ClientWithResponses) GetCurrencyRatesApiV1CurrencyRateGetWithResponse(ctx context.Context, params *GetCurrencyRatesApiV1CurrencyRateGetParams, reqEditors ...RequestEditorFn) (*GetCurrencyRatesApiV1CurrencyRateGetResponse, error) {
	rsp, err := c.GetCurrencyRatesApiV1CurrencyRateGet(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetCurrencyRatesApiV1CurrencyRateGetResponse(rsp)
}

// SetupCurrencyRatesApiV1CurrencyRateSetupPostWithBodyWithResponse request with arbitrary body returning *SetupCurrencyRatesApiV1CurrencyRateSetupPostResponse
func (c *ClientWithResponses) SetupCurrencyRatesApiV1CurrencyRateSetupPostWithBodyWithResponse(ctx context.Context, params *SetupCurrencyRatesApiV1CurrencyRateSetupPostParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SetupCurrencyRatesApiV1CurrencyRateSetupPostResponse, error) {
	rsp, err := c.SetupCurrencyRatesApiV1CurrencyRateSetupPostWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSetupCurrencyRatesApiV1CurrencyRateSetupPostResponse(rsp)
}

func (c *ClientWithResponses) SetupCurrencyRatesApiV1CurrencyRateSetupPostWithResponse(ctx context.Context, params *SetupCurrencyRatesApiV1CurrencyRateSetupPostParams, body SetupCurrencyRatesApiV1CurrencyRateSetupPostJSONRequestBody, reqEditors ...RequestEditorFn) (*SetupCurrencyRatesApiV1CurrencyRateSetupPostResponse, error) {
	rsp, err := c.SetupCurrencyRatesApiV1CurrencyRateSetupPost(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSetupCurrencyRatesApiV1CurrencyRateSetupPostResponse(rsp)
}

// GetCurrencyRateApiV1CurrencyRateCurrencyCodeGetWithResponse request returning *GetCurrencyRateApiV1CurrencyRateCurrencyCodeGetResponse
func (c *ClientWithResponses) GetCurrencyRateApiV1CurrencyRateCurrencyCodeGetWithResponse(ctx context.Context, currencyCode string, params *GetCurrencyRateApiV1CurrencyRateCurrencyCodeGetParams, reqEditors ...RequestEditorFn) (*GetCurrencyRateApiV1CurrencyRateCurrencyCodeGetResponse, error) {
	rsp, err := c.GetCurrencyRateApiV1CurrencyRateCurrencyCodeGet(ctx, currencyCode, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetCurrencyRateApiV1CurrencyRateCurrencyCodeGetResponse(rsp)
}

// GoodsReportApiV1ExtendedReportsGoodsPostWithBodyWithResponse request with arbitrary body returning *GoodsReportApiV1ExtendedReportsGoodsPostResponse
func (c *ClientWithResponses) GoodsReportApiV1ExtendedReportsGoodsPostWithBodyWithResponse(ctx context.Context, params *GoodsReportApiV1ExtendedReportsGoodsPostParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*GoodsReportApiV1ExtendedReportsGoodsPostResponse, error) {
	rsp, err := c.GoodsReportApiV1ExtendedReportsGoodsPostWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGoodsReportApiV1ExtendedReportsGoodsPostResponse(rsp)
}

func (c *ClientWithResponses) GoodsReportApiV1ExtendedReportsGoodsPostWithResponse(ctx context.Context, params *GoodsReportApiV1ExtendedReportsGoodsPostParams, body GoodsReportApiV1ExtendedReportsGoodsPostJSONRequestBody, reqEditors ...RequestEditorFn) (*GoodsReportApiV1ExtendedReportsGoodsPostResponse, error) {
	rsp, err := c.GoodsReportApiV1ExtendedReportsGoodsPost(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGoodsReportApiV1ExtendedReportsGoodsPostResponse(rsp)
}

// GetReportTaskByIdApiV1ExtendedReportsReportTaskIdGetWithResponse request returning *GetReportTaskByIdApiV1ExtendedReportsReportTaskIdGetResponse
func (c *ClientWithResponses) GetReportTaskByIdApiV1ExtendedReportsReportTaskIdGetWithResponse(ctx context.Context, reportTaskId openapi_types.UUID, params *GetReportTaskByIdApiV1ExtendedReportsReportTaskIdGetParams, reqEditors ...RequestEditorFn) (*GetReportTaskByIdApiV1ExtendedReportsReportTaskIdGetResponse, error) {
	rsp, err := c.GetReportTaskByIdApiV1ExtendedReportsReportTaskIdGet(ctx, reportTaskId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetReportTaskByIdApiV1ExtendedReportsReportTaskIdGetResponse(rsp)
}

// GetReportXlsxByIdApiV1ExtendedReportsReportTaskIdReportXlsxGetWithResponse request returning *GetReportXlsxByIdApiV1ExtendedReportsReportTaskIdReportXlsxGetResponse
func (c *ClientWithResponses) GetReportXlsxByIdApiV1ExtendedReportsReportTaskIdReportXlsxGetWithResponse(ctx context.Context, reportTaskId openapi_types.UUID, params *GetReportXlsxByIdApiV1ExtendedReportsReportTaskIdReportXlsxGetParams, reqEditors ...RequestEditorFn) (*GetReportXlsxByIdApiV1ExtendedReportsReportTaskIdReportXlsxGetResponse, error) {
	rsp, err := c.GetReportXlsxByIdApiV1ExtendedReportsReportTaskIdReportXlsxGet(ctx, reportTaskId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetReportXlsxByIdApiV1ExtendedReportsReportTaskIdReportXlsxGetResponse(rsp)
}

// GetGoodsApiV1GoodsGetWithResponse request returning *GetGoodsApiV1GoodsGetResponse
func (c *ClientWithResponses) GetGoodsApiV1GoodsGetWithResponse(ctx context.Context, params *GetGoodsApiV1GoodsGetParams, reqEditors ...RequestEditorFn) (*GetGoodsApiV1GoodsGetResponse, error) {
	rsp, err := c.GetGoodsApiV1GoodsGet(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetGoodsApiV1GoodsGetResponse(rsp)
}

// ExportGoodsFileApiV1GoodsExportFileTaskIdGetWithResponse request returning *ExportGoodsFileApiV1GoodsExportFileTaskIdGetResponse
func (c *ClientWithResponses) ExportGoodsFileApiV1GoodsExportFileTaskIdGetWithResponse(ctx context.Context, taskId openapi_types.UUID, params *ExportGoodsFileApiV1GoodsExportFileTaskIdGetParams, reqEditors ...RequestEditorFn) (*ExportGoodsFileApiV1GoodsExportFileTaskIdGetResponse, error) {
	rsp, err := c.ExportGoodsFileApiV1GoodsExportFileTaskIdGet(ctx, taskId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseExportGoodsFileApiV1GoodsExportFileTaskIdGetResponse(rsp)
}

// ExportGoodsTaskStatusApiV1GoodsExportTaskStatusTaskIdGetWithResponse request returning *ExportGoodsTaskStatusApiV1GoodsExportTaskStatusTaskIdGetResponse
func (c *ClientWithResponses) ExportGoodsTaskStatusApiV1GoodsExportTaskStatusTaskIdGetWithResponse(ctx context.Context, taskId openapi_types.UUID, params *ExportGoodsTaskStatusApiV1GoodsExportTaskStatusTaskIdGetParams, reqEditors ...RequestEditorFn) (*ExportGoodsTaskStatusApiV1GoodsExportTaskStatusTaskIdGetResponse, error) {
	rsp, err := c.ExportGoodsTaskStatusApiV1GoodsExportTaskStatusTaskIdGet(ctx, taskId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseExportGoodsTaskStatusApiV1GoodsExportTaskStatusTaskIdGetResponse(rsp)
}

// ExportGoodsApiV1GoodsExportExportExtensionGetWithResponse request returning *ExportGoodsApiV1GoodsExportExportExtensionGetResponse
func (c *ClientWithResponses) ExportGoodsApiV1GoodsExportExportExtensionGetWithResponse(ctx context.Context, exportExtension ExportExtensionType, params *ExportGoodsApiV1GoodsExportExportExtensionGetParams, reqEditors ...RequestEditorFn) (*ExportGoodsApiV1GoodsExportExportExtensionGetResponse, error) {
	rsp, err := c.ExportGoodsApiV1GoodsExportExportExtensionGet(ctx, exportExtension, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseExportGoodsApiV1GoodsExportExportExtensionGetResponse(rsp)
}

// ImportGoodsApplyChangesApiV1GoodsImportApplyChangesTaskIdPostWithResponse request returning *ImportGoodsApplyChangesApiV1GoodsImportApplyChangesTaskIdPostResponse
func (c *ClientWithResponses) ImportGoodsApplyChangesApiV1GoodsImportApplyChangesTaskIdPostWithResponse(ctx context.Context, taskId openapi_types.UUID, params *ImportGoodsApplyChangesApiV1GoodsImportApplyChangesTaskIdPostParams, reqEditors ...RequestEditorFn) (*ImportGoodsApplyChangesApiV1GoodsImportApplyChangesTaskIdPostResponse, error) {
	rsp, err := c.ImportGoodsApplyChangesApiV1GoodsImportApplyChangesTaskIdPost(ctx, taskId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseImportGoodsApplyChangesApiV1GoodsImportApplyChangesTaskIdPostResponse(rsp)
}

// ImportGoodsTaskStatusApiV1GoodsImportTaskStatusTaskIdGetWithResponse request returning *ImportGoodsTaskStatusApiV1GoodsImportTaskStatusTaskIdGetResponse
func (c *ClientWithResponses) ImportGoodsTaskStatusApiV1GoodsImportTaskStatusTaskIdGetWithResponse(ctx context.Context, taskId openapi_types.UUID, params *ImportGoodsTaskStatusApiV1GoodsImportTaskStatusTaskIdGetParams, reqEditors ...RequestEditorFn) (*ImportGoodsTaskStatusApiV1GoodsImportTaskStatusTaskIdGetResponse, error) {
	rsp, err := c.ImportGoodsTaskStatusApiV1GoodsImportTaskStatusTaskIdGet(ctx, taskId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseImportGoodsTaskStatusApiV1GoodsImportTaskStatusTaskIdGetResponse(rsp)
}

// ImportGoodsFromFileApiV1GoodsImportUploadPostWithBodyWithResponse request with arbitrary body returning *ImportGoodsFromFileApiV1GoodsImportUploadPostResponse
func (c *ClientWithResponses) ImportGoodsFromFileApiV1GoodsImportUploadPostWithBodyWithResponse(ctx context.Context, params *ImportGoodsFromFileApiV1GoodsImportUploadPostParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ImportGoodsFromFileApiV1GoodsImportUploadPostResponse, error) {
	rsp, err := c.ImportGoodsFromFileApiV1GoodsImportUploadPostWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseImportGoodsFromFileApiV1GoodsImportUploadPostResponse(rsp)
}

// GetGoodApiV1GoodsGoodIdGetWithResponse request returning *GetGoodApiV1GoodsGoodIdGetResponse
func (c *ClientWithResponses) GetGoodApiV1GoodsGoodIdGetWithResponse(ctx context.Context, goodId openapi_types.UUID, params *GetGoodApiV1GoodsGoodIdGetParams, reqEditors ...RequestEditorFn) (*GetGoodApiV1GoodsGoodIdGetResponse, error) {
	rsp, err := c.GetGoodApiV1GoodsGoodIdGet(ctx, goodId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetGoodApiV1GoodsGoodIdGetResponse(rsp)
}

// GetOrdersApiV1OrdersGetWithResponse request returning *GetOrdersApiV1OrdersGetResponse
func (c *ClientWithResponses) GetOrdersApiV1OrdersGetWithResponse(ctx context.Context, params *GetOrdersApiV1OrdersGetParams, reqEditors ...RequestEditorFn) (*GetOrdersApiV1OrdersGetResponse, error) {
	rsp, err := c.GetOrdersApiV1OrdersGet(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetOrdersApiV1OrdersGetResponse(rsp)
}

// AddOrdersApiV1OrdersPostWithBodyWithResponse request with arbitrary body returning *AddOrdersApiV1OrdersPostResponse
func (c *ClientWithResponses) AddOrdersApiV1OrdersPostWithBodyWithResponse(ctx context.Context, params *AddOrdersApiV1OrdersPostParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AddOrdersApiV1OrdersPostResponse, error) {
	rsp, err := c.AddOrdersApiV1OrdersPostWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAddOrdersApiV1OrdersPostResponse(rsp)
}

func (c *ClientWithResponses) AddOrdersApiV1OrdersPostWithResponse(ctx context.Context, params *AddOrdersApiV1OrdersPostParams, body AddOrdersApiV1OrdersPostJSONRequestBody, reqEditors ...RequestEditorFn) (*AddOrdersApiV1OrdersPostResponse, error) {
	rsp, err := c.AddOrdersApiV1OrdersPost(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAddOrdersApiV1OrdersPostResponse(rsp)
}

// CloseNotFiscalizeOrderApiV1OrdersClosePatchWithResponse request returning *CloseNotFiscalizeOrderApiV1OrdersClosePatchResponse
func (c *ClientWithResponses) CloseNotFiscalizeOrderApiV1OrdersClosePatchWithResponse(ctx context.Context, params *CloseNotFiscalizeOrderApiV1OrdersClosePatchParams, reqEditors ...RequestEditorFn) (*CloseNotFiscalizeOrderApiV1OrdersClosePatchResponse, error) {
	rsp, err := c.CloseNotFiscalizeOrderApiV1OrdersClosePatch(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCloseNotFiscalizeOrderApiV1OrdersClosePatchResponse(rsp)
}

// UpdateCustomOrderStatusApiV1OrdersCustomStatusOrderIdPatchWithResponse request returning *UpdateCustomOrderStatusApiV1OrdersCustomStatusOrderIdPatchResponse
func (c *ClientWithResponses) UpdateCustomOrderStatusApiV1OrdersCustomStatusOrderIdPatchWithResponse(ctx context.Context, orderId openapi_types.UUID, params *UpdateCustomOrderStatusApiV1OrdersCustomStatusOrderIdPatchParams, reqEditors ...RequestEditorFn) (*UpdateCustomOrderStatusApiV1OrdersCustomStatusOrderIdPatchResponse, error) {
	rsp, err := c.UpdateCustomOrderStatusApiV1OrdersCustomStatusOrderIdPatch(ctx, orderId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateCustomOrderStatusApiV1OrdersCustomStatusOrderIdPatchResponse(rsp)
}

// DeleteIntegrationApiV1OrdersIntegrationDeleteWithResponse request returning *DeleteIntegrationApiV1OrdersIntegrationDeleteResponse
func (c *ClientWithResponses) DeleteIntegrationApiV1OrdersIntegrationDeleteWithResponse(ctx context.Context, params *DeleteIntegrationApiV1OrdersIntegrationDeleteParams, reqEditors ...RequestEditorFn) (*DeleteIntegrationApiV1OrdersIntegrationDeleteResponse, error) {
	rsp, err := c.DeleteIntegrationApiV1OrdersIntegrationDelete(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteIntegrationApiV1OrdersIntegrationDeleteResponse(rsp)
}

// GetIntegrationApiV1OrdersIntegrationGetWithResponse request returning *GetIntegrationApiV1OrdersIntegrationGetResponse
func (c *ClientWithResponses) GetIntegrationApiV1OrdersIntegrationGetWithResponse(ctx context.Context, params *GetIntegrationApiV1OrdersIntegrationGetParams, reqEditors ...RequestEditorFn) (*GetIntegrationApiV1OrdersIntegrationGetResponse, error) {
	rsp, err := c.GetIntegrationApiV1OrdersIntegrationGet(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetIntegrationApiV1OrdersIntegrationGetResponse(rsp)
}

// SetIntegrationApiV1OrdersIntegrationPostWithBodyWithResponse request with arbitrary body returning *SetIntegrationApiV1OrdersIntegrationPostResponse
func (c *ClientWithResponses) SetIntegrationApiV1OrdersIntegrationPostWithBodyWithResponse(ctx context.Context, params *SetIntegrationApiV1OrdersIntegrationPostParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SetIntegrationApiV1OrdersIntegrationPostResponse, error) {
	rsp, err := c.SetIntegrationApiV1OrdersIntegrationPostWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSetIntegrationApiV1OrdersIntegrationPostResponse(rsp)
}

func (c *ClientWithResponses) SetIntegrationApiV1OrdersIntegrationPostWithResponse(ctx context.Context, params *SetIntegrationApiV1OrdersIntegrationPostParams, body SetIntegrationApiV1OrdersIntegrationPostJSONRequestBody, reqEditors ...RequestEditorFn) (*SetIntegrationApiV1OrdersIntegrationPostResponse, error) {
	rsp, err := c.SetIntegrationApiV1OrdersIntegrationPost(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSetIntegrationApiV1OrdersIntegrationPostResponse(rsp)
}

// EditOrderApiV1OrdersIntegrationEditOrderPostWithBodyWithResponse request with arbitrary body returning *EditOrderApiV1OrdersIntegrationEditOrderPostResponse
func (c *ClientWithResponses) EditOrderApiV1OrdersIntegrationEditOrderPostWithBodyWithResponse(ctx context.Context, params *EditOrderApiV1OrdersIntegrationEditOrderPostParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*EditOrderApiV1OrdersIntegrationEditOrderPostResponse, error) {
	rsp, err := c.EditOrderApiV1OrdersIntegrationEditOrderPostWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseEditOrderApiV1OrdersIntegrationEditOrderPostResponse(rsp)
}

func (c *ClientWithResponses) EditOrderApiV1OrdersIntegrationEditOrderPostWithResponse(ctx context.Context, params *EditOrderApiV1OrdersIntegrationEditOrderPostParams, body EditOrderApiV1OrdersIntegrationEditOrderPostJSONRequestBody, reqEditors ...RequestEditorFn) (*EditOrderApiV1OrdersIntegrationEditOrderPostResponse, error) {
	rsp, err := c.EditOrderApiV1OrdersIntegrationEditOrderPost(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseEditOrderApiV1OrdersIntegrationEditOrderPostResponse(rsp)
}

// RunOrdersSynchronizationApiV1OrdersSyncPostWithResponse request returning *RunOrdersSynchronizationApiV1OrdersSyncPostResponse
func (c *ClientWithResponses) RunOrdersSynchronizationApiV1OrdersSyncPostWithResponse(ctx context.Context, params *RunOrdersSynchronizationApiV1OrdersSyncPostParams, reqEditors ...RequestEditorFn) (*RunOrdersSynchronizationApiV1OrdersSyncPostResponse, error) {
	rsp, err := c.RunOrdersSynchronizationApiV1OrdersSyncPost(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRunOrdersSynchronizationApiV1OrdersSyncPostResponse(rsp)
}

// GetOrderApiV1OrdersOrderIdGetWithResponse request returning *GetOrderApiV1OrdersOrderIdGetResponse
func (c *ClientWithResponses) GetOrderApiV1OrdersOrderIdGetWithResponse(ctx context.Context, orderId openapi_types.UUID, params *GetOrderApiV1OrdersOrderIdGetParams, reqEditors ...RequestEditorFn) (*GetOrderApiV1OrdersOrderIdGetResponse, error) {
	rsp, err := c.GetOrderApiV1OrdersOrderIdGet(ctx, orderId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetOrderApiV1OrdersOrderIdGetResponse(rsp)
}

// CancelOrderApiV1OrdersOrderIdPatchWithResponse request returning *CancelOrderApiV1OrdersOrderIdPatchResponse
func (c *ClientWithResponses) CancelOrderApiV1OrdersOrderIdPatchWithResponse(ctx context.Context, orderId openapi_types.UUID, params *CancelOrderApiV1OrdersOrderIdPatchParams, reqEditors ...RequestEditorFn) (*CancelOrderApiV1OrdersOrderIdPatchResponse, error) {
	rsp, err := c.CancelOrderApiV1OrdersOrderIdPatch(ctx, orderId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCancelOrderApiV1OrdersOrderIdPatchResponse(rsp)
}

// GetCurrentOrganizationLogoApiV1OrganizationLogoPngGetWithResponse request returning *GetCurrentOrganizationLogoApiV1OrganizationLogoPngGetResponse
func (c *ClientWithResponses) GetCurrentOrganizationLogoApiV1OrganizationLogoPngGetWithResponse(ctx context.Context, params *GetCurrentOrganizationLogoApiV1OrganizationLogoPngGetParams, reqEditors ...RequestEditorFn) (*GetCurrentOrganizationLogoApiV1OrganizationLogoPngGetResponse, error) {
	rsp, err := c.GetCurrentOrganizationLogoApiV1OrganizationLogoPngGet(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetCurrentOrganizationLogoApiV1OrganizationLogoPngGetResponse(rsp)
}

// GetCurrentOrganizationReceiptSettingsApiV1OrganizationReceiptConfigGetWithResponse request returning *GetCurrentOrganizationReceiptSettingsApiV1OrganizationReceiptConfigGetResponse
func (c *ClientWithResponses) GetCurrentOrganizationReceiptSettingsApiV1OrganizationReceiptConfigGetWithResponse(ctx context.Context, params *GetCurrentOrganizationReceiptSettingsApiV1OrganizationReceiptConfigGetParams, reqEditors ...RequestEditorFn) (*GetCurrentOrganizationReceiptSettingsApiV1OrganizationReceiptConfigGetResponse, error) {
	rsp, err := c.GetCurrentOrganizationReceiptSettingsApiV1OrganizationReceiptConfigGet(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetCurrentOrganizationReceiptSettingsApiV1OrganizationReceiptConfigGetResponse(rsp)
}

// GetCurrentOrganizationSmsBillingBalanceApiV1OrganizationSmsBillingGetWithResponse request returning *GetCurrentOrganizationSmsBillingBalanceApiV1OrganizationSmsBillingGetResponse
func (c *ClientWithResponses) GetCurrentOrganizationSmsBillingBalanceApiV1OrganizationSmsBillingGetWithResponse(ctx context.Context, params *GetCurrentOrganizationSmsBillingBalanceApiV1OrganizationSmsBillingGetParams, reqEditors ...RequestEditorFn) (*GetCurrentOrganizationSmsBillingBalanceApiV1OrganizationSmsBillingGetResponse, error) {
	rsp, err := c.GetCurrentOrganizationSmsBillingBalanceApiV1OrganizationSmsBillingGet(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetCurrentOrganizationSmsBillingBalanceApiV1OrganizationSmsBillingGetResponse(rsp)
}

// GetCurrentOrganizationTextLogoApiV1OrganizationTextLogoPngGetWithResponse request returning *GetCurrentOrganizationTextLogoApiV1OrganizationTextLogoPngGetResponse
func (c *ClientWithResponses) GetCurrentOrganizationTextLogoApiV1OrganizationTextLogoPngGetWithResponse(ctx context.Context, params *GetCurrentOrganizationTextLogoApiV1OrganizationTextLogoPngGetParams, reqEditors ...RequestEditorFn) (*GetCurrentOrganizationTextLogoApiV1OrganizationTextLogoPngGetResponse, error) {
	rsp, err := c.GetCurrentOrganizationTextLogoApiV1OrganizationTextLogoPngGet(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetCurrentOrganizationTextLogoApiV1OrganizationTextLogoPngGetResponse(rsp)
}

// GetReceiptsApiV1ReceiptsGetWithResponse request returning *GetReceiptsApiV1ReceiptsGetResponse
func (c *ClientWithResponses) GetReceiptsApiV1ReceiptsGetWithResponse(ctx context.Context, params *GetReceiptsApiV1ReceiptsGetParams, reqEditors ...RequestEditorFn) (*GetReceiptsApiV1ReceiptsGetResponse, error) {
	rsp, err := c.GetReceiptsApiV1ReceiptsGet(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetReceiptsApiV1ReceiptsGetResponse(rsp)
}

// AddExternalReceiptApiV1ReceiptsAddExternalPostWithBodyWithResponse request with arbitrary body returning *AddExternalReceiptApiV1ReceiptsAddExternalPostResponse
func (c *ClientWithResponses) AddExternalReceiptApiV1ReceiptsAddExternalPostWithBodyWithResponse(ctx context.Context, params *AddExternalReceiptApiV1ReceiptsAddExternalPostParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AddExternalReceiptApiV1ReceiptsAddExternalPostResponse, error) {
	rsp, err := c.AddExternalReceiptApiV1ReceiptsAddExternalPostWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAddExternalReceiptApiV1ReceiptsAddExternalPostResponse(rsp)
}

func (c *ClientWithResponses) AddExternalReceiptApiV1ReceiptsAddExternalPostWithResponse(ctx context.Context, params *AddExternalReceiptApiV1ReceiptsAddExternalPostParams, body AddExternalReceiptApiV1ReceiptsAddExternalPostJSONRequestBody, reqEditors ...RequestEditorFn) (*AddExternalReceiptApiV1ReceiptsAddExternalPostResponse, error) {
	rsp, err := c.AddExternalReceiptApiV1ReceiptsAddExternalPost(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAddExternalReceiptApiV1ReceiptsAddExternalPostResponse(rsp)
}

// CashWithdrawalApiV1ReceiptsCashWithdrawalPostWithBodyWithResponse request with arbitrary body returning *CashWithdrawalApiV1ReceiptsCashWithdrawalPostResponse
func (c *ClientWithResponses) CashWithdrawalApiV1ReceiptsCashWithdrawalPostWithBodyWithResponse(ctx context.Context, params *CashWithdrawalApiV1ReceiptsCashWithdrawalPostParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CashWithdrawalApiV1ReceiptsCashWithdrawalPostResponse, error) {
	rsp, err := c.CashWithdrawalApiV1ReceiptsCashWithdrawalPostWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCashWithdrawalApiV1ReceiptsCashWithdrawalPostResponse(rsp)
}

func (c *ClientWithResponses) CashWithdrawalApiV1ReceiptsCashWithdrawalPostWithResponse(ctx context.Context, params *CashWithdrawalApiV1ReceiptsCashWithdrawalPostParams, body CashWithdrawalApiV1ReceiptsCashWithdrawalPostJSONRequestBody, reqEditors ...RequestEditorFn) (*CashWithdrawalApiV1ReceiptsCashWithdrawalPostResponse, error) {
	rsp, err := c.CashWithdrawalApiV1ReceiptsCashWithdrawalPost(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCashWithdrawalApiV1ReceiptsCashWithdrawalPostResponse(rsp)
}

// ExchangeApiV1ReceiptsCurrencyExchangePostWithBodyWithResponse request with arbitrary body returning *ExchangeApiV1ReceiptsCurrencyExchangePostResponse
func (c *ClientWithResponses) ExchangeApiV1ReceiptsCurrencyExchangePostWithBodyWithResponse(ctx context.Context, params *ExchangeApiV1ReceiptsCurrencyExchangePostParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ExchangeApiV1ReceiptsCurrencyExchangePostResponse, error) {
	rsp, err := c.ExchangeApiV1ReceiptsCurrencyExchangePostWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseExchangeApiV1ReceiptsCurrencyExchangePostResponse(rsp)
}

func (c *ClientWithResponses) ExchangeApiV1ReceiptsCurrencyExchangePostWithResponse(ctx context.Context, params *ExchangeApiV1ReceiptsCurrencyExchangePostParams, body ExchangeApiV1ReceiptsCurrencyExchangePostJSONRequestBody, reqEditors ...RequestEditorFn) (*ExchangeApiV1ReceiptsCurrencyExchangePostResponse, error) {
	rsp, err := c.ExchangeApiV1ReceiptsCurrencyExchangePost(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseExchangeApiV1ReceiptsCurrencyExchangePostResponse(rsp)
}

// GetReceiptsSearchApiV1ReceiptsSearchGetWithResponse request returning *GetReceiptsSearchApiV1ReceiptsSearchGetResponse
func (c *ClientWithResponses) GetReceiptsSearchApiV1ReceiptsSearchGetWithResponse(ctx context.Context, params *GetReceiptsSearchApiV1ReceiptsSearchGetParams, reqEditors ...RequestEditorFn) (*GetReceiptsSearchApiV1ReceiptsSearchGetResponse, error) {
	rsp, err := c.GetReceiptsSearchApiV1ReceiptsSearchGet(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetReceiptsSearchApiV1ReceiptsSearchGetResponse(rsp)
}

// CreateReceiptApiV1ReceiptsSellPostWithBodyWithResponse request with arbitrary body returning *CreateReceiptApiV1ReceiptsSellPostResponse
func (c *ClientWithResponses) CreateReceiptApiV1ReceiptsSellPostWithBodyWithResponse(ctx context.Context, params *CreateReceiptApiV1ReceiptsSellPostParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateReceiptApiV1ReceiptsSellPostResponse, error) {
	rsp, err := c.CreateReceiptApiV1ReceiptsSellPostWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateReceiptApiV1ReceiptsSellPostResponse(rsp)
}

func (c *ClientWithResponses) CreateReceiptApiV1ReceiptsSellPostWithResponse(ctx context.Context, params *CreateReceiptApiV1ReceiptsSellPostParams, body CreateReceiptApiV1ReceiptsSellPostJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateReceiptApiV1ReceiptsSellPostResponse, error) {
	rsp, err := c.CreateReceiptApiV1ReceiptsSellPost(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateReceiptApiV1ReceiptsSellPostResponse(rsp)
}

// CreateOfflineReceiptApiV1ReceiptsSellOfflinePostWithBodyWithResponse request with arbitrary body returning *CreateOfflineReceiptApiV1ReceiptsSellOfflinePostResponse
func (c *ClientWithResponses) CreateOfflineReceiptApiV1ReceiptsSellOfflinePostWithBodyWithResponse(ctx context.Context, params *CreateOfflineReceiptApiV1ReceiptsSellOfflinePostParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateOfflineReceiptApiV1ReceiptsSellOfflinePostResponse, error) {
	rsp, err := c.CreateOfflineReceiptApiV1ReceiptsSellOfflinePostWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateOfflineReceiptApiV1ReceiptsSellOfflinePostResponse(rsp)
}

func (c *ClientWithResponses) CreateOfflineReceiptApiV1ReceiptsSellOfflinePostWithResponse(ctx context.Context, params *CreateOfflineReceiptApiV1ReceiptsSellOfflinePostParams, body CreateOfflineReceiptApiV1ReceiptsSellOfflinePostJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateOfflineReceiptApiV1ReceiptsSellOfflinePostResponse, error) {
	rsp, err := c.CreateOfflineReceiptApiV1ReceiptsSellOfflinePost(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateOfflineReceiptApiV1ReceiptsSellOfflinePostResponse(rsp)
}

// CreateServiceReceiptApiV1ReceiptsServicePostWithBodyWithResponse request with arbitrary body returning *CreateServiceReceiptApiV1ReceiptsServicePostResponse
func (c *ClientWithResponses) CreateServiceReceiptApiV1ReceiptsServicePostWithBodyWithResponse(ctx context.Context, params *CreateServiceReceiptApiV1ReceiptsServicePostParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateServiceReceiptApiV1ReceiptsServicePostResponse, error) {
	rsp, err := c.CreateServiceReceiptApiV1ReceiptsServicePostWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateServiceReceiptApiV1ReceiptsServicePostResponse(rsp)
}

func (c *ClientWithResponses) CreateServiceReceiptApiV1ReceiptsServicePostWithResponse(ctx context.Context, params *CreateServiceReceiptApiV1ReceiptsServicePostParams, body CreateServiceReceiptApiV1ReceiptsServicePostJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateServiceReceiptApiV1ReceiptsServicePostResponse, error) {
	rsp, err := c.CreateServiceReceiptApiV1ReceiptsServicePost(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateServiceReceiptApiV1ReceiptsServicePostResponse(rsp)
}

// CreateServiceCurrencyReceiptApiV1ReceiptsServiceCurrencyPostWithBodyWithResponse request with arbitrary body returning *CreateServiceCurrencyReceiptApiV1ReceiptsServiceCurrencyPostResponse
func (c *ClientWithResponses) CreateServiceCurrencyReceiptApiV1ReceiptsServiceCurrencyPostWithBodyWithResponse(ctx context.Context, params *CreateServiceCurrencyReceiptApiV1ReceiptsServiceCurrencyPostParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateServiceCurrencyReceiptApiV1ReceiptsServiceCurrencyPostResponse, error) {
	rsp, err := c.CreateServiceCurrencyReceiptApiV1ReceiptsServiceCurrencyPostWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateServiceCurrencyReceiptApiV1ReceiptsServiceCurrencyPostResponse(rsp)
}

func (c *ClientWithResponses) CreateServiceCurrencyReceiptApiV1ReceiptsServiceCurrencyPostWithResponse(ctx context.Context, params *CreateServiceCurrencyReceiptApiV1ReceiptsServiceCurrencyPostParams, body CreateServiceCurrencyReceiptApiV1ReceiptsServiceCurrencyPostJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateServiceCurrencyReceiptApiV1ReceiptsServiceCurrencyPostResponse, error) {
	rsp, err := c.CreateServiceCurrencyReceiptApiV1ReceiptsServiceCurrencyPost(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateServiceCurrencyReceiptApiV1ReceiptsServiceCurrencyPostResponse(rsp)
}

// GetReceiptApiV1ReceiptsReceiptIdGetWithResponse request returning *GetReceiptApiV1ReceiptsReceiptIdGetResponse
func (c *ClientWithResponses) GetReceiptApiV1ReceiptsReceiptIdGetWithResponse(ctx context.Context, receiptId struct {
	union json.RawMessage
}, params *GetReceiptApiV1ReceiptsReceiptIdGetParams, reqEditors ...RequestEditorFn) (*GetReceiptApiV1ReceiptsReceiptIdGetResponse, error) {
	rsp, err := c.GetReceiptApiV1ReceiptsReceiptIdGet(ctx, receiptId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetReceiptApiV1ReceiptsReceiptIdGetResponse(rsp)
}

// SendReceiptToEmailApiV1ReceiptsReceiptIdEmailPostWithBodyWithResponse request with arbitrary body returning *SendReceiptToEmailApiV1ReceiptsReceiptIdEmailPostResponse
func (c *ClientWithResponses) SendReceiptToEmailApiV1ReceiptsReceiptIdEmailPostWithBodyWithResponse(ctx context.Context, receiptId struct {
	union json.RawMessage
}, params *SendReceiptToEmailApiV1ReceiptsReceiptIdEmailPostParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SendReceiptToEmailApiV1ReceiptsReceiptIdEmailPostResponse, error) {
	rsp, err := c.SendReceiptToEmailApiV1ReceiptsReceiptIdEmailPostWithBody(ctx, receiptId, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSendReceiptToEmailApiV1ReceiptsReceiptIdEmailPostResponse(rsp)
}

func (c *ClientWithResponses) SendReceiptToEmailApiV1ReceiptsReceiptIdEmailPostWithResponse(ctx context.Context, receiptId struct {
	union json.RawMessage
}, params *SendReceiptToEmailApiV1ReceiptsReceiptIdEmailPostParams, body SendReceiptToEmailApiV1ReceiptsReceiptIdEmailPostJSONRequestBody, reqEditors ...RequestEditorFn) (*SendReceiptToEmailApiV1ReceiptsReceiptIdEmailPostResponse, error) {
	rsp, err := c.SendReceiptToEmailApiV1ReceiptsReceiptIdEmailPost(ctx, receiptId, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSendReceiptToEmailApiV1ReceiptsReceiptIdEmailPostResponse(rsp)
}

// GetReceiptHtmlApiV1ReceiptsReceiptIdHtmlGetWithResponse request returning *GetReceiptHtmlApiV1ReceiptsReceiptIdHtmlGetResponse
func (c *ClientWithResponses) GetReceiptHtmlApiV1ReceiptsReceiptIdHtmlGetWithResponse(ctx context.Context, receiptId struct {
	union json.RawMessage
}, params *GetReceiptHtmlApiV1ReceiptsReceiptIdHtmlGetParams, reqEditors ...RequestEditorFn) (*GetReceiptHtmlApiV1ReceiptsReceiptIdHtmlGetResponse, error) {
	rsp, err := c.GetReceiptHtmlApiV1ReceiptsReceiptIdHtmlGet(ctx, receiptId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetReceiptHtmlApiV1ReceiptsReceiptIdHtmlGetResponse(rsp)
}

// GetReceiptPdfApiV1ReceiptsReceiptIdPdfGetWithResponse request returning *GetReceiptPdfApiV1ReceiptsReceiptIdPdfGetResponse
func (c *ClientWithResponses) GetReceiptPdfApiV1ReceiptsReceiptIdPdfGetWithResponse(ctx context.Context, receiptId struct {
	union json.RawMessage
}, params *GetReceiptPdfApiV1ReceiptsReceiptIdPdfGetParams, reqEditors ...RequestEditorFn) (*GetReceiptPdfApiV1ReceiptsReceiptIdPdfGetResponse, error) {
	rsp, err := c.GetReceiptPdfApiV1ReceiptsReceiptIdPdfGet(ctx, receiptId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetReceiptPdfApiV1ReceiptsReceiptIdPdfGetResponse(rsp)
}

// GetReceiptPngApiV1ReceiptsReceiptIdPngGetWithResponse request returning *GetReceiptPngApiV1ReceiptsReceiptIdPngGetResponse
func (c *ClientWithResponses) GetReceiptPngApiV1ReceiptsReceiptIdPngGetWithResponse(ctx context.Context, receiptId struct {
	union json.RawMessage
}, params *GetReceiptPngApiV1ReceiptsReceiptIdPngGetParams, reqEditors ...RequestEditorFn) (*GetReceiptPngApiV1ReceiptsReceiptIdPngGetResponse, error) {
	rsp, err := c.GetReceiptPngApiV1ReceiptsReceiptIdPngGet(ctx, receiptId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetReceiptPngApiV1ReceiptsReceiptIdPngGetResponse(rsp)
}

// GetReceiptQrCodeImageApiV1ReceiptsReceiptIdQrcodeGetWithResponse request returning *GetReceiptQrCodeImageApiV1ReceiptsReceiptIdQrcodeGetResponse
func (c *ClientWithResponses) GetReceiptQrCodeImageApiV1ReceiptsReceiptIdQrcodeGetWithResponse(ctx context.Context, receiptId struct {
	union json.RawMessage
}, params *GetReceiptQrCodeImageApiV1ReceiptsReceiptIdQrcodeGetParams, reqEditors ...RequestEditorFn) (*GetReceiptQrCodeImageApiV1ReceiptsReceiptIdQrcodeGetResponse, error) {
	rsp, err := c.GetReceiptQrCodeImageApiV1ReceiptsReceiptIdQrcodeGet(ctx, receiptId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetReceiptQrCodeImageApiV1ReceiptsReceiptIdQrcodeGetResponse(rsp)
}

// SendReceiptViaSmsApiV1ReceiptsReceiptIdSmsPostWithBodyWithResponse request with arbitrary body returning *SendReceiptViaSmsApiV1ReceiptsReceiptIdSmsPostResponse
func (c *ClientWithResponses) SendReceiptViaSmsApiV1ReceiptsReceiptIdSmsPostWithBodyWithResponse(ctx context.Context, receiptId struct {
	union json.RawMessage
}, params *SendReceiptViaSmsApiV1ReceiptsReceiptIdSmsPostParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SendReceiptViaSmsApiV1ReceiptsReceiptIdSmsPostResponse, error) {
	rsp, err := c.SendReceiptViaSmsApiV1ReceiptsReceiptIdSmsPostWithBody(ctx, receiptId, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSendReceiptViaSmsApiV1ReceiptsReceiptIdSmsPostResponse(rsp)
}

func (c *ClientWithResponses) SendReceiptViaSmsApiV1ReceiptsReceiptIdSmsPostWithResponse(ctx context.Context, receiptId struct {
	union json.RawMessage
}, params *SendReceiptViaSmsApiV1ReceiptsReceiptIdSmsPostParams, body SendReceiptViaSmsApiV1ReceiptsReceiptIdSmsPostJSONRequestBody, reqEditors ...RequestEditorFn) (*SendReceiptViaSmsApiV1ReceiptsReceiptIdSmsPostResponse, error) {
	rsp, err := c.SendReceiptViaSmsApiV1ReceiptsReceiptIdSmsPost(ctx, receiptId, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSendReceiptViaSmsApiV1ReceiptsReceiptIdSmsPostResponse(rsp)
}

// GetReceiptTextApiV1ReceiptsReceiptIdTextGetWithResponse request returning *GetReceiptTextApiV1ReceiptsReceiptIdTextGetResponse
func (c *ClientWithResponses) GetReceiptTextApiV1ReceiptsReceiptIdTextGetWithResponse(ctx context.Context, receiptId struct {
	union json.RawMessage
}, params *GetReceiptTextApiV1ReceiptsReceiptIdTextGetParams, reqEditors ...RequestEditorFn) (*GetReceiptTextApiV1ReceiptsReceiptIdTextGetResponse, error) {
	rsp, err := c.GetReceiptTextApiV1ReceiptsReceiptIdTextGet(ctx, receiptId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetReceiptTextApiV1ReceiptsReceiptIdTextGetResponse(rsp)
}

// GetReceiptXmlApiV1ReceiptsReceiptIdXmlGetWithResponse request returning *GetReceiptXmlApiV1ReceiptsReceiptIdXmlGetResponse
func (c *ClientWithResponses) GetReceiptXmlApiV1ReceiptsReceiptIdXmlGetWithResponse(ctx context.Context, receiptId struct {
	union json.RawMessage
}, params *GetReceiptXmlApiV1ReceiptsReceiptIdXmlGetParams, reqEditors ...RequestEditorFn) (*GetReceiptXmlApiV1ReceiptsReceiptIdXmlGetResponse, error) {
	rsp, err := c.GetReceiptXmlApiV1ReceiptsReceiptIdXmlGet(ctx, receiptId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetReceiptXmlApiV1ReceiptsReceiptIdXmlGetResponse(rsp)
}

// GetReportsApiV1ReportsGetWithResponse request returning *GetReportsApiV1ReportsGetResponse
func (c *ClientWithResponses) GetReportsApiV1ReportsGetWithResponse(ctx context.Context, params *GetReportsApiV1ReportsGetParams, reqEditors ...RequestEditorFn) (*GetReportsApiV1ReportsGetResponse, error) {
	rsp, err := c.GetReportsApiV1ReportsGet(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetReportsApiV1ReportsGetResponse(rsp)
}

// CreateXReportApiV1ReportsPostWithResponse request returning *CreateXReportApiV1ReportsPostResponse
func (c *ClientWithResponses) CreateXReportApiV1ReportsPostWithResponse(ctx context.Context, params *CreateXReportApiV1ReportsPostParams, reqEditors ...RequestEditorFn) (*CreateXReportApiV1ReportsPostResponse, error) {
	rsp, err := c.CreateXReportApiV1ReportsPost(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateXReportApiV1ReportsPostResponse(rsp)
}

// AddExternalReportApiV1ReportsAddExternalPostWithBodyWithResponse request with arbitrary body returning *AddExternalReportApiV1ReportsAddExternalPostResponse
func (c *ClientWithResponses) AddExternalReportApiV1ReportsAddExternalPostWithBodyWithResponse(ctx context.Context, params *AddExternalReportApiV1ReportsAddExternalPostParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AddExternalReportApiV1ReportsAddExternalPostResponse, error) {
	rsp, err := c.AddExternalReportApiV1ReportsAddExternalPostWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAddExternalReportApiV1ReportsAddExternalPostResponse(rsp)
}

func (c *ClientWithResponses) AddExternalReportApiV1ReportsAddExternalPostWithResponse(ctx context.Context, params *AddExternalReportApiV1ReportsAddExternalPostParams, body AddExternalReportApiV1ReportsAddExternalPostJSONRequestBody, reqEditors ...RequestEditorFn) (*AddExternalReportApiV1ReportsAddExternalPostResponse, error) {
	rsp, err := c.AddExternalReportApiV1ReportsAddExternalPost(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAddExternalReportApiV1ReportsAddExternalPostResponse(rsp)
}

// GetPeriodicalReportApiV1ReportsPeriodicalGetWithResponse request returning *GetPeriodicalReportApiV1ReportsPeriodicalGetResponse
func (c *ClientWithResponses) GetPeriodicalReportApiV1ReportsPeriodicalGetWithResponse(ctx context.Context, params *GetPeriodicalReportApiV1ReportsPeriodicalGetParams, reqEditors ...RequestEditorFn) (*GetPeriodicalReportApiV1ReportsPeriodicalGetResponse, error) {
	rsp, err := c.GetPeriodicalReportApiV1ReportsPeriodicalGet(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetPeriodicalReportApiV1ReportsPeriodicalGetResponse(rsp)
}

// GetSearchReportsApiV1ReportsSearchGetWithResponse request returning *GetSearchReportsApiV1ReportsSearchGetResponse
func (c *ClientWithResponses) GetSearchReportsApiV1ReportsSearchGetWithResponse(ctx context.Context, params *GetSearchReportsApiV1ReportsSearchGetParams, reqEditors ...RequestEditorFn) (*GetSearchReportsApiV1ReportsSearchGetResponse, error) {
	rsp, err := c.GetSearchReportsApiV1ReportsSearchGet(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetSearchReportsApiV1ReportsSearchGetResponse(rsp)
}

// GetReportApiV1ReportsReportIdGetWithResponse request returning *GetReportApiV1ReportsReportIdGetResponse
func (c *ClientWithResponses) GetReportApiV1ReportsReportIdGetWithResponse(ctx context.Context, reportId openapi_types.UUID, params *GetReportApiV1ReportsReportIdGetParams, reqEditors ...RequestEditorFn) (*GetReportApiV1ReportsReportIdGetResponse, error) {
	rsp, err := c.GetReportApiV1ReportsReportIdGet(ctx, reportId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetReportApiV1ReportsReportIdGetResponse(rsp)
}

// GetReportTextApiV1ReportsReportIdTextGetWithResponse request returning *GetReportTextApiV1ReportsReportIdTextGetResponse
func (c *ClientWithResponses) GetReportTextApiV1ReportsReportIdTextGetWithResponse(ctx context.Context, reportId openapi_types.UUID, params *GetReportTextApiV1ReportsReportIdTextGetParams, reqEditors ...RequestEditorFn) (*GetReportTextApiV1ReportsReportIdTextGetResponse, error) {
	rsp, err := c.GetReportTextApiV1ReportsReportIdTextGet(ctx, reportId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetReportTextApiV1ReportsReportIdTextGetResponse(rsp)
}

// GetShiftsApiV1ShiftsGetWithResponse request returning *GetShiftsApiV1ShiftsGetResponse
func (c *ClientWithResponses) GetShiftsApiV1ShiftsGetWithResponse(ctx context.Context, params *GetShiftsApiV1ShiftsGetParams, reqEditors ...RequestEditorFn) (*GetShiftsApiV1ShiftsGetResponse, error) {
	rsp, err := c.GetShiftsApiV1ShiftsGet(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetShiftsApiV1ShiftsGetResponse(rsp)
}

// CreateShiftApiV1ShiftsPostWithBodyWithResponse request with arbitrary body returning *CreateShiftApiV1ShiftsPostResponse
func (c *ClientWithResponses) CreateShiftApiV1ShiftsPostWithBodyWithResponse(ctx context.Context, params *CreateShiftApiV1ShiftsPostParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateShiftApiV1ShiftsPostResponse, error) {
	rsp, err := c.CreateShiftApiV1ShiftsPostWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateShiftApiV1ShiftsPostResponse(rsp)
}

func (c *ClientWithResponses) CreateShiftApiV1ShiftsPostWithResponse(ctx context.Context, params *CreateShiftApiV1ShiftsPostParams, body CreateShiftApiV1ShiftsPostJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateShiftApiV1ShiftsPostResponse, error) {
	rsp, err := c.CreateShiftApiV1ShiftsPost(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateShiftApiV1ShiftsPostResponse(rsp)
}

// CloseShiftApiV1ShiftsClosePostWithBodyWithResponse request with arbitrary body returning *CloseShiftApiV1ShiftsClosePostResponse
func (c *ClientWithResponses) CloseShiftApiV1ShiftsClosePostWithBodyWithResponse(ctx context.Context, params *CloseShiftApiV1ShiftsClosePostParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CloseShiftApiV1ShiftsClosePostResponse, error) {
	rsp, err := c.CloseShiftApiV1ShiftsClosePostWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCloseShiftApiV1ShiftsClosePostResponse(rsp)
}

func (c *ClientWithResponses) CloseShiftApiV1ShiftsClosePostWithResponse(ctx context.Context, params *CloseShiftApiV1ShiftsClosePostParams, body CloseShiftApiV1ShiftsClosePostJSONRequestBody, reqEditors ...RequestEditorFn) (*CloseShiftApiV1ShiftsClosePostResponse, error) {
	rsp, err := c.CloseShiftApiV1ShiftsClosePost(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCloseShiftApiV1ShiftsClosePostResponse(rsp)
}

// GetShiftApiV1ShiftsShiftIdGetWithResponse request returning *GetShiftApiV1ShiftsShiftIdGetResponse
func (c *ClientWithResponses) GetShiftApiV1ShiftsShiftIdGetWithResponse(ctx context.Context, shiftId openapi_types.UUID, params *GetShiftApiV1ShiftsShiftIdGetParams, reqEditors ...RequestEditorFn) (*GetShiftApiV1ShiftsShiftIdGetResponse, error) {
	rsp, err := c.GetShiftApiV1ShiftsShiftIdGet(ctx, shiftId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetShiftApiV1ShiftsShiftIdGetResponse(rsp)
}

// CloseShiftBySeniorCashierApiV1ShiftsShiftIdClosePostWithBodyWithResponse request with arbitrary body returning *CloseShiftBySeniorCashierApiV1ShiftsShiftIdClosePostResponse
func (c *ClientWithResponses) CloseShiftBySeniorCashierApiV1ShiftsShiftIdClosePostWithBodyWithResponse(ctx context.Context, shiftId openapi_types.UUID, params *CloseShiftBySeniorCashierApiV1ShiftsShiftIdClosePostParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CloseShiftBySeniorCashierApiV1ShiftsShiftIdClosePostResponse, error) {
	rsp, err := c.CloseShiftBySeniorCashierApiV1ShiftsShiftIdClosePostWithBody(ctx, shiftId, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCloseShiftBySeniorCashierApiV1ShiftsShiftIdClosePostResponse(rsp)
}

func (c *ClientWithResponses) CloseShiftBySeniorCashierApiV1ShiftsShiftIdClosePostWithResponse(ctx context.Context, shiftId openapi_types.UUID, params *CloseShiftBySeniorCashierApiV1ShiftsShiftIdClosePostParams, body CloseShiftBySeniorCashierApiV1ShiftsShiftIdClosePostJSONRequestBody, reqEditors ...RequestEditorFn) (*CloseShiftBySeniorCashierApiV1ShiftsShiftIdClosePostResponse, error) {
	rsp, err := c.CloseShiftBySeniorCashierApiV1ShiftsShiftIdClosePost(ctx, shiftId, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCloseShiftBySeniorCashierApiV1ShiftsShiftIdClosePostResponse(rsp)
}

// GetAllTaxesApiV1TaxGetWithResponse request returning *GetAllTaxesApiV1TaxGetResponse
func (c *ClientWithResponses) GetAllTaxesApiV1TaxGetWithResponse(ctx context.Context, params *GetAllTaxesApiV1TaxGetParams, reqEditors ...RequestEditorFn) (*GetAllTaxesApiV1TaxGetResponse, error) {
	rsp, err := c.GetAllTaxesApiV1TaxGet(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAllTaxesApiV1TaxGetResponse(rsp)
}

// GetTransactionsApiV1TransactionsGetWithResponse request returning *GetTransactionsApiV1TransactionsGetResponse
func (c *ClientWithResponses) GetTransactionsApiV1TransactionsGetWithResponse(ctx context.Context, params *GetTransactionsApiV1TransactionsGetParams, reqEditors ...RequestEditorFn) (*GetTransactionsApiV1TransactionsGetResponse, error) {
	rsp, err := c.GetTransactionsApiV1TransactionsGet(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetTransactionsApiV1TransactionsGetResponse(rsp)
}

// GetTransactionApiV1TransactionsTransactionIdGetWithResponse request returning *GetTransactionApiV1TransactionsTransactionIdGetResponse
func (c *ClientWithResponses) GetTransactionApiV1TransactionsTransactionIdGetWithResponse(ctx context.Context, transactionId openapi_types.UUID, params *GetTransactionApiV1TransactionsTransactionIdGetParams, reqEditors ...RequestEditorFn) (*GetTransactionApiV1TransactionsTransactionIdGetResponse, error) {
	rsp, err := c.GetTransactionApiV1TransactionsTransactionIdGet(ctx, transactionId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetTransactionApiV1TransactionsTransactionIdGetResponse(rsp)
}

// UpdateTransactionApiV1TransactionsTransactionIdPatchWithBodyWithResponse request with arbitrary body returning *UpdateTransactionApiV1TransactionsTransactionIdPatchResponse
func (c *ClientWithResponses) UpdateTransactionApiV1TransactionsTransactionIdPatchWithBodyWithResponse(ctx context.Context, transactionId openapi_types.UUID, params *UpdateTransactionApiV1TransactionsTransactionIdPatchParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateTransactionApiV1TransactionsTransactionIdPatchResponse, error) {
	rsp, err := c.UpdateTransactionApiV1TransactionsTransactionIdPatchWithBody(ctx, transactionId, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateTransactionApiV1TransactionsTransactionIdPatchResponse(rsp)
}

func (c *ClientWithResponses) UpdateTransactionApiV1TransactionsTransactionIdPatchWithResponse(ctx context.Context, transactionId openapi_types.UUID, params *UpdateTransactionApiV1TransactionsTransactionIdPatchParams, body UpdateTransactionApiV1TransactionsTransactionIdPatchJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateTransactionApiV1TransactionsTransactionIdPatchResponse, error) {
	rsp, err := c.UpdateTransactionApiV1TransactionsTransactionIdPatch(ctx, transactionId, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateTransactionApiV1TransactionsTransactionIdPatchResponse(rsp)
}

// DeleteWebhookApiV1WebhookDeleteWithResponse request returning *DeleteWebhookApiV1WebhookDeleteResponse
func (c *ClientWithResponses) DeleteWebhookApiV1WebhookDeleteWithResponse(ctx context.Context, params *DeleteWebhookApiV1WebhookDeleteParams, reqEditors ...RequestEditorFn) (*DeleteWebhookApiV1WebhookDeleteResponse, error) {
	rsp, err := c.DeleteWebhookApiV1WebhookDelete(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteWebhookApiV1WebhookDeleteResponse(rsp)
}

// GetWebhookInfoApiV1WebhookGetWithResponse request returning *GetWebhookInfoApiV1WebhookGetResponse
func (c *ClientWithResponses) GetWebhookInfoApiV1WebhookGetWithResponse(ctx context.Context, params *GetWebhookInfoApiV1WebhookGetParams, reqEditors ...RequestEditorFn) (*GetWebhookInfoApiV1WebhookGetResponse, error) {
	rsp, err := c.GetWebhookInfoApiV1WebhookGet(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetWebhookInfoApiV1WebhookGetResponse(rsp)
}

// SetWebhookApiV1WebhookPostWithBodyWithResponse request with arbitrary body returning *SetWebhookApiV1WebhookPostResponse
func (c *ClientWithResponses) SetWebhookApiV1WebhookPostWithBodyWithResponse(ctx context.Context, params *SetWebhookApiV1WebhookPostParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SetWebhookApiV1WebhookPostResponse, error) {
	rsp, err := c.SetWebhookApiV1WebhookPostWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSetWebhookApiV1WebhookPostResponse(rsp)
}

func (c *ClientWithResponses) SetWebhookApiV1WebhookPostWithResponse(ctx context.Context, params *SetWebhookApiV1WebhookPostParams, body SetWebhookApiV1WebhookPostJSONRequestBody, reqEditors ...RequestEditorFn) (*SetWebhookApiV1WebhookPostResponse, error) {
	rsp, err := c.SetWebhookApiV1WebhookPost(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSetWebhookApiV1WebhookPostResponse(rsp)
}

// ParseGetCashRegistersApiV1CashRegistersGetResponse parses an HTTP response from a GetCashRegistersApiV1CashRegistersGetWithResponse call
func ParseGetCashRegistersApiV1CashRegistersGetResponse(rsp *http.Response) (*GetCashRegistersApiV1CashRegistersGetResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetCashRegistersApiV1CashRegistersGetResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PaginatedResultDetailedCashRegisterModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest HTTPValidationError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	}

	return response, nil
}

// ParseAskOfflineCodesApiV1CashRegistersAskOfflineCodesGetResponse parses an HTTP response from a AskOfflineCodesApiV1CashRegistersAskOfflineCodesGetWithResponse call
func ParseAskOfflineCodesApiV1CashRegistersAskOfflineCodesGetResponse(rsp *http.Response) (*AskOfflineCodesApiV1CashRegistersAskOfflineCodesGetResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AskOfflineCodesApiV1CashRegistersAskOfflineCodesGetResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest HTTPValidationError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	}

	return response, nil
}

// ParseGetOfflineCodesApiV1CashRegistersGetOfflineCodesGetResponse parses an HTTP response from a GetOfflineCodesApiV1CashRegistersGetOfflineCodesGetWithResponse call
func ParseGetOfflineCodesApiV1CashRegistersGetOfflineCodesGetResponse(rsp *http.Response) (*GetOfflineCodesApiV1CashRegistersGetOfflineCodesGetResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetOfflineCodesApiV1CashRegistersGetOfflineCodesGetResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []DetailedOfflineFiscalCodeModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest HTTPValidationError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	}

	return response, nil
}

// ParseGetOfflineCodesCountApiV1CashRegistersGetOfflineCodesCountGetResponse parses an HTTP response from a GetOfflineCodesCountApiV1CashRegistersGetOfflineCodesCountGetWithResponse call
func ParseGetOfflineCodesCountApiV1CashRegistersGetOfflineCodesCountGetResponse(rsp *http.Response) (*GetOfflineCodesCountApiV1CashRegistersGetOfflineCodesCountGetResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetOfflineCodesCountApiV1CashRegistersGetOfflineCodesCountGetResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest OfflineCodesCountSchema
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest HTTPValidationError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	}

	return response, nil
}

// ParseGetOfflineTimeApiV1CashRegistersGetOfflineTimeGetResponse parses an HTTP response from a GetOfflineTimeApiV1CashRegistersGetOfflineTimeGetWithResponse call
func ParseGetOfflineTimeApiV1CashRegistersGetOfflineTimeGetResponse(rsp *http.Response) (*GetOfflineTimeApiV1CashRegistersGetOfflineTimeGetResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetOfflineTimeApiV1CashRegistersGetOfflineTimeGetResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest CashRegisterOfflineTime
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest HTTPValidationError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	}

	return response, nil
}

// ParseGoOfflineActionApiV1CashRegistersGoOfflinePostResponse parses an HTTP response from a GoOfflineActionApiV1CashRegistersGoOfflinePostWithResponse call
func ParseGoOfflineActionApiV1CashRegistersGoOfflinePostResponse(rsp *http.Response) (*GoOfflineActionApiV1CashRegistersGoOfflinePostResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GoOfflineActionApiV1CashRegistersGoOfflinePostResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest HTTPValidationError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	}

	return response, nil
}

// ParseGoOnlineActionApiV1CashRegistersGoOnlinePostResponse parses an HTTP response from a GoOnlineActionApiV1CashRegistersGoOnlinePostWithResponse call
func ParseGoOnlineActionApiV1CashRegistersGoOnlinePostResponse(rsp *http.Response) (*GoOnlineActionApiV1CashRegistersGoOnlinePostResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GoOnlineActionApiV1CashRegistersGoOnlinePostResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest HTTPValidationError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	}

	return response, nil
}

// ParseGetCashRegisterInfoApiV1CashRegistersInfoGetResponse parses an HTTP response from a GetCashRegisterInfoApiV1CashRegistersInfoGetWithResponse call
func ParseGetCashRegisterInfoApiV1CashRegistersInfoGetResponse(rsp *http.Response) (*GetCashRegisterInfoApiV1CashRegistersInfoGetResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetCashRegisterInfoApiV1CashRegistersInfoGetResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest CashRegisterDeviceModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest HTTPValidationError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	}

	return response, nil
}

// ParsePingTaxServiceActionApiV1CashRegistersPingTaxServicePostResponse parses an HTTP response from a PingTaxServiceActionApiV1CashRegistersPingTaxServicePostWithResponse call
func ParsePingTaxServiceActionApiV1CashRegistersPingTaxServicePostResponse(rsp *http.Response) (*PingTaxServiceActionApiV1CashRegistersPingTaxServicePostResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PingTaxServiceActionApiV1CashRegistersPingTaxServicePostResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest HTTPValidationError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	}

	return response, nil
}

// ParseGetCashRegisterApiV1CashRegistersCashRegisterIdGetResponse parses an HTTP response from a GetCashRegisterApiV1CashRegistersCashRegisterIdGetWithResponse call
func ParseGetCashRegisterApiV1CashRegistersCashRegisterIdGetResponse(rsp *http.Response) (*GetCashRegisterApiV1CashRegistersCashRegisterIdGetResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetCashRegisterApiV1CashRegistersCashRegisterIdGetResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest DetailedCashRegisterModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest HTTPValidationError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	}

	return response, nil
}

// ParseCheckSignatureApiV1CashierCheckSignatureGetResponse parses an HTTP response from a CheckSignatureApiV1CashierCheckSignatureGetWithResponse call
func ParseCheckSignatureApiV1CashierCheckSignatureGetResponse(rsp *http.Response) (*CheckSignatureApiV1CashierCheckSignatureGetResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CheckSignatureApiV1CashierCheckSignatureGetResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest CashierSignatureStatus
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest HTTPValidationError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	}

	return response, nil
}

// ParseGetCashierProfileApiV1CashierMeGetResponse parses an HTTP response from a GetCashierProfileApiV1CashierMeGetWithResponse call
func ParseGetCashierProfileApiV1CashierMeGetResponse(rsp *http.Response) (*GetCashierProfileApiV1CashierMeGetResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetCashierProfileApiV1CashierMeGetResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest DetailedCashierModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest HTTPValidationError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	}

	return response, nil
}

// ParseGetCashierShiftApiV1CashierShiftGetResponse parses an HTTP response from a GetCashierShiftApiV1CashierShiftGetWithResponse call
func ParseGetCashierShiftApiV1CashierShiftGetResponse(rsp *http.Response) (*GetCashierShiftApiV1CashierShiftGetResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetCashierShiftApiV1CashierShiftGetResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ShiftWithCashRegisterModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest HTTPValidationError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	}

	return response, nil
}

// ParseSignInCashierApiV1CashierSigninPostResponse parses an HTTP response from a SignInCashierApiV1CashierSigninPostWithResponse call
func ParseSignInCashierApiV1CashierSigninPostResponse(rsp *http.Response) (*SignInCashierApiV1CashierSigninPostResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SignInCashierApiV1CashierSigninPostResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest CashierAccessTokenResponseModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest HTTPError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest HTTPValidationError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	}

	return response, nil
}

// ParseSignInCashierViaPinCodeApiV1CashierSigninPinCodePostResponse parses an HTTP response from a SignInCashierViaPinCodeApiV1CashierSigninPinCodePostWithResponse call
func ParseSignInCashierViaPinCodeApiV1CashierSigninPinCodePostResponse(rsp *http.Response) (*SignInCashierViaPinCodeApiV1CashierSigninPinCodePostResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SignInCashierViaPinCodeApiV1CashierSigninPinCodePostResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest CashierAccessTokenResponseModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest HTTPError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest HTTPValidationError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	}

	return response, nil
}

// ParseSignOutCashierApiV1CashierSignoutPostResponse parses an HTTP response from a SignOutCashierApiV1CashierSignoutPostWithResponse call
func ParseSignOutCashierApiV1CashierSignoutPostResponse(rsp *http.Response) (*SignOutCashierApiV1CashierSignoutPostResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SignOutCashierApiV1CashierSignoutPostResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 205:
		var dest interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON205 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest HTTPValidationError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	}

	return response, nil
}

// ParseGetCurrencyRatesApiV1CurrencyRateGetResponse parses an HTTP response from a GetCurrencyRatesApiV1CurrencyRateGetWithResponse call
func ParseGetCurrencyRatesApiV1CurrencyRateGetResponse(rsp *http.Response) (*GetCurrencyRatesApiV1CurrencyRateGetResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetCurrencyRatesApiV1CurrencyRateGetResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []CurrencyRateModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest HTTPValidationError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	}

	return response, nil
}

// ParseSetupCurrencyRatesApiV1CurrencyRateSetupPostResponse parses an HTTP response from a SetupCurrencyRatesApiV1CurrencyRateSetupPostWithResponse call
func ParseSetupCurrencyRatesApiV1CurrencyRateSetupPostResponse(rsp *http.Response) (*SetupCurrencyRatesApiV1CurrencyRateSetupPostResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SetupCurrencyRatesApiV1CurrencyRateSetupPostResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []CurrencyRateModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest HTTPValidationError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	}

	return response, nil
}

// ParseGetCurrencyRateApiV1CurrencyRateCurrencyCodeGetResponse parses an HTTP response from a GetCurrencyRateApiV1CurrencyRateCurrencyCodeGetWithResponse call
func ParseGetCurrencyRateApiV1CurrencyRateCurrencyCodeGetResponse(rsp *http.Response) (*GetCurrencyRateApiV1CurrencyRateCurrencyCodeGetResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetCurrencyRateApiV1CurrencyRateCurrencyCodeGetResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest CurrencyRateModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest HTTPValidationError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	}

	return response, nil
}

// ParseGoodsReportApiV1ExtendedReportsGoodsPostResponse parses an HTTP response from a GoodsReportApiV1ExtendedReportsGoodsPostWithResponse call
func ParseGoodsReportApiV1ExtendedReportsGoodsPostResponse(rsp *http.Response) (*GoodsReportApiV1ExtendedReportsGoodsPostResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GoodsReportApiV1ExtendedReportsGoodsPostResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PublicReportTaskSchema
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest HTTPValidationError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	}

	return response, nil
}

// ParseGetReportTaskByIdApiV1ExtendedReportsReportTaskIdGetResponse parses an HTTP response from a GetReportTaskByIdApiV1ExtendedReportsReportTaskIdGetWithResponse call
func ParseGetReportTaskByIdApiV1ExtendedReportsReportTaskIdGetResponse(rsp *http.Response) (*GetReportTaskByIdApiV1ExtendedReportsReportTaskIdGetResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetReportTaskByIdApiV1ExtendedReportsReportTaskIdGetResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PublicReportTaskSchema
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest HTTPValidationError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	}

	return response, nil
}

// ParseGetReportXlsxByIdApiV1ExtendedReportsReportTaskIdReportXlsxGetResponse parses an HTTP response from a GetReportXlsxByIdApiV1ExtendedReportsReportTaskIdReportXlsxGetWithResponse call
func ParseGetReportXlsxByIdApiV1ExtendedReportsReportTaskIdReportXlsxGetResponse(rsp *http.Response) (*GetReportXlsxByIdApiV1ExtendedReportsReportTaskIdReportXlsxGetResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetReportXlsxByIdApiV1ExtendedReportsReportTaskIdReportXlsxGetResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PublicReportTaskSchema
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest HTTPValidationError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	}

	return response, nil
}

// ParseGetGoodsApiV1GoodsGetResponse parses an HTTP response from a GetGoodsApiV1GoodsGetWithResponse call
func ParseGetGoodsApiV1GoodsGetResponse(rsp *http.Response) (*GetGoodsApiV1GoodsGetResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetGoodsApiV1GoodsGetResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PaginatedResultGoodModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest HTTPValidationError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	}

	return response, nil
}

// ParseExportGoodsFileApiV1GoodsExportFileTaskIdGetResponse parses an HTTP response from a ExportGoodsFileApiV1GoodsExportFileTaskIdGetWithResponse call
func ParseExportGoodsFileApiV1GoodsExportFileTaskIdGetResponse(rsp *http.Response) (*ExportGoodsFileApiV1GoodsExportFileTaskIdGetResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ExportGoodsFileApiV1GoodsExportFileTaskIdGetResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest HTTPValidationError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	}

	return response, nil
}

// ParseExportGoodsTaskStatusApiV1GoodsExportTaskStatusTaskIdGetResponse parses an HTTP response from a ExportGoodsTaskStatusApiV1GoodsExportTaskStatusTaskIdGetWithResponse call
func ParseExportGoodsTaskStatusApiV1GoodsExportTaskStatusTaskIdGetResponse(rsp *http.Response) (*ExportGoodsTaskStatusApiV1GoodsExportTaskStatusTaskIdGetResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ExportGoodsTaskStatusApiV1GoodsExportTaskStatusTaskIdGetResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest CheckStatusResponseSchema
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest HTTPValidationError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	}

	return response, nil
}

// ParseExportGoodsApiV1GoodsExportExportExtensionGetResponse parses an HTTP response from a ExportGoodsApiV1GoodsExportExportExtensionGetWithResponse call
func ParseExportGoodsApiV1GoodsExportExportExtensionGetResponse(rsp *http.Response) (*ExportGoodsApiV1GoodsExportExportExtensionGetResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ExportGoodsApiV1GoodsExportExportExtensionGetResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest OperationBaseResponseSchema
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest HTTPValidationError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	}

	return response, nil
}

// ParseImportGoodsApplyChangesApiV1GoodsImportApplyChangesTaskIdPostResponse parses an HTTP response from a ImportGoodsApplyChangesApiV1GoodsImportApplyChangesTaskIdPostWithResponse call
func ParseImportGoodsApplyChangesApiV1GoodsImportApplyChangesTaskIdPostResponse(rsp *http.Response) (*ImportGoodsApplyChangesApiV1GoodsImportApplyChangesTaskIdPostResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ImportGoodsApplyChangesApiV1GoodsImportApplyChangesTaskIdPostResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest OperationBaseResponseSchema
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest HTTPValidationError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	}

	return response, nil
}

// ParseImportGoodsTaskStatusApiV1GoodsImportTaskStatusTaskIdGetResponse parses an HTTP response from a ImportGoodsTaskStatusApiV1GoodsImportTaskStatusTaskIdGetWithResponse call
func ParseImportGoodsTaskStatusApiV1GoodsImportTaskStatusTaskIdGetResponse(rsp *http.Response) (*ImportGoodsTaskStatusApiV1GoodsImportTaskStatusTaskIdGetResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ImportGoodsTaskStatusApiV1GoodsImportTaskStatusTaskIdGetResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest CheckStatusResponseSchema
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest HTTPValidationError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	}

	return response, nil
}

// ParseImportGoodsFromFileApiV1GoodsImportUploadPostResponse parses an HTTP response from a ImportGoodsFromFileApiV1GoodsImportUploadPostWithResponse call
func ParseImportGoodsFromFileApiV1GoodsImportUploadPostResponse(rsp *http.Response) (*ImportGoodsFromFileApiV1GoodsImportUploadPostResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ImportGoodsFromFileApiV1GoodsImportUploadPostResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest OperationBaseResponseSchema
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest HTTPValidationError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	}

	return response, nil
}

// ParseGetGoodApiV1GoodsGoodIdGetResponse parses an HTTP response from a GetGoodApiV1GoodsGoodIdGetWithResponse call
func ParseGetGoodApiV1GoodsGoodIdGetResponse(rsp *http.Response) (*GetGoodApiV1GoodsGoodIdGetResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetGoodApiV1GoodsGoodIdGetResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SrsoSchemaGoodSchemaGoodModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest HTTPValidationError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	}

	return response, nil
}

// ParseGetOrdersApiV1OrdersGetResponse parses an HTTP response from a GetOrdersApiV1OrdersGetWithResponse call
func ParseGetOrdersApiV1OrdersGetResponse(rsp *http.Response) (*GetOrdersApiV1OrdersGetResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetOrdersApiV1OrdersGetResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PaginatedResultOrderModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest HTTPValidationError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	}

	return response, nil
}

// ParseAddOrdersApiV1OrdersPostResponse parses an HTTP response from a AddOrdersApiV1OrdersPostWithResponse call
func ParseAddOrdersApiV1OrdersPostResponse(rsp *http.Response) (*AddOrdersApiV1OrdersPostResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AddOrdersApiV1OrdersPostResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			union json.RawMessage
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest HTTPValidationError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	}

	return response, nil
}

// ParseCloseNotFiscalizeOrderApiV1OrdersClosePatchResponse parses an HTTP response from a CloseNotFiscalizeOrderApiV1OrdersClosePatchWithResponse call
func ParseCloseNotFiscalizeOrderApiV1OrdersClosePatchResponse(rsp *http.Response) (*CloseNotFiscalizeOrderApiV1OrdersClosePatchResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CloseNotFiscalizeOrderApiV1OrdersClosePatchResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest OrderModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest HTTPValidationError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	}

	return response, nil
}

// ParseUpdateCustomOrderStatusApiV1OrdersCustomStatusOrderIdPatchResponse parses an HTTP response from a UpdateCustomOrderStatusApiV1OrdersCustomStatusOrderIdPatchWithResponse call
func ParseUpdateCustomOrderStatusApiV1OrdersCustomStatusOrderIdPatchResponse(rsp *http.Response) (*UpdateCustomOrderStatusApiV1OrdersCustomStatusOrderIdPatchResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateCustomOrderStatusApiV1OrdersCustomStatusOrderIdPatchResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest OrderModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest HTTPValidationError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	}

	return response, nil
}

// ParseDeleteIntegrationApiV1OrdersIntegrationDeleteResponse parses an HTTP response from a DeleteIntegrationApiV1OrdersIntegrationDeleteWithResponse call
func ParseDeleteIntegrationApiV1OrdersIntegrationDeleteResponse(rsp *http.Response) (*DeleteIntegrationApiV1OrdersIntegrationDeleteResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteIntegrationApiV1OrdersIntegrationDeleteResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest DeleteIntegrationSchema
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest HTTPValidationError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	}

	return response, nil
}

// ParseGetIntegrationApiV1OrdersIntegrationGetResponse parses an HTTP response from a GetIntegrationApiV1OrdersIntegrationGetWithResponse call
func ParseGetIntegrationApiV1OrdersIntegrationGetResponse(rsp *http.Response) (*GetIntegrationApiV1OrdersIntegrationGetResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetIntegrationApiV1OrdersIntegrationGetResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest IntegrationInfoSchema
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest HTTPValidationError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	}

	return response, nil
}

// ParseSetIntegrationApiV1OrdersIntegrationPostResponse parses an HTTP response from a SetIntegrationApiV1OrdersIntegrationPostWithResponse call
func ParseSetIntegrationApiV1OrdersIntegrationPostResponse(rsp *http.Response) (*SetIntegrationApiV1OrdersIntegrationPostResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SetIntegrationApiV1OrdersIntegrationPostResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest IntegrationInfoResponseSchema
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest HTTPValidationError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	}

	return response, nil
}

// ParseEditOrderApiV1OrdersIntegrationEditOrderPostResponse parses an HTTP response from a EditOrderApiV1OrdersIntegrationEditOrderPostWithResponse call
func ParseEditOrderApiV1OrdersIntegrationEditOrderPostResponse(rsp *http.Response) (*EditOrderApiV1OrdersIntegrationEditOrderPostResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &EditOrderApiV1OrdersIntegrationEditOrderPostResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest IntegrationEditOrderReceiptSchema
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest HTTPValidationError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	}

	return response, nil
}

// ParseRunOrdersSynchronizationApiV1OrdersSyncPostResponse parses an HTTP response from a RunOrdersSynchronizationApiV1OrdersSyncPostWithResponse call
func ParseRunOrdersSynchronizationApiV1OrdersSyncPostResponse(rsp *http.Response) (*RunOrdersSynchronizationApiV1OrdersSyncPostResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RunOrdersSynchronizationApiV1OrdersSyncPostResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest HTTPValidationError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	}

	return response, nil
}

// ParseGetOrderApiV1OrdersOrderIdGetResponse parses an HTTP response from a GetOrderApiV1OrdersOrderIdGetWithResponse call
func ParseGetOrderApiV1OrdersOrderIdGetResponse(rsp *http.Response) (*GetOrderApiV1OrdersOrderIdGetResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetOrderApiV1OrdersOrderIdGetResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest OrderModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest HTTPValidationError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	}

	return response, nil
}

// ParseCancelOrderApiV1OrdersOrderIdPatchResponse parses an HTTP response from a CancelOrderApiV1OrdersOrderIdPatchWithResponse call
func ParseCancelOrderApiV1OrdersOrderIdPatchResponse(rsp *http.Response) (*CancelOrderApiV1OrdersOrderIdPatchResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CancelOrderApiV1OrdersOrderIdPatchResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest OrderModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest HTTPValidationError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	}

	return response, nil
}

// ParseGetCurrentOrganizationLogoApiV1OrganizationLogoPngGetResponse parses an HTTP response from a GetCurrentOrganizationLogoApiV1OrganizationLogoPngGetWithResponse call
func ParseGetCurrentOrganizationLogoApiV1OrganizationLogoPngGetResponse(rsp *http.Response) (*GetCurrentOrganizationLogoApiV1OrganizationLogoPngGetResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetCurrentOrganizationLogoApiV1OrganizationLogoPngGetResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest HTTPValidationError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	}

	return response, nil
}

// ParseGetCurrentOrganizationReceiptSettingsApiV1OrganizationReceiptConfigGetResponse parses an HTTP response from a GetCurrentOrganizationReceiptSettingsApiV1OrganizationReceiptConfigGetWithResponse call
func ParseGetCurrentOrganizationReceiptSettingsApiV1OrganizationReceiptConfigGetResponse(rsp *http.Response) (*GetCurrentOrganizationReceiptSettingsApiV1OrganizationReceiptConfigGetResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetCurrentOrganizationReceiptSettingsApiV1OrganizationReceiptConfigGetResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest OrganizationReceiptConfigSchema
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest HTTPValidationError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	}

	return response, nil
}

// ParseGetCurrentOrganizationSmsBillingBalanceApiV1OrganizationSmsBillingGetResponse parses an HTTP response from a GetCurrentOrganizationSmsBillingBalanceApiV1OrganizationSmsBillingGetWithResponse call
func ParseGetCurrentOrganizationSmsBillingBalanceApiV1OrganizationSmsBillingGetResponse(rsp *http.Response) (*GetCurrentOrganizationSmsBillingBalanceApiV1OrganizationSmsBillingGetResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetCurrentOrganizationSmsBillingBalanceApiV1OrganizationSmsBillingGetResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest OrganizationBillingSchema
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest HTTPValidationError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	}

	return response, nil
}

// ParseGetCurrentOrganizationTextLogoApiV1OrganizationTextLogoPngGetResponse parses an HTTP response from a GetCurrentOrganizationTextLogoApiV1OrganizationTextLogoPngGetWithResponse call
func ParseGetCurrentOrganizationTextLogoApiV1OrganizationTextLogoPngGetResponse(rsp *http.Response) (*GetCurrentOrganizationTextLogoApiV1OrganizationTextLogoPngGetResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetCurrentOrganizationTextLogoApiV1OrganizationTextLogoPngGetResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest HTTPValidationError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	}

	return response, nil
}

// ParseGetReceiptsApiV1ReceiptsGetResponse parses an HTTP response from a GetReceiptsApiV1ReceiptsGetWithResponse call
func ParseGetReceiptsApiV1ReceiptsGetResponse(rsp *http.Response) (*GetReceiptsApiV1ReceiptsGetResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetReceiptsApiV1ReceiptsGetResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PaginatedResultReceiptModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest HTTPValidationError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	}

	return response, nil
}

// ParseAddExternalReceiptApiV1ReceiptsAddExternalPostResponse parses an HTTP response from a AddExternalReceiptApiV1ReceiptsAddExternalPostWithResponse call
func ParseAddExternalReceiptApiV1ReceiptsAddExternalPostResponse(rsp *http.Response) (*AddExternalReceiptApiV1ReceiptsAddExternalPostResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AddExternalReceiptApiV1ReceiptsAddExternalPostResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest ReceiptModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest HTTPValidationError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	}

	return response, nil
}

// ParseCashWithdrawalApiV1ReceiptsCashWithdrawalPostResponse parses an HTTP response from a CashWithdrawalApiV1ReceiptsCashWithdrawalPostWithResponse call
func ParseCashWithdrawalApiV1ReceiptsCashWithdrawalPostResponse(rsp *http.Response) (*CashWithdrawalApiV1ReceiptsCashWithdrawalPostResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CashWithdrawalApiV1ReceiptsCashWithdrawalPostResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ReceiptModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest HTTPValidationError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	}

	return response, nil
}

// ParseExchangeApiV1ReceiptsCurrencyExchangePostResponse parses an HTTP response from a ExchangeApiV1ReceiptsCurrencyExchangePostWithResponse call
func ParseExchangeApiV1ReceiptsCurrencyExchangePostResponse(rsp *http.Response) (*ExchangeApiV1ReceiptsCurrencyExchangePostResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ExchangeApiV1ReceiptsCurrencyExchangePostResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ReceiptModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest HTTPValidationError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	}

	return response, nil
}

// ParseGetReceiptsSearchApiV1ReceiptsSearchGetResponse parses an HTTP response from a GetReceiptsSearchApiV1ReceiptsSearchGetWithResponse call
func ParseGetReceiptsSearchApiV1ReceiptsSearchGetResponse(rsp *http.Response) (*GetReceiptsSearchApiV1ReceiptsSearchGetResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetReceiptsSearchApiV1ReceiptsSearchGetResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PaginatedResultReceiptModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest HTTPValidationError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	}

	return response, nil
}

// ParseCreateReceiptApiV1ReceiptsSellPostResponse parses an HTTP response from a CreateReceiptApiV1ReceiptsSellPostWithResponse call
func ParseCreateReceiptApiV1ReceiptsSellPostResponse(rsp *http.Response) (*CreateReceiptApiV1ReceiptsSellPostResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateReceiptApiV1ReceiptsSellPostResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest ReceiptModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest HTTPValidationError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	}

	return response, nil
}

// ParseCreateOfflineReceiptApiV1ReceiptsSellOfflinePostResponse parses an HTTP response from a CreateOfflineReceiptApiV1ReceiptsSellOfflinePostWithResponse call
func ParseCreateOfflineReceiptApiV1ReceiptsSellOfflinePostResponse(rsp *http.Response) (*CreateOfflineReceiptApiV1ReceiptsSellOfflinePostResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateOfflineReceiptApiV1ReceiptsSellOfflinePostResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest ReceiptModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest HTTPValidationError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	}

	return response, nil
}

// ParseCreateServiceReceiptApiV1ReceiptsServicePostResponse parses an HTTP response from a CreateServiceReceiptApiV1ReceiptsServicePostWithResponse call
func ParseCreateServiceReceiptApiV1ReceiptsServicePostResponse(rsp *http.Response) (*CreateServiceReceiptApiV1ReceiptsServicePostResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateServiceReceiptApiV1ReceiptsServicePostResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest ReceiptModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest HTTPValidationError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	}

	return response, nil
}

// ParseCreateServiceCurrencyReceiptApiV1ReceiptsServiceCurrencyPostResponse parses an HTTP response from a CreateServiceCurrencyReceiptApiV1ReceiptsServiceCurrencyPostWithResponse call
func ParseCreateServiceCurrencyReceiptApiV1ReceiptsServiceCurrencyPostResponse(rsp *http.Response) (*CreateServiceCurrencyReceiptApiV1ReceiptsServiceCurrencyPostResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateServiceCurrencyReceiptApiV1ReceiptsServiceCurrencyPostResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest ReceiptModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest HTTPValidationError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	}

	return response, nil
}

// ParseGetReceiptApiV1ReceiptsReceiptIdGetResponse parses an HTTP response from a GetReceiptApiV1ReceiptsReceiptIdGetWithResponse call
func ParseGetReceiptApiV1ReceiptsReceiptIdGetResponse(rsp *http.Response) (*GetReceiptApiV1ReceiptsReceiptIdGetResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetReceiptApiV1ReceiptsReceiptIdGetResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ReceiptModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest HTTPValidationError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	}

	return response, nil
}

// ParseSendReceiptToEmailApiV1ReceiptsReceiptIdEmailPostResponse parses an HTTP response from a SendReceiptToEmailApiV1ReceiptsReceiptIdEmailPostWithResponse call
func ParseSendReceiptToEmailApiV1ReceiptsReceiptIdEmailPostResponse(rsp *http.Response) (*SendReceiptToEmailApiV1ReceiptsReceiptIdEmailPostResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SendReceiptToEmailApiV1ReceiptsReceiptIdEmailPostResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest HTTPValidationError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	}

	return response, nil
}

// ParseGetReceiptHtmlApiV1ReceiptsReceiptIdHtmlGetResponse parses an HTTP response from a GetReceiptHtmlApiV1ReceiptsReceiptIdHtmlGetWithResponse call
func ParseGetReceiptHtmlApiV1ReceiptsReceiptIdHtmlGetResponse(rsp *http.Response) (*GetReceiptHtmlApiV1ReceiptsReceiptIdHtmlGetResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetReceiptHtmlApiV1ReceiptsReceiptIdHtmlGetResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest HTTPValidationError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	}

	return response, nil
}

// ParseGetReceiptPdfApiV1ReceiptsReceiptIdPdfGetResponse parses an HTTP response from a GetReceiptPdfApiV1ReceiptsReceiptIdPdfGetWithResponse call
func ParseGetReceiptPdfApiV1ReceiptsReceiptIdPdfGetResponse(rsp *http.Response) (*GetReceiptPdfApiV1ReceiptsReceiptIdPdfGetResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetReceiptPdfApiV1ReceiptsReceiptIdPdfGetResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest HTTPValidationError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	}

	return response, nil
}

// ParseGetReceiptPngApiV1ReceiptsReceiptIdPngGetResponse parses an HTTP response from a GetReceiptPngApiV1ReceiptsReceiptIdPngGetWithResponse call
func ParseGetReceiptPngApiV1ReceiptsReceiptIdPngGetResponse(rsp *http.Response) (*GetReceiptPngApiV1ReceiptsReceiptIdPngGetResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetReceiptPngApiV1ReceiptsReceiptIdPngGetResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest HTTPValidationError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	}

	return response, nil
}

// ParseGetReceiptQrCodeImageApiV1ReceiptsReceiptIdQrcodeGetResponse parses an HTTP response from a GetReceiptQrCodeImageApiV1ReceiptsReceiptIdQrcodeGetWithResponse call
func ParseGetReceiptQrCodeImageApiV1ReceiptsReceiptIdQrcodeGetResponse(rsp *http.Response) (*GetReceiptQrCodeImageApiV1ReceiptsReceiptIdQrcodeGetResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetReceiptQrCodeImageApiV1ReceiptsReceiptIdQrcodeGetResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest HTTPValidationError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	}

	return response, nil
}

// ParseSendReceiptViaSmsApiV1ReceiptsReceiptIdSmsPostResponse parses an HTTP response from a SendReceiptViaSmsApiV1ReceiptsReceiptIdSmsPostWithResponse call
func ParseSendReceiptViaSmsApiV1ReceiptsReceiptIdSmsPostResponse(rsp *http.Response) (*SendReceiptViaSmsApiV1ReceiptsReceiptIdSmsPostResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SendReceiptViaSmsApiV1ReceiptsReceiptIdSmsPostResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest HTTPValidationError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	}

	return response, nil
}

// ParseGetReceiptTextApiV1ReceiptsReceiptIdTextGetResponse parses an HTTP response from a GetReceiptTextApiV1ReceiptsReceiptIdTextGetWithResponse call
func ParseGetReceiptTextApiV1ReceiptsReceiptIdTextGetResponse(rsp *http.Response) (*GetReceiptTextApiV1ReceiptsReceiptIdTextGetResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetReceiptTextApiV1ReceiptsReceiptIdTextGetResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest HTTPValidationError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	}

	return response, nil
}

// ParseGetReceiptXmlApiV1ReceiptsReceiptIdXmlGetResponse parses an HTTP response from a GetReceiptXmlApiV1ReceiptsReceiptIdXmlGetWithResponse call
func ParseGetReceiptXmlApiV1ReceiptsReceiptIdXmlGetResponse(rsp *http.Response) (*GetReceiptXmlApiV1ReceiptsReceiptIdXmlGetResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetReceiptXmlApiV1ReceiptsReceiptIdXmlGetResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest HTTPValidationError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	}

	return response, nil
}

// ParseGetReportsApiV1ReportsGetResponse parses an HTTP response from a GetReportsApiV1ReportsGetWithResponse call
func ParseGetReportsApiV1ReportsGetResponse(rsp *http.Response) (*GetReportsApiV1ReportsGetResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetReportsApiV1ReportsGetResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PaginatedResultReportModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest HTTPValidationError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	}

	return response, nil
}

// ParseCreateXReportApiV1ReportsPostResponse parses an HTTP response from a CreateXReportApiV1ReportsPostWithResponse call
func ParseCreateXReportApiV1ReportsPostResponse(rsp *http.Response) (*CreateXReportApiV1ReportsPostResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateXReportApiV1ReportsPostResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest ReportModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest HTTPValidationError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	}

	return response, nil
}

// ParseAddExternalReportApiV1ReportsAddExternalPostResponse parses an HTTP response from a AddExternalReportApiV1ReportsAddExternalPostWithResponse call
func ParseAddExternalReportApiV1ReportsAddExternalPostResponse(rsp *http.Response) (*AddExternalReportApiV1ReportsAddExternalPostResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AddExternalReportApiV1ReportsAddExternalPostResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest ReportModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest HTTPValidationError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	}

	return response, nil
}

// ParseGetPeriodicalReportApiV1ReportsPeriodicalGetResponse parses an HTTP response from a GetPeriodicalReportApiV1ReportsPeriodicalGetWithResponse call
func ParseGetPeriodicalReportApiV1ReportsPeriodicalGetResponse(rsp *http.Response) (*GetPeriodicalReportApiV1ReportsPeriodicalGetResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetPeriodicalReportApiV1ReportsPeriodicalGetResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest HTTPValidationError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	}

	return response, nil
}

// ParseGetSearchReportsApiV1ReportsSearchGetResponse parses an HTTP response from a GetSearchReportsApiV1ReportsSearchGetWithResponse call
func ParseGetSearchReportsApiV1ReportsSearchGetResponse(rsp *http.Response) (*GetSearchReportsApiV1ReportsSearchGetResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetSearchReportsApiV1ReportsSearchGetResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PaginatedResultReportModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest HTTPValidationError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	}

	return response, nil
}

// ParseGetReportApiV1ReportsReportIdGetResponse parses an HTTP response from a GetReportApiV1ReportsReportIdGetWithResponse call
func ParseGetReportApiV1ReportsReportIdGetResponse(rsp *http.Response) (*GetReportApiV1ReportsReportIdGetResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetReportApiV1ReportsReportIdGetResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ReportModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest HTTPValidationError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	}

	return response, nil
}

// ParseGetReportTextApiV1ReportsReportIdTextGetResponse parses an HTTP response from a GetReportTextApiV1ReportsReportIdTextGetWithResponse call
func ParseGetReportTextApiV1ReportsReportIdTextGetResponse(rsp *http.Response) (*GetReportTextApiV1ReportsReportIdTextGetResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetReportTextApiV1ReportsReportIdTextGetResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest HTTPValidationError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	}

	return response, nil
}

// ParseGetShiftsApiV1ShiftsGetResponse parses an HTTP response from a GetShiftsApiV1ShiftsGetWithResponse call
func ParseGetShiftsApiV1ShiftsGetResponse(rsp *http.Response) (*GetShiftsApiV1ShiftsGetResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetShiftsApiV1ShiftsGetResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PaginatedResultShiftWithCashRegisterModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest HTTPValidationError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	}

	return response, nil
}

// ParseCreateShiftApiV1ShiftsPostResponse parses an HTTP response from a CreateShiftApiV1ShiftsPostWithResponse call
func ParseCreateShiftApiV1ShiftsPostResponse(rsp *http.Response) (*CreateShiftApiV1ShiftsPostResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateShiftApiV1ShiftsPostResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest ShiftWithCashierAndCashRegister
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest HTTPValidationError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	}

	return response, nil
}

// ParseCloseShiftApiV1ShiftsClosePostResponse parses an HTTP response from a CloseShiftApiV1ShiftsClosePostWithResponse call
func ParseCloseShiftApiV1ShiftsClosePostResponse(rsp *http.Response) (*CloseShiftApiV1ShiftsClosePostResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CloseShiftApiV1ShiftsClosePostResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest ShiftWithCashierAndCashRegister
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest HTTPValidationError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	}

	return response, nil
}

// ParseGetShiftApiV1ShiftsShiftIdGetResponse parses an HTTP response from a GetShiftApiV1ShiftsShiftIdGetWithResponse call
func ParseGetShiftApiV1ShiftsShiftIdGetResponse(rsp *http.Response) (*GetShiftApiV1ShiftsShiftIdGetResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetShiftApiV1ShiftsShiftIdGetResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ShiftWithCashierAndCashRegister
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest HTTPValidationError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	}

	return response, nil
}

// ParseCloseShiftBySeniorCashierApiV1ShiftsShiftIdClosePostResponse parses an HTTP response from a CloseShiftBySeniorCashierApiV1ShiftsShiftIdClosePostWithResponse call
func ParseCloseShiftBySeniorCashierApiV1ShiftsShiftIdClosePostResponse(rsp *http.Response) (*CloseShiftBySeniorCashierApiV1ShiftsShiftIdClosePostResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CloseShiftBySeniorCashierApiV1ShiftsShiftIdClosePostResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ShiftWithCashierAndCashRegister
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest HTTPValidationError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	}

	return response, nil
}

// ParseGetAllTaxesApiV1TaxGetResponse parses an HTTP response from a GetAllTaxesApiV1TaxGetWithResponse call
func ParseGetAllTaxesApiV1TaxGetResponse(rsp *http.Response) (*GetAllTaxesApiV1TaxGetResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetAllTaxesApiV1TaxGetResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []TaxModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest HTTPValidationError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	}

	return response, nil
}

// ParseGetTransactionsApiV1TransactionsGetResponse parses an HTTP response from a GetTransactionsApiV1TransactionsGetWithResponse call
func ParseGetTransactionsApiV1TransactionsGetResponse(rsp *http.Response) (*GetTransactionsApiV1TransactionsGetResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetTransactionsApiV1TransactionsGetResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PaginatedResultShortTransaction
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest HTTPValidationError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	}

	return response, nil
}

// ParseGetTransactionApiV1TransactionsTransactionIdGetResponse parses an HTTP response from a GetTransactionApiV1TransactionsTransactionIdGetWithResponse call
func ParseGetTransactionApiV1TransactionsTransactionIdGetResponse(rsp *http.Response) (*GetTransactionApiV1TransactionsTransactionIdGetResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetTransactionApiV1TransactionsTransactionIdGetResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest TransactionModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest HTTPValidationError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	}

	return response, nil
}

// ParseUpdateTransactionApiV1TransactionsTransactionIdPatchResponse parses an HTTP response from a UpdateTransactionApiV1TransactionsTransactionIdPatchWithResponse call
func ParseUpdateTransactionApiV1TransactionsTransactionIdPatchResponse(rsp *http.Response) (*UpdateTransactionApiV1TransactionsTransactionIdPatchResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateTransactionApiV1TransactionsTransactionIdPatchResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest TransactionModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest HTTPValidationError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	}

	return response, nil
}

// ParseDeleteWebhookApiV1WebhookDeleteResponse parses an HTTP response from a DeleteWebhookApiV1WebhookDeleteWithResponse call
func ParseDeleteWebhookApiV1WebhookDeleteResponse(rsp *http.Response) (*DeleteWebhookApiV1WebhookDeleteResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteWebhookApiV1WebhookDeleteResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest DeleteWebhookSchema
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest HTTPValidationError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	}

	return response, nil
}

// ParseGetWebhookInfoApiV1WebhookGetResponse parses an HTTP response from a GetWebhookInfoApiV1WebhookGetWithResponse call
func ParseGetWebhookInfoApiV1WebhookGetResponse(rsp *http.Response) (*GetWebhookInfoApiV1WebhookGetResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetWebhookInfoApiV1WebhookGetResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest WebhookInfoSchema
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest HTTPValidationError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	}

	return response, nil
}

// ParseSetWebhookApiV1WebhookPostResponse parses an HTTP response from a SetWebhookApiV1WebhookPostWithResponse call
func ParseSetWebhookApiV1WebhookPostResponse(rsp *http.Response) (*SetWebhookApiV1WebhookPostResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SetWebhookApiV1WebhookPostResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest WebhookInfoResponseSchema
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest HTTPValidationError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	}

	return response, nil
}

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// Get Cash Registers
	// (GET /api/v1/cash-registers)
	GetCashRegistersApiV1CashRegistersGet(ctx echo.Context, params GetCashRegistersApiV1CashRegistersGetParams) error
	// Ask Offline Codes
	// (GET /api/v1/cash-registers/ask-offline-codes)
	AskOfflineCodesApiV1CashRegistersAskOfflineCodesGet(ctx echo.Context, params AskOfflineCodesApiV1CashRegistersAskOfflineCodesGetParams) error
	// Get Offline Codes
	// (GET /api/v1/cash-registers/get-offline-codes)
	GetOfflineCodesApiV1CashRegistersGetOfflineCodesGet(ctx echo.Context, params GetOfflineCodesApiV1CashRegistersGetOfflineCodesGetParams) error
	// Get Offline Codes Count
	// (GET /api/v1/cash-registers/get-offline-codes-count)
	GetOfflineCodesCountApiV1CashRegistersGetOfflineCodesCountGet(ctx echo.Context, params GetOfflineCodesCountApiV1CashRegistersGetOfflineCodesCountGetParams) error
	// Get Offline Time
	// (GET /api/v1/cash-registers/get-offline-time)
	GetOfflineTimeApiV1CashRegistersGetOfflineTimeGet(ctx echo.Context, params GetOfflineTimeApiV1CashRegistersGetOfflineTimeGetParams) error
	// Go Offline Action
	// (POST /api/v1/cash-registers/go-offline)
	GoOfflineActionApiV1CashRegistersGoOfflinePost(ctx echo.Context, params GoOfflineActionApiV1CashRegistersGoOfflinePostParams) error
	// Go Online Action
	// (POST /api/v1/cash-registers/go-online)
	GoOnlineActionApiV1CashRegistersGoOnlinePost(ctx echo.Context, params GoOnlineActionApiV1CashRegistersGoOnlinePostParams) error
	// Get Cash Register Info
	// (GET /api/v1/cash-registers/info)
	GetCashRegisterInfoApiV1CashRegistersInfoGet(ctx echo.Context, params GetCashRegisterInfoApiV1CashRegistersInfoGetParams) error
	// Ping Tax Service Action
	// (POST /api/v1/cash-registers/ping-tax-service)
	PingTaxServiceActionApiV1CashRegistersPingTaxServicePost(ctx echo.Context, params PingTaxServiceActionApiV1CashRegistersPingTaxServicePostParams) error
	// Get Cash Register
	// (GET /api/v1/cash-registers/{cash_register_id})
	GetCashRegisterApiV1CashRegistersCashRegisterIdGet(ctx echo.Context, cashRegisterId openapi_types.UUID, params GetCashRegisterApiV1CashRegistersCashRegisterIdGetParams) error
	// Check Signature
	// (GET /api/v1/cashier/check-signature)
	CheckSignatureApiV1CashierCheckSignatureGet(ctx echo.Context, params CheckSignatureApiV1CashierCheckSignatureGetParams) error
	// Get Cashier Profile
	// (GET /api/v1/cashier/me)
	GetCashierProfileApiV1CashierMeGet(ctx echo.Context, params GetCashierProfileApiV1CashierMeGetParams) error
	// Get Cashier Shift
	// (GET /api/v1/cashier/shift)
	GetCashierShiftApiV1CashierShiftGet(ctx echo.Context, params GetCashierShiftApiV1CashierShiftGetParams) error
	// Sign In Cashier
	// (POST /api/v1/cashier/signin)
	SignInCashierApiV1CashierSigninPost(ctx echo.Context, params SignInCashierApiV1CashierSigninPostParams) error
	// Sign In Cashier Via Pin Code
	// (POST /api/v1/cashier/signinPinCode)
	SignInCashierViaPinCodeApiV1CashierSigninPinCodePost(ctx echo.Context, params SignInCashierViaPinCodeApiV1CashierSigninPinCodePostParams) error
	// Sign Out Cashier
	// (POST /api/v1/cashier/signout)
	SignOutCashierApiV1CashierSignoutPost(ctx echo.Context, params SignOutCashierApiV1CashierSignoutPostParams) error
	// Get Currency Rates
	// (GET /api/v1/currency/rate)
	GetCurrencyRatesApiV1CurrencyRateGet(ctx echo.Context, params GetCurrencyRatesApiV1CurrencyRateGetParams) error
	// Setup Currency Rates
	// (POST /api/v1/currency/rate/setup)
	SetupCurrencyRatesApiV1CurrencyRateSetupPost(ctx echo.Context, params SetupCurrencyRatesApiV1CurrencyRateSetupPostParams) error
	// Get Currency Rate
	// (GET /api/v1/currency/rate/{currency_code})
	GetCurrencyRateApiV1CurrencyRateCurrencyCodeGet(ctx echo.Context, currencyCode string, params GetCurrencyRateApiV1CurrencyRateCurrencyCodeGetParams) error
	// Goods Report
	// (POST /api/v1/extended-reports/goods)
	GoodsReportApiV1ExtendedReportsGoodsPost(ctx echo.Context, params GoodsReportApiV1ExtendedReportsGoodsPostParams) error
	// Get Report Task By Id
	// (GET /api/v1/extended-reports/{report_task_id})
	GetReportTaskByIdApiV1ExtendedReportsReportTaskIdGet(ctx echo.Context, reportTaskId openapi_types.UUID, params GetReportTaskByIdApiV1ExtendedReportsReportTaskIdGetParams) error
	// Get Report Xlsx By Id
	// (GET /api/v1/extended-reports/{report_task_id}/report.xlsx)
	GetReportXlsxByIdApiV1ExtendedReportsReportTaskIdReportXlsxGet(ctx echo.Context, reportTaskId openapi_types.UUID, params GetReportXlsxByIdApiV1ExtendedReportsReportTaskIdReportXlsxGetParams) error
	// Get Goods
	// (GET /api/v1/goods)
	GetGoodsApiV1GoodsGet(ctx echo.Context, params GetGoodsApiV1GoodsGetParams) error
	// Export Goods File
	// (GET /api/v1/goods/export/file/{task_id})
	ExportGoodsFileApiV1GoodsExportFileTaskIdGet(ctx echo.Context, taskId openapi_types.UUID, params ExportGoodsFileApiV1GoodsExportFileTaskIdGetParams) error
	// Export Goods Task Status
	// (GET /api/v1/goods/export/task_status/{task_id})
	ExportGoodsTaskStatusApiV1GoodsExportTaskStatusTaskIdGet(ctx echo.Context, taskId openapi_types.UUID, params ExportGoodsTaskStatusApiV1GoodsExportTaskStatusTaskIdGetParams) error
	// Export Goods
	// (GET /api/v1/goods/export/{export_extension})
	ExportGoodsApiV1GoodsExportExportExtensionGet(ctx echo.Context, exportExtension ExportExtensionType, params ExportGoodsApiV1GoodsExportExportExtensionGetParams) error
	// Import Goods Apply Changes
	// (POST /api/v1/goods/import/apply_changes/{task_id})
	ImportGoodsApplyChangesApiV1GoodsImportApplyChangesTaskIdPost(ctx echo.Context, taskId openapi_types.UUID, params ImportGoodsApplyChangesApiV1GoodsImportApplyChangesTaskIdPostParams) error
	// Import Goods Task Status
	// (GET /api/v1/goods/import/task_status/{task_id})
	ImportGoodsTaskStatusApiV1GoodsImportTaskStatusTaskIdGet(ctx echo.Context, taskId openapi_types.UUID, params ImportGoodsTaskStatusApiV1GoodsImportTaskStatusTaskIdGetParams) error
	// Import Goods From File
	// (POST /api/v1/goods/import/upload)
	ImportGoodsFromFileApiV1GoodsImportUploadPost(ctx echo.Context, params ImportGoodsFromFileApiV1GoodsImportUploadPostParams) error
	// Get Good
	// (GET /api/v1/goods/{good_id})
	GetGoodApiV1GoodsGoodIdGet(ctx echo.Context, goodId openapi_types.UUID, params GetGoodApiV1GoodsGoodIdGetParams) error
	// Get Orders
	// (GET /api/v1/orders)
	GetOrdersApiV1OrdersGet(ctx echo.Context, params GetOrdersApiV1OrdersGetParams) error
	// Add Orders
	// (POST /api/v1/orders)
	AddOrdersApiV1OrdersPost(ctx echo.Context, params AddOrdersApiV1OrdersPostParams) error
	// Close Not Fiscalize Order
	// (PATCH /api/v1/orders/close)
	CloseNotFiscalizeOrderApiV1OrdersClosePatch(ctx echo.Context, params CloseNotFiscalizeOrderApiV1OrdersClosePatchParams) error
	// Update Custom Order Status
	// (PATCH /api/v1/orders/custom_status/{order_id})
	UpdateCustomOrderStatusApiV1OrdersCustomStatusOrderIdPatch(ctx echo.Context, orderId openapi_types.UUID, params UpdateCustomOrderStatusApiV1OrdersCustomStatusOrderIdPatchParams) error
	// Delete Integration
	// (DELETE /api/v1/orders/integration)
	DeleteIntegrationApiV1OrdersIntegrationDelete(ctx echo.Context, params DeleteIntegrationApiV1OrdersIntegrationDeleteParams) error
	// Get Integration
	// (GET /api/v1/orders/integration)
	GetIntegrationApiV1OrdersIntegrationGet(ctx echo.Context, params GetIntegrationApiV1OrdersIntegrationGetParams) error
	// Set Integration
	// (POST /api/v1/orders/integration)
	SetIntegrationApiV1OrdersIntegrationPost(ctx echo.Context, params SetIntegrationApiV1OrdersIntegrationPostParams) error
	// Edit Order
	// (POST /api/v1/orders/integration/edit-order)
	EditOrderApiV1OrdersIntegrationEditOrderPost(ctx echo.Context, params EditOrderApiV1OrdersIntegrationEditOrderPostParams) error
	// Run Orders Synchronization
	// (POST /api/v1/orders/sync)
	RunOrdersSynchronizationApiV1OrdersSyncPost(ctx echo.Context, params RunOrdersSynchronizationApiV1OrdersSyncPostParams) error
	// Get Order
	// (GET /api/v1/orders/{order_id})
	GetOrderApiV1OrdersOrderIdGet(ctx echo.Context, orderId openapi_types.UUID, params GetOrderApiV1OrdersOrderIdGetParams) error
	// Cancel Order
	// (PATCH /api/v1/orders/{order_id})
	CancelOrderApiV1OrdersOrderIdPatch(ctx echo.Context, orderId openapi_types.UUID, params CancelOrderApiV1OrdersOrderIdPatchParams) error
	// Get Current Organization Logo
	// (GET /api/v1/organization/logo.png)
	GetCurrentOrganizationLogoApiV1OrganizationLogoPngGet(ctx echo.Context, params GetCurrentOrganizationLogoApiV1OrganizationLogoPngGetParams) error
	// Get Current Organization Receipt Settings
	// (GET /api/v1/organization/receipt-config)
	GetCurrentOrganizationReceiptSettingsApiV1OrganizationReceiptConfigGet(ctx echo.Context, params GetCurrentOrganizationReceiptSettingsApiV1OrganizationReceiptConfigGetParams) error
	// Get Current Organization Sms Billing Balance
	// (GET /api/v1/organization/sms-billing)
	GetCurrentOrganizationSmsBillingBalanceApiV1OrganizationSmsBillingGet(ctx echo.Context, params GetCurrentOrganizationSmsBillingBalanceApiV1OrganizationSmsBillingGetParams) error
	// Get Current Organization Text Logo
	// (GET /api/v1/organization/text_logo.png)
	GetCurrentOrganizationTextLogoApiV1OrganizationTextLogoPngGet(ctx echo.Context, params GetCurrentOrganizationTextLogoApiV1OrganizationTextLogoPngGetParams) error
	// Get Receipts
	// (GET /api/v1/receipts)
	GetReceiptsApiV1ReceiptsGet(ctx echo.Context, params GetReceiptsApiV1ReceiptsGetParams) error
	// Add External Receipt
	// (POST /api/v1/receipts/add-external)
	AddExternalReceiptApiV1ReceiptsAddExternalPost(ctx echo.Context, params AddExternalReceiptApiV1ReceiptsAddExternalPostParams) error
	// Cash Withdrawal
	// (POST /api/v1/receipts/cash-withdrawal)
	CashWithdrawalApiV1ReceiptsCashWithdrawalPost(ctx echo.Context, params CashWithdrawalApiV1ReceiptsCashWithdrawalPostParams) error
	// Exchange
	// (POST /api/v1/receipts/currency-exchange)
	ExchangeApiV1ReceiptsCurrencyExchangePost(ctx echo.Context, params ExchangeApiV1ReceiptsCurrencyExchangePostParams) error
	// Get Receipts Search
	// (GET /api/v1/receipts/search)
	GetReceiptsSearchApiV1ReceiptsSearchGet(ctx echo.Context, params GetReceiptsSearchApiV1ReceiptsSearchGetParams) error
	// Create Receipt
	// (POST /api/v1/receipts/sell)
	CreateReceiptApiV1ReceiptsSellPost(ctx echo.Context, params CreateReceiptApiV1ReceiptsSellPostParams) error
	// Create Offline Receipt
	// (POST /api/v1/receipts/sell-offline)
	CreateOfflineReceiptApiV1ReceiptsSellOfflinePost(ctx echo.Context, params CreateOfflineReceiptApiV1ReceiptsSellOfflinePostParams) error
	// Create Service Receipt
	// (POST /api/v1/receipts/service)
	CreateServiceReceiptApiV1ReceiptsServicePost(ctx echo.Context, params CreateServiceReceiptApiV1ReceiptsServicePostParams) error
	// Create Service Currency Receipt
	// (POST /api/v1/receipts/service-currency)
	CreateServiceCurrencyReceiptApiV1ReceiptsServiceCurrencyPost(ctx echo.Context, params CreateServiceCurrencyReceiptApiV1ReceiptsServiceCurrencyPostParams) error
	// Get Receipt
	// (GET /api/v1/receipts/{receipt_id})
	GetReceiptApiV1ReceiptsReceiptIdGet(ctx echo.Context, receiptId struct {
		union json.RawMessage
	}, params GetReceiptApiV1ReceiptsReceiptIdGetParams) error
	// Send Receipt To Email
	// (POST /api/v1/receipts/{receipt_id}/email)
	SendReceiptToEmailApiV1ReceiptsReceiptIdEmailPost(ctx echo.Context, receiptId struct {
		union json.RawMessage
	}, params SendReceiptToEmailApiV1ReceiptsReceiptIdEmailPostParams) error
	// Get Receipt Html
	// (GET /api/v1/receipts/{receipt_id}/html)
	GetReceiptHtmlApiV1ReceiptsReceiptIdHtmlGet(ctx echo.Context, receiptId struct {
		union json.RawMessage
	}, params GetReceiptHtmlApiV1ReceiptsReceiptIdHtmlGetParams) error
	// Get Receipt Pdf
	// (GET /api/v1/receipts/{receipt_id}/pdf)
	GetReceiptPdfApiV1ReceiptsReceiptIdPdfGet(ctx echo.Context, receiptId struct {
		union json.RawMessage
	}, params GetReceiptPdfApiV1ReceiptsReceiptIdPdfGetParams) error
	// Get Receipt Png
	// (GET /api/v1/receipts/{receipt_id}/png)
	GetReceiptPngApiV1ReceiptsReceiptIdPngGet(ctx echo.Context, receiptId struct {
		union json.RawMessage
	}, params GetReceiptPngApiV1ReceiptsReceiptIdPngGetParams) error
	// Get Receipt Qr Code Image
	// (GET /api/v1/receipts/{receipt_id}/qrcode)
	GetReceiptQrCodeImageApiV1ReceiptsReceiptIdQrcodeGet(ctx echo.Context, receiptId struct {
		union json.RawMessage
	}, params GetReceiptQrCodeImageApiV1ReceiptsReceiptIdQrcodeGetParams) error
	// Send Receipt Via Sms
	// (POST /api/v1/receipts/{receipt_id}/sms)
	SendReceiptViaSmsApiV1ReceiptsReceiptIdSmsPost(ctx echo.Context, receiptId struct {
		union json.RawMessage
	}, params SendReceiptViaSmsApiV1ReceiptsReceiptIdSmsPostParams) error
	// Get Receipt Text
	// (GET /api/v1/receipts/{receipt_id}/text)
	GetReceiptTextApiV1ReceiptsReceiptIdTextGet(ctx echo.Context, receiptId struct {
		union json.RawMessage
	}, params GetReceiptTextApiV1ReceiptsReceiptIdTextGetParams) error
	// Get Receipt Xml
	// (GET /api/v1/receipts/{receipt_id}/xml)
	GetReceiptXmlApiV1ReceiptsReceiptIdXmlGet(ctx echo.Context, receiptId struct {
		union json.RawMessage
	}, params GetReceiptXmlApiV1ReceiptsReceiptIdXmlGetParams) error
	// Get Reports
	// (GET /api/v1/reports)
	GetReportsApiV1ReportsGet(ctx echo.Context, params GetReportsApiV1ReportsGetParams) error
	// Create X Report
	// (POST /api/v1/reports)
	CreateXReportApiV1ReportsPost(ctx echo.Context, params CreateXReportApiV1ReportsPostParams) error
	// Add External Report
	// (POST /api/v1/reports/add-external)
	AddExternalReportApiV1ReportsAddExternalPost(ctx echo.Context, params AddExternalReportApiV1ReportsAddExternalPostParams) error
	// Get Periodical Report
	// (GET /api/v1/reports/periodical)
	GetPeriodicalReportApiV1ReportsPeriodicalGet(ctx echo.Context, params GetPeriodicalReportApiV1ReportsPeriodicalGetParams) error
	// Get Search Reports
	// (GET /api/v1/reports/search)
	GetSearchReportsApiV1ReportsSearchGet(ctx echo.Context, params GetSearchReportsApiV1ReportsSearchGetParams) error
	// Get Report
	// (GET /api/v1/reports/{report_id})
	GetReportApiV1ReportsReportIdGet(ctx echo.Context, reportId openapi_types.UUID, params GetReportApiV1ReportsReportIdGetParams) error
	// Get Report Text
	// (GET /api/v1/reports/{report_id}/text)
	GetReportTextApiV1ReportsReportIdTextGet(ctx echo.Context, reportId openapi_types.UUID, params GetReportTextApiV1ReportsReportIdTextGetParams) error
	// Get Shifts
	// (GET /api/v1/shifts)
	GetShiftsApiV1ShiftsGet(ctx echo.Context, params GetShiftsApiV1ShiftsGetParams) error
	// Create Shift
	// (POST /api/v1/shifts)
	CreateShiftApiV1ShiftsPost(ctx echo.Context, params CreateShiftApiV1ShiftsPostParams) error
	// Close Shift
	// (POST /api/v1/shifts/close)
	CloseShiftApiV1ShiftsClosePost(ctx echo.Context, params CloseShiftApiV1ShiftsClosePostParams) error
	// Get Shift
	// (GET /api/v1/shifts/{shift_id})
	GetShiftApiV1ShiftsShiftIdGet(ctx echo.Context, shiftId openapi_types.UUID, params GetShiftApiV1ShiftsShiftIdGetParams) error
	// Close Shift By Senior Cashier
	// (POST /api/v1/shifts/{shift_id}/close)
	CloseShiftBySeniorCashierApiV1ShiftsShiftIdClosePost(ctx echo.Context, shiftId openapi_types.UUID, params CloseShiftBySeniorCashierApiV1ShiftsShiftIdClosePostParams) error
	// Get All Taxes
	// (GET /api/v1/tax)
	GetAllTaxesApiV1TaxGet(ctx echo.Context, params GetAllTaxesApiV1TaxGetParams) error
	// Get Transactions
	// (GET /api/v1/transactions)
	GetTransactionsApiV1TransactionsGet(ctx echo.Context, params GetTransactionsApiV1TransactionsGetParams) error
	// Get Transaction
	// (GET /api/v1/transactions/{transaction_id})
	GetTransactionApiV1TransactionsTransactionIdGet(ctx echo.Context, transactionId openapi_types.UUID, params GetTransactionApiV1TransactionsTransactionIdGetParams) error
	// Update Transaction
	// (PATCH /api/v1/transactions/{transaction_id})
	UpdateTransactionApiV1TransactionsTransactionIdPatch(ctx echo.Context, transactionId openapi_types.UUID, params UpdateTransactionApiV1TransactionsTransactionIdPatchParams) error
	// Delete Webhook
	// (DELETE /api/v1/webhook)
	DeleteWebhookApiV1WebhookDelete(ctx echo.Context, params DeleteWebhookApiV1WebhookDeleteParams) error
	// Get Webhook Info
	// (GET /api/v1/webhook)
	GetWebhookInfoApiV1WebhookGet(ctx echo.Context, params GetWebhookInfoApiV1WebhookGetParams) error
	// Set Webhook
	// (POST /api/v1/webhook)
	SetWebhookApiV1WebhookPost(ctx echo.Context, params SetWebhookApiV1WebhookPostParams) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

// GetCashRegistersApiV1CashRegistersGet converts echo context to params.
func (w *ServerInterfaceWrapper) GetCashRegistersApiV1CashRegistersGet(ctx echo.Context) error {
	var err error

	ctx.Set(CashierJWTtokenScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetCashRegistersApiV1CashRegistersGetParams
	// ------------- Optional query parameter "in_use" -------------

	err = runtime.BindQueryParameter("form", true, false, "in_use", ctx.QueryParams(), &params.InUse)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter in_use: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "offset" -------------

	err = runtime.BindQueryParameter("form", true, false, "offset", ctx.QueryParams(), &params.Offset)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter offset: %s", err))
	}

	headers := ctx.Request().Header
	// ------------- Optional header parameter "X-Client-Name" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Client-Name")]; found {
		var XClientName string
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for X-Client-Name, got %d", n))
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "X-Client-Name", runtime.ParamLocationHeader, valueList[0], &XClientName)
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter X-Client-Name: %s", err))
		}

		params.XClientName = &XClientName
	}
	// ------------- Optional header parameter "X-Client-Version" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Client-Version")]; found {
		var XClientVersion string
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for X-Client-Version, got %d", n))
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "X-Client-Version", runtime.ParamLocationHeader, valueList[0], &XClientVersion)
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter X-Client-Version: %s", err))
		}

		params.XClientVersion = &XClientVersion
	}
	// ------------- Optional header parameter "X-Access-Key" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Access-Key")]; found {
		var XAccessKey string
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for X-Access-Key, got %d", n))
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "X-Access-Key", runtime.ParamLocationHeader, valueList[0], &XAccessKey)
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter X-Access-Key: %s", err))
		}

		params.XAccessKey = &XAccessKey
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetCashRegistersApiV1CashRegistersGet(ctx, params)
	return err
}

// AskOfflineCodesApiV1CashRegistersAskOfflineCodesGet converts echo context to params.
func (w *ServerInterfaceWrapper) AskOfflineCodesApiV1CashRegistersAskOfflineCodesGet(ctx echo.Context) error {
	var err error

	ctx.Set(CashierJWTtokenScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AskOfflineCodesApiV1CashRegistersAskOfflineCodesGetParams
	// ------------- Optional query parameter "count" -------------

	err = runtime.BindQueryParameter("form", true, false, "count", ctx.QueryParams(), &params.Count)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter count: %s", err))
	}

	// ------------- Optional query parameter "sync" -------------

	err = runtime.BindQueryParameter("form", true, false, "sync", ctx.QueryParams(), &params.Sync)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sync: %s", err))
	}

	headers := ctx.Request().Header
	// ------------- Optional header parameter "X-Client-Name" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Client-Name")]; found {
		var XClientName string
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for X-Client-Name, got %d", n))
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "X-Client-Name", runtime.ParamLocationHeader, valueList[0], &XClientName)
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter X-Client-Name: %s", err))
		}

		params.XClientName = &XClientName
	}
	// ------------- Optional header parameter "X-Client-Version" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Client-Version")]; found {
		var XClientVersion string
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for X-Client-Version, got %d", n))
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "X-Client-Version", runtime.ParamLocationHeader, valueList[0], &XClientVersion)
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter X-Client-Version: %s", err))
		}

		params.XClientVersion = &XClientVersion
	}
	// ------------- Optional header parameter "X-Access-Key" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Access-Key")]; found {
		var XAccessKey string
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for X-Access-Key, got %d", n))
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "X-Access-Key", runtime.ParamLocationHeader, valueList[0], &XAccessKey)
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter X-Access-Key: %s", err))
		}

		params.XAccessKey = &XAccessKey
	}
	// ------------- Optional header parameter "X-Device-ID" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Device-ID")]; found {
		var XDeviceID string
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for X-Device-ID, got %d", n))
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "X-Device-ID", runtime.ParamLocationHeader, valueList[0], &XDeviceID)
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter X-Device-ID: %s", err))
		}

		params.XDeviceID = &XDeviceID
	}
	// ------------- Required header parameter "X-License-Key" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-License-Key")]; found {
		var XLicenseKey string
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for X-License-Key, got %d", n))
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "X-License-Key", runtime.ParamLocationHeader, valueList[0], &XLicenseKey)
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter X-License-Key: %s", err))
		}

		params.XLicenseKey = XLicenseKey
	} else {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Header parameter X-License-Key is required, but not found"))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AskOfflineCodesApiV1CashRegistersAskOfflineCodesGet(ctx, params)
	return err
}

// GetOfflineCodesApiV1CashRegistersGetOfflineCodesGet converts echo context to params.
func (w *ServerInterfaceWrapper) GetOfflineCodesApiV1CashRegistersGetOfflineCodesGet(ctx echo.Context) error {
	var err error

	ctx.Set(CashierJWTtokenScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetOfflineCodesApiV1CashRegistersGetOfflineCodesGetParams
	// ------------- Optional query parameter "count" -------------

	err = runtime.BindQueryParameter("form", true, false, "count", ctx.QueryParams(), &params.Count)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter count: %s", err))
	}

	headers := ctx.Request().Header
	// ------------- Optional header parameter "X-Client-Name" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Client-Name")]; found {
		var XClientName string
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for X-Client-Name, got %d", n))
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "X-Client-Name", runtime.ParamLocationHeader, valueList[0], &XClientName)
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter X-Client-Name: %s", err))
		}

		params.XClientName = &XClientName
	}
	// ------------- Optional header parameter "X-Client-Version" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Client-Version")]; found {
		var XClientVersion string
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for X-Client-Version, got %d", n))
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "X-Client-Version", runtime.ParamLocationHeader, valueList[0], &XClientVersion)
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter X-Client-Version: %s", err))
		}

		params.XClientVersion = &XClientVersion
	}
	// ------------- Optional header parameter "X-Access-Key" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Access-Key")]; found {
		var XAccessKey string
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for X-Access-Key, got %d", n))
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "X-Access-Key", runtime.ParamLocationHeader, valueList[0], &XAccessKey)
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter X-Access-Key: %s", err))
		}

		params.XAccessKey = &XAccessKey
	}
	// ------------- Optional header parameter "X-License-Key" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-License-Key")]; found {
		var XLicenseKey string
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for X-License-Key, got %d", n))
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "X-License-Key", runtime.ParamLocationHeader, valueList[0], &XLicenseKey)
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter X-License-Key: %s", err))
		}

		params.XLicenseKey = &XLicenseKey
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetOfflineCodesApiV1CashRegistersGetOfflineCodesGet(ctx, params)
	return err
}

// GetOfflineCodesCountApiV1CashRegistersGetOfflineCodesCountGet converts echo context to params.
func (w *ServerInterfaceWrapper) GetOfflineCodesCountApiV1CashRegistersGetOfflineCodesCountGet(ctx echo.Context) error {
	var err error

	ctx.Set(CashierJWTtokenScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetOfflineCodesCountApiV1CashRegistersGetOfflineCodesCountGetParams

	headers := ctx.Request().Header
	// ------------- Optional header parameter "X-Client-Name" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Client-Name")]; found {
		var XClientName string
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for X-Client-Name, got %d", n))
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "X-Client-Name", runtime.ParamLocationHeader, valueList[0], &XClientName)
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter X-Client-Name: %s", err))
		}

		params.XClientName = &XClientName
	}
	// ------------- Optional header parameter "X-Client-Version" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Client-Version")]; found {
		var XClientVersion string
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for X-Client-Version, got %d", n))
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "X-Client-Version", runtime.ParamLocationHeader, valueList[0], &XClientVersion)
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter X-Client-Version: %s", err))
		}

		params.XClientVersion = &XClientVersion
	}
	// ------------- Optional header parameter "X-Access-Key" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Access-Key")]; found {
		var XAccessKey string
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for X-Access-Key, got %d", n))
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "X-Access-Key", runtime.ParamLocationHeader, valueList[0], &XAccessKey)
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter X-Access-Key: %s", err))
		}

		params.XAccessKey = &XAccessKey
	}
	// ------------- Required header parameter "X-License-Key" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-License-Key")]; found {
		var XLicenseKey string
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for X-License-Key, got %d", n))
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "X-License-Key", runtime.ParamLocationHeader, valueList[0], &XLicenseKey)
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter X-License-Key: %s", err))
		}

		params.XLicenseKey = XLicenseKey
	} else {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Header parameter X-License-Key is required, but not found"))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetOfflineCodesCountApiV1CashRegistersGetOfflineCodesCountGet(ctx, params)
	return err
}

// GetOfflineTimeApiV1CashRegistersGetOfflineTimeGet converts echo context to params.
func (w *ServerInterfaceWrapper) GetOfflineTimeApiV1CashRegistersGetOfflineTimeGet(ctx echo.Context) error {
	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params GetOfflineTimeApiV1CashRegistersGetOfflineTimeGetParams
	// ------------- Optional query parameter "from_date" -------------

	err = runtime.BindQueryParameter("form", true, false, "from_date", ctx.QueryParams(), &params.FromDate)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter from_date: %s", err))
	}

	// ------------- Optional query parameter "to_date" -------------

	err = runtime.BindQueryParameter("form", true, false, "to_date", ctx.QueryParams(), &params.ToDate)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter to_date: %s", err))
	}

	headers := ctx.Request().Header
	// ------------- Optional header parameter "X-Client-Name" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Client-Name")]; found {
		var XClientName string
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for X-Client-Name, got %d", n))
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "X-Client-Name", runtime.ParamLocationHeader, valueList[0], &XClientName)
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter X-Client-Name: %s", err))
		}

		params.XClientName = &XClientName
	}
	// ------------- Optional header parameter "X-Client-Version" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Client-Version")]; found {
		var XClientVersion string
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for X-Client-Version, got %d", n))
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "X-Client-Version", runtime.ParamLocationHeader, valueList[0], &XClientVersion)
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter X-Client-Version: %s", err))
		}

		params.XClientVersion = &XClientVersion
	}
	// ------------- Optional header parameter "X-Access-Key" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Access-Key")]; found {
		var XAccessKey string
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for X-Access-Key, got %d", n))
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "X-Access-Key", runtime.ParamLocationHeader, valueList[0], &XAccessKey)
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter X-Access-Key: %s", err))
		}

		params.XAccessKey = &XAccessKey
	}
	// ------------- Required header parameter "X-License-Key" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-License-Key")]; found {
		var XLicenseKey string
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for X-License-Key, got %d", n))
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "X-License-Key", runtime.ParamLocationHeader, valueList[0], &XLicenseKey)
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter X-License-Key: %s", err))
		}

		params.XLicenseKey = XLicenseKey
	} else {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Header parameter X-License-Key is required, but not found"))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetOfflineTimeApiV1CashRegistersGetOfflineTimeGet(ctx, params)
	return err
}

// GoOfflineActionApiV1CashRegistersGoOfflinePost converts echo context to params.
func (w *ServerInterfaceWrapper) GoOfflineActionApiV1CashRegistersGoOfflinePost(ctx echo.Context) error {
	var err error

	ctx.Set(CashierJWTtokenScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GoOfflineActionApiV1CashRegistersGoOfflinePostParams

	headers := ctx.Request().Header
	// ------------- Optional header parameter "X-Client-Name" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Client-Name")]; found {
		var XClientName string
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for X-Client-Name, got %d", n))
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "X-Client-Name", runtime.ParamLocationHeader, valueList[0], &XClientName)
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter X-Client-Name: %s", err))
		}

		params.XClientName = &XClientName
	}
	// ------------- Optional header parameter "X-Client-Version" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Client-Version")]; found {
		var XClientVersion string
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for X-Client-Version, got %d", n))
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "X-Client-Version", runtime.ParamLocationHeader, valueList[0], &XClientVersion)
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter X-Client-Version: %s", err))
		}

		params.XClientVersion = &XClientVersion
	}
	// ------------- Optional header parameter "X-Access-Key" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Access-Key")]; found {
		var XAccessKey string
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for X-Access-Key, got %d", n))
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "X-Access-Key", runtime.ParamLocationHeader, valueList[0], &XAccessKey)
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter X-Access-Key: %s", err))
		}

		params.XAccessKey = &XAccessKey
	}
	// ------------- Optional header parameter "X-Device-ID" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Device-ID")]; found {
		var XDeviceID string
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for X-Device-ID, got %d", n))
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "X-Device-ID", runtime.ParamLocationHeader, valueList[0], &XDeviceID)
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter X-Device-ID: %s", err))
		}

		params.XDeviceID = &XDeviceID
	}
	// ------------- Optional header parameter "X-License-Key" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-License-Key")]; found {
		var XLicenseKey string
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for X-License-Key, got %d", n))
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "X-License-Key", runtime.ParamLocationHeader, valueList[0], &XLicenseKey)
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter X-License-Key: %s", err))
		}

		params.XLicenseKey = &XLicenseKey
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GoOfflineActionApiV1CashRegistersGoOfflinePost(ctx, params)
	return err
}

// GoOnlineActionApiV1CashRegistersGoOnlinePost converts echo context to params.
func (w *ServerInterfaceWrapper) GoOnlineActionApiV1CashRegistersGoOnlinePost(ctx echo.Context) error {
	var err error

	ctx.Set(CashierJWTtokenScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GoOnlineActionApiV1CashRegistersGoOnlinePostParams

	headers := ctx.Request().Header
	// ------------- Optional header parameter "X-Client-Name" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Client-Name")]; found {
		var XClientName string
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for X-Client-Name, got %d", n))
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "X-Client-Name", runtime.ParamLocationHeader, valueList[0], &XClientName)
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter X-Client-Name: %s", err))
		}

		params.XClientName = &XClientName
	}
	// ------------- Optional header parameter "X-Client-Version" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Client-Version")]; found {
		var XClientVersion string
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for X-Client-Version, got %d", n))
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "X-Client-Version", runtime.ParamLocationHeader, valueList[0], &XClientVersion)
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter X-Client-Version: %s", err))
		}

		params.XClientVersion = &XClientVersion
	}
	// ------------- Optional header parameter "X-Access-Key" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Access-Key")]; found {
		var XAccessKey string
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for X-Access-Key, got %d", n))
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "X-Access-Key", runtime.ParamLocationHeader, valueList[0], &XAccessKey)
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter X-Access-Key: %s", err))
		}

		params.XAccessKey = &XAccessKey
	}
	// ------------- Optional header parameter "X-Device-ID" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Device-ID")]; found {
		var XDeviceID string
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for X-Device-ID, got %d", n))
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "X-Device-ID", runtime.ParamLocationHeader, valueList[0], &XDeviceID)
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter X-Device-ID: %s", err))
		}

		params.XDeviceID = &XDeviceID
	}
	// ------------- Optional header parameter "X-License-Key" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-License-Key")]; found {
		var XLicenseKey string
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for X-License-Key, got %d", n))
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "X-License-Key", runtime.ParamLocationHeader, valueList[0], &XLicenseKey)
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter X-License-Key: %s", err))
		}

		params.XLicenseKey = &XLicenseKey
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GoOnlineActionApiV1CashRegistersGoOnlinePost(ctx, params)
	return err
}

// GetCashRegisterInfoApiV1CashRegistersInfoGet converts echo context to params.
func (w *ServerInterfaceWrapper) GetCashRegisterInfoApiV1CashRegistersInfoGet(ctx echo.Context) error {
	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params GetCashRegisterInfoApiV1CashRegistersInfoGetParams

	headers := ctx.Request().Header
	// ------------- Optional header parameter "X-Client-Name" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Client-Name")]; found {
		var XClientName string
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for X-Client-Name, got %d", n))
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "X-Client-Name", runtime.ParamLocationHeader, valueList[0], &XClientName)
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter X-Client-Name: %s", err))
		}

		params.XClientName = &XClientName
	}
	// ------------- Optional header parameter "X-Client-Version" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Client-Version")]; found {
		var XClientVersion string
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for X-Client-Version, got %d", n))
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "X-Client-Version", runtime.ParamLocationHeader, valueList[0], &XClientVersion)
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter X-Client-Version: %s", err))
		}

		params.XClientVersion = &XClientVersion
	}
	// ------------- Optional header parameter "X-Access-Key" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Access-Key")]; found {
		var XAccessKey string
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for X-Access-Key, got %d", n))
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "X-Access-Key", runtime.ParamLocationHeader, valueList[0], &XAccessKey)
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter X-Access-Key: %s", err))
		}

		params.XAccessKey = &XAccessKey
	}
	// ------------- Required header parameter "X-License-Key" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-License-Key")]; found {
		var XLicenseKey string
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for X-License-Key, got %d", n))
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "X-License-Key", runtime.ParamLocationHeader, valueList[0], &XLicenseKey)
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter X-License-Key: %s", err))
		}

		params.XLicenseKey = XLicenseKey
	} else {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Header parameter X-License-Key is required, but not found"))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetCashRegisterInfoApiV1CashRegistersInfoGet(ctx, params)
	return err
}

// PingTaxServiceActionApiV1CashRegistersPingTaxServicePost converts echo context to params.
func (w *ServerInterfaceWrapper) PingTaxServiceActionApiV1CashRegistersPingTaxServicePost(ctx echo.Context) error {
	var err error

	ctx.Set(CashierJWTtokenScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params PingTaxServiceActionApiV1CashRegistersPingTaxServicePostParams

	headers := ctx.Request().Header
	// ------------- Optional header parameter "X-Client-Name" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Client-Name")]; found {
		var XClientName string
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for X-Client-Name, got %d", n))
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "X-Client-Name", runtime.ParamLocationHeader, valueList[0], &XClientName)
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter X-Client-Name: %s", err))
		}

		params.XClientName = &XClientName
	}
	// ------------- Optional header parameter "X-Client-Version" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Client-Version")]; found {
		var XClientVersion string
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for X-Client-Version, got %d", n))
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "X-Client-Version", runtime.ParamLocationHeader, valueList[0], &XClientVersion)
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter X-Client-Version: %s", err))
		}

		params.XClientVersion = &XClientVersion
	}
	// ------------- Optional header parameter "X-Access-Key" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Access-Key")]; found {
		var XAccessKey string
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for X-Access-Key, got %d", n))
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "X-Access-Key", runtime.ParamLocationHeader, valueList[0], &XAccessKey)
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter X-Access-Key: %s", err))
		}

		params.XAccessKey = &XAccessKey
	}
	// ------------- Required header parameter "X-License-Key" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-License-Key")]; found {
		var XLicenseKey string
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for X-License-Key, got %d", n))
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "X-License-Key", runtime.ParamLocationHeader, valueList[0], &XLicenseKey)
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter X-License-Key: %s", err))
		}

		params.XLicenseKey = XLicenseKey
	} else {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Header parameter X-License-Key is required, but not found"))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.PingTaxServiceActionApiV1CashRegistersPingTaxServicePost(ctx, params)
	return err
}

// GetCashRegisterApiV1CashRegistersCashRegisterIdGet converts echo context to params.
func (w *ServerInterfaceWrapper) GetCashRegisterApiV1CashRegistersCashRegisterIdGet(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "cash_register_id" -------------
	var cashRegisterId openapi_types.UUID

	err = runtime.BindStyledParameterWithLocation("simple", false, "cash_register_id", runtime.ParamLocationPath, ctx.Param("cash_register_id"), &cashRegisterId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter cash_register_id: %s", err))
	}

	ctx.Set(CashierJWTtokenScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetCashRegisterApiV1CashRegistersCashRegisterIdGetParams

	headers := ctx.Request().Header
	// ------------- Optional header parameter "X-Client-Name" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Client-Name")]; found {
		var XClientName string
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for X-Client-Name, got %d", n))
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "X-Client-Name", runtime.ParamLocationHeader, valueList[0], &XClientName)
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter X-Client-Name: %s", err))
		}

		params.XClientName = &XClientName
	}
	// ------------- Optional header parameter "X-Client-Version" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Client-Version")]; found {
		var XClientVersion string
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for X-Client-Version, got %d", n))
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "X-Client-Version", runtime.ParamLocationHeader, valueList[0], &XClientVersion)
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter X-Client-Version: %s", err))
		}

		params.XClientVersion = &XClientVersion
	}
	// ------------- Optional header parameter "X-Access-Key" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Access-Key")]; found {
		var XAccessKey string
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for X-Access-Key, got %d", n))
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "X-Access-Key", runtime.ParamLocationHeader, valueList[0], &XAccessKey)
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter X-Access-Key: %s", err))
		}

		params.XAccessKey = &XAccessKey
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetCashRegisterApiV1CashRegistersCashRegisterIdGet(ctx, cashRegisterId, params)
	return err
}

// CheckSignatureApiV1CashierCheckSignatureGet converts echo context to params.
func (w *ServerInterfaceWrapper) CheckSignatureApiV1CashierCheckSignatureGet(ctx echo.Context) error {
	var err error

	ctx.Set(CashierJWTtokenScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params CheckSignatureApiV1CashierCheckSignatureGetParams

	headers := ctx.Request().Header
	// ------------- Optional header parameter "X-Client-Name" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Client-Name")]; found {
		var XClientName string
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for X-Client-Name, got %d", n))
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "X-Client-Name", runtime.ParamLocationHeader, valueList[0], &XClientName)
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter X-Client-Name: %s", err))
		}

		params.XClientName = &XClientName
	}
	// ------------- Optional header parameter "X-Client-Version" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Client-Version")]; found {
		var XClientVersion string
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for X-Client-Version, got %d", n))
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "X-Client-Version", runtime.ParamLocationHeader, valueList[0], &XClientVersion)
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter X-Client-Version: %s", err))
		}

		params.XClientVersion = &XClientVersion
	}
	// ------------- Optional header parameter "X-Access-Key" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Access-Key")]; found {
		var XAccessKey string
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for X-Access-Key, got %d", n))
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "X-Access-Key", runtime.ParamLocationHeader, valueList[0], &XAccessKey)
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter X-Access-Key: %s", err))
		}

		params.XAccessKey = &XAccessKey
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.CheckSignatureApiV1CashierCheckSignatureGet(ctx, params)
	return err
}

// GetCashierProfileApiV1CashierMeGet converts echo context to params.
func (w *ServerInterfaceWrapper) GetCashierProfileApiV1CashierMeGet(ctx echo.Context) error {
	var err error

	ctx.Set(CashierJWTtokenScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetCashierProfileApiV1CashierMeGetParams

	headers := ctx.Request().Header
	// ------------- Optional header parameter "X-Client-Name" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Client-Name")]; found {
		var XClientName string
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for X-Client-Name, got %d", n))
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "X-Client-Name", runtime.ParamLocationHeader, valueList[0], &XClientName)
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter X-Client-Name: %s", err))
		}

		params.XClientName = &XClientName
	}
	// ------------- Optional header parameter "X-Client-Version" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Client-Version")]; found {
		var XClientVersion string
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for X-Client-Version, got %d", n))
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "X-Client-Version", runtime.ParamLocationHeader, valueList[0], &XClientVersion)
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter X-Client-Version: %s", err))
		}

		params.XClientVersion = &XClientVersion
	}
	// ------------- Optional header parameter "X-Access-Key" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Access-Key")]; found {
		var XAccessKey string
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for X-Access-Key, got %d", n))
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "X-Access-Key", runtime.ParamLocationHeader, valueList[0], &XAccessKey)
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter X-Access-Key: %s", err))
		}

		params.XAccessKey = &XAccessKey
	}
	// ------------- Optional header parameter "X-Device-ID" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Device-ID")]; found {
		var XDeviceID string
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for X-Device-ID, got %d", n))
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "X-Device-ID", runtime.ParamLocationHeader, valueList[0], &XDeviceID)
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter X-Device-ID: %s", err))
		}

		params.XDeviceID = &XDeviceID
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetCashierProfileApiV1CashierMeGet(ctx, params)
	return err
}

// GetCashierShiftApiV1CashierShiftGet converts echo context to params.
func (w *ServerInterfaceWrapper) GetCashierShiftApiV1CashierShiftGet(ctx echo.Context) error {
	var err error

	ctx.Set(CashierJWTtokenScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetCashierShiftApiV1CashierShiftGetParams

	headers := ctx.Request().Header
	// ------------- Optional header parameter "X-Client-Name" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Client-Name")]; found {
		var XClientName string
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for X-Client-Name, got %d", n))
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "X-Client-Name", runtime.ParamLocationHeader, valueList[0], &XClientName)
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter X-Client-Name: %s", err))
		}

		params.XClientName = &XClientName
	}
	// ------------- Optional header parameter "X-Client-Version" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Client-Version")]; found {
		var XClientVersion string
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for X-Client-Version, got %d", n))
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "X-Client-Version", runtime.ParamLocationHeader, valueList[0], &XClientVersion)
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter X-Client-Version: %s", err))
		}

		params.XClientVersion = &XClientVersion
	}
	// ------------- Optional header parameter "X-Access-Key" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Access-Key")]; found {
		var XAccessKey string
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for X-Access-Key, got %d", n))
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "X-Access-Key", runtime.ParamLocationHeader, valueList[0], &XAccessKey)
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter X-Access-Key: %s", err))
		}

		params.XAccessKey = &XAccessKey
	}
	// ------------- Optional header parameter "X-Device-ID" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Device-ID")]; found {
		var XDeviceID string
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for X-Device-ID, got %d", n))
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "X-Device-ID", runtime.ParamLocationHeader, valueList[0], &XDeviceID)
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter X-Device-ID: %s", err))
		}

		params.XDeviceID = &XDeviceID
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetCashierShiftApiV1CashierShiftGet(ctx, params)
	return err
}

// SignInCashierApiV1CashierSigninPost converts echo context to params.
func (w *ServerInterfaceWrapper) SignInCashierApiV1CashierSigninPost(ctx echo.Context) error {
	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params SignInCashierApiV1CashierSigninPostParams

	headers := ctx.Request().Header
	// ------------- Optional header parameter "X-Client-Name" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Client-Name")]; found {
		var XClientName string
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for X-Client-Name, got %d", n))
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "X-Client-Name", runtime.ParamLocationHeader, valueList[0], &XClientName)
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter X-Client-Name: %s", err))
		}

		params.XClientName = &XClientName
	}
	// ------------- Optional header parameter "X-Client-Version" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Client-Version")]; found {
		var XClientVersion string
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for X-Client-Version, got %d", n))
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "X-Client-Version", runtime.ParamLocationHeader, valueList[0], &XClientVersion)
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter X-Client-Version: %s", err))
		}

		params.XClientVersion = &XClientVersion
	}
	// ------------- Optional header parameter "X-Access-Key" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Access-Key")]; found {
		var XAccessKey string
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for X-Access-Key, got %d", n))
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "X-Access-Key", runtime.ParamLocationHeader, valueList[0], &XAccessKey)
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter X-Access-Key: %s", err))
		}

		params.XAccessKey = &XAccessKey
	}
	// ------------- Optional header parameter "X-Device-ID" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Device-ID")]; found {
		var XDeviceID string
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for X-Device-ID, got %d", n))
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "X-Device-ID", runtime.ParamLocationHeader, valueList[0], &XDeviceID)
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter X-Device-ID: %s", err))
		}

		params.XDeviceID = &XDeviceID
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SignInCashierApiV1CashierSigninPost(ctx, params)
	return err
}

// SignInCashierViaPinCodeApiV1CashierSigninPinCodePost converts echo context to params.
func (w *ServerInterfaceWrapper) SignInCashierViaPinCodeApiV1CashierSigninPinCodePost(ctx echo.Context) error {
	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params SignInCashierViaPinCodeApiV1CashierSigninPinCodePostParams

	headers := ctx.Request().Header
	// ------------- Optional header parameter "X-Client-Name" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Client-Name")]; found {
		var XClientName string
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for X-Client-Name, got %d", n))
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "X-Client-Name", runtime.ParamLocationHeader, valueList[0], &XClientName)
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter X-Client-Name: %s", err))
		}

		params.XClientName = &XClientName
	}
	// ------------- Optional header parameter "X-Client-Version" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Client-Version")]; found {
		var XClientVersion string
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for X-Client-Version, got %d", n))
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "X-Client-Version", runtime.ParamLocationHeader, valueList[0], &XClientVersion)
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter X-Client-Version: %s", err))
		}

		params.XClientVersion = &XClientVersion
	}
	// ------------- Optional header parameter "X-Access-Key" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Access-Key")]; found {
		var XAccessKey string
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for X-Access-Key, got %d", n))
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "X-Access-Key", runtime.ParamLocationHeader, valueList[0], &XAccessKey)
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter X-Access-Key: %s", err))
		}

		params.XAccessKey = &XAccessKey
	}
	// ------------- Required header parameter "X-License-Key" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-License-Key")]; found {
		var XLicenseKey string
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for X-License-Key, got %d", n))
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "X-License-Key", runtime.ParamLocationHeader, valueList[0], &XLicenseKey)
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter X-License-Key: %s", err))
		}

		params.XLicenseKey = XLicenseKey
	} else {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Header parameter X-License-Key is required, but not found"))
	}
	// ------------- Optional header parameter "X-Device-ID" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Device-ID")]; found {
		var XDeviceID string
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for X-Device-ID, got %d", n))
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "X-Device-ID", runtime.ParamLocationHeader, valueList[0], &XDeviceID)
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter X-Device-ID: %s", err))
		}

		params.XDeviceID = &XDeviceID
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SignInCashierViaPinCodeApiV1CashierSigninPinCodePost(ctx, params)
	return err
}

// SignOutCashierApiV1CashierSignoutPost converts echo context to params.
func (w *ServerInterfaceWrapper) SignOutCashierApiV1CashierSignoutPost(ctx echo.Context) error {
	var err error

	ctx.Set(CashierJWTtokenScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params SignOutCashierApiV1CashierSignoutPostParams

	headers := ctx.Request().Header
	// ------------- Optional header parameter "X-Client-Name" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Client-Name")]; found {
		var XClientName string
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for X-Client-Name, got %d", n))
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "X-Client-Name", runtime.ParamLocationHeader, valueList[0], &XClientName)
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter X-Client-Name: %s", err))
		}

		params.XClientName = &XClientName
	}
	// ------------- Optional header parameter "X-Client-Version" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Client-Version")]; found {
		var XClientVersion string
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for X-Client-Version, got %d", n))
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "X-Client-Version", runtime.ParamLocationHeader, valueList[0], &XClientVersion)
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter X-Client-Version: %s", err))
		}

		params.XClientVersion = &XClientVersion
	}
	// ------------- Optional header parameter "X-Access-Key" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Access-Key")]; found {
		var XAccessKey string
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for X-Access-Key, got %d", n))
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "X-Access-Key", runtime.ParamLocationHeader, valueList[0], &XAccessKey)
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter X-Access-Key: %s", err))
		}

		params.XAccessKey = &XAccessKey
	}
	// ------------- Optional header parameter "X-Device-ID" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Device-ID")]; found {
		var XDeviceID string
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for X-Device-ID, got %d", n))
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "X-Device-ID", runtime.ParamLocationHeader, valueList[0], &XDeviceID)
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter X-Device-ID: %s", err))
		}

		params.XDeviceID = &XDeviceID
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SignOutCashierApiV1CashierSignoutPost(ctx, params)
	return err
}

// GetCurrencyRatesApiV1CurrencyRateGet converts echo context to params.
func (w *ServerInterfaceWrapper) GetCurrencyRatesApiV1CurrencyRateGet(ctx echo.Context) error {
	var err error

	ctx.Set(CashierJWTtokenScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetCurrencyRatesApiV1CurrencyRateGetParams
	// ------------- Optional query parameter "active" -------------

	err = runtime.BindQueryParameter("form", true, false, "active", ctx.QueryParams(), &params.Active)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter active: %s", err))
	}

	headers := ctx.Request().Header
	// ------------- Optional header parameter "X-Client-Name" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Client-Name")]; found {
		var XClientName string
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for X-Client-Name, got %d", n))
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "X-Client-Name", runtime.ParamLocationHeader, valueList[0], &XClientName)
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter X-Client-Name: %s", err))
		}

		params.XClientName = &XClientName
	}
	// ------------- Optional header parameter "X-Client-Version" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Client-Version")]; found {
		var XClientVersion string
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for X-Client-Version, got %d", n))
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "X-Client-Version", runtime.ParamLocationHeader, valueList[0], &XClientVersion)
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter X-Client-Version: %s", err))
		}

		params.XClientVersion = &XClientVersion
	}
	// ------------- Optional header parameter "X-Access-Key" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Access-Key")]; found {
		var XAccessKey string
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for X-Access-Key, got %d", n))
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "X-Access-Key", runtime.ParamLocationHeader, valueList[0], &XAccessKey)
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter X-Access-Key: %s", err))
		}

		params.XAccessKey = &XAccessKey
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetCurrencyRatesApiV1CurrencyRateGet(ctx, params)
	return err
}

// SetupCurrencyRatesApiV1CurrencyRateSetupPost converts echo context to params.
func (w *ServerInterfaceWrapper) SetupCurrencyRatesApiV1CurrencyRateSetupPost(ctx echo.Context) error {
	var err error

	ctx.Set(CashierJWTtokenScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params SetupCurrencyRatesApiV1CurrencyRateSetupPostParams

	headers := ctx.Request().Header
	// ------------- Optional header parameter "X-Client-Name" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Client-Name")]; found {
		var XClientName string
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for X-Client-Name, got %d", n))
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "X-Client-Name", runtime.ParamLocationHeader, valueList[0], &XClientName)
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter X-Client-Name: %s", err))
		}

		params.XClientName = &XClientName
	}
	// ------------- Optional header parameter "X-Client-Version" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Client-Version")]; found {
		var XClientVersion string
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for X-Client-Version, got %d", n))
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "X-Client-Version", runtime.ParamLocationHeader, valueList[0], &XClientVersion)
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter X-Client-Version: %s", err))
		}

		params.XClientVersion = &XClientVersion
	}
	// ------------- Optional header parameter "X-Access-Key" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Access-Key")]; found {
		var XAccessKey string
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for X-Access-Key, got %d", n))
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "X-Access-Key", runtime.ParamLocationHeader, valueList[0], &XAccessKey)
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter X-Access-Key: %s", err))
		}

		params.XAccessKey = &XAccessKey
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SetupCurrencyRatesApiV1CurrencyRateSetupPost(ctx, params)
	return err
}

// GetCurrencyRateApiV1CurrencyRateCurrencyCodeGet converts echo context to params.
func (w *ServerInterfaceWrapper) GetCurrencyRateApiV1CurrencyRateCurrencyCodeGet(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "currency_code" -------------
	var currencyCode string

	err = runtime.BindStyledParameterWithLocation("simple", false, "currency_code", runtime.ParamLocationPath, ctx.Param("currency_code"), &currencyCode)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency_code: %s", err))
	}

	ctx.Set(CashierJWTtokenScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetCurrencyRateApiV1CurrencyRateCurrencyCodeGetParams

	headers := ctx.Request().Header
	// ------------- Optional header parameter "X-Client-Name" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Client-Name")]; found {
		var XClientName string
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for X-Client-Name, got %d", n))
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "X-Client-Name", runtime.ParamLocationHeader, valueList[0], &XClientName)
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter X-Client-Name: %s", err))
		}

		params.XClientName = &XClientName
	}
	// ------------- Optional header parameter "X-Client-Version" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Client-Version")]; found {
		var XClientVersion string
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for X-Client-Version, got %d", n))
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "X-Client-Version", runtime.ParamLocationHeader, valueList[0], &XClientVersion)
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter X-Client-Version: %s", err))
		}

		params.XClientVersion = &XClientVersion
	}
	// ------------- Optional header parameter "X-Access-Key" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Access-Key")]; found {
		var XAccessKey string
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for X-Access-Key, got %d", n))
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "X-Access-Key", runtime.ParamLocationHeader, valueList[0], &XAccessKey)
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter X-Access-Key: %s", err))
		}

		params.XAccessKey = &XAccessKey
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetCurrencyRateApiV1CurrencyRateCurrencyCodeGet(ctx, currencyCode, params)
	return err
}

// GoodsReportApiV1ExtendedReportsGoodsPost converts echo context to params.
func (w *ServerInterfaceWrapper) GoodsReportApiV1ExtendedReportsGoodsPost(ctx echo.Context) error {
	var err error

	ctx.Set(CashierJWTtokenScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GoodsReportApiV1ExtendedReportsGoodsPostParams

	headers := ctx.Request().Header
	// ------------- Optional header parameter "X-Client-Name" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Client-Name")]; found {
		var XClientName string
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for X-Client-Name, got %d", n))
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "X-Client-Name", runtime.ParamLocationHeader, valueList[0], &XClientName)
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter X-Client-Name: %s", err))
		}

		params.XClientName = &XClientName
	}
	// ------------- Optional header parameter "X-Client-Version" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Client-Version")]; found {
		var XClientVersion string
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for X-Client-Version, got %d", n))
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "X-Client-Version", runtime.ParamLocationHeader, valueList[0], &XClientVersion)
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter X-Client-Version: %s", err))
		}

		params.XClientVersion = &XClientVersion
	}
	// ------------- Optional header parameter "X-Access-Key" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Access-Key")]; found {
		var XAccessKey string
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for X-Access-Key, got %d", n))
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "X-Access-Key", runtime.ParamLocationHeader, valueList[0], &XAccessKey)
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter X-Access-Key: %s", err))
		}

		params.XAccessKey = &XAccessKey
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GoodsReportApiV1ExtendedReportsGoodsPost(ctx, params)
	return err
}

// GetReportTaskByIdApiV1ExtendedReportsReportTaskIdGet converts echo context to params.
func (w *ServerInterfaceWrapper) GetReportTaskByIdApiV1ExtendedReportsReportTaskIdGet(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "report_task_id" -------------
	var reportTaskId openapi_types.UUID

	err = runtime.BindStyledParameterWithLocation("simple", false, "report_task_id", runtime.ParamLocationPath, ctx.Param("report_task_id"), &reportTaskId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter report_task_id: %s", err))
	}

	ctx.Set(CashierJWTtokenScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetReportTaskByIdApiV1ExtendedReportsReportTaskIdGetParams

	headers := ctx.Request().Header
	// ------------- Optional header parameter "X-Client-Name" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Client-Name")]; found {
		var XClientName string
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for X-Client-Name, got %d", n))
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "X-Client-Name", runtime.ParamLocationHeader, valueList[0], &XClientName)
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter X-Client-Name: %s", err))
		}

		params.XClientName = &XClientName
	}
	// ------------- Optional header parameter "X-Client-Version" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Client-Version")]; found {
		var XClientVersion string
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for X-Client-Version, got %d", n))
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "X-Client-Version", runtime.ParamLocationHeader, valueList[0], &XClientVersion)
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter X-Client-Version: %s", err))
		}

		params.XClientVersion = &XClientVersion
	}
	// ------------- Optional header parameter "X-Access-Key" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Access-Key")]; found {
		var XAccessKey string
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for X-Access-Key, got %d", n))
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "X-Access-Key", runtime.ParamLocationHeader, valueList[0], &XAccessKey)
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter X-Access-Key: %s", err))
		}

		params.XAccessKey = &XAccessKey
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetReportTaskByIdApiV1ExtendedReportsReportTaskIdGet(ctx, reportTaskId, params)
	return err
}

// GetReportXlsxByIdApiV1ExtendedReportsReportTaskIdReportXlsxGet converts echo context to params.
func (w *ServerInterfaceWrapper) GetReportXlsxByIdApiV1ExtendedReportsReportTaskIdReportXlsxGet(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "report_task_id" -------------
	var reportTaskId openapi_types.UUID

	err = runtime.BindStyledParameterWithLocation("simple", false, "report_task_id", runtime.ParamLocationPath, ctx.Param("report_task_id"), &reportTaskId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter report_task_id: %s", err))
	}

	ctx.Set(CashierJWTtokenScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetReportXlsxByIdApiV1ExtendedReportsReportTaskIdReportXlsxGetParams

	headers := ctx.Request().Header
	// ------------- Optional header parameter "X-Client-Name" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Client-Name")]; found {
		var XClientName string
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for X-Client-Name, got %d", n))
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "X-Client-Name", runtime.ParamLocationHeader, valueList[0], &XClientName)
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter X-Client-Name: %s", err))
		}

		params.XClientName = &XClientName
	}
	// ------------- Optional header parameter "X-Client-Version" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Client-Version")]; found {
		var XClientVersion string
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for X-Client-Version, got %d", n))
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "X-Client-Version", runtime.ParamLocationHeader, valueList[0], &XClientVersion)
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter X-Client-Version: %s", err))
		}

		params.XClientVersion = &XClientVersion
	}
	// ------------- Optional header parameter "X-Access-Key" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Access-Key")]; found {
		var XAccessKey string
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for X-Access-Key, got %d", n))
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "X-Access-Key", runtime.ParamLocationHeader, valueList[0], &XAccessKey)
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter X-Access-Key: %s", err))
		}

		params.XAccessKey = &XAccessKey
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetReportXlsxByIdApiV1ExtendedReportsReportTaskIdReportXlsxGet(ctx, reportTaskId, params)
	return err
}

// GetGoodsApiV1GoodsGet converts echo context to params.
func (w *ServerInterfaceWrapper) GetGoodsApiV1GoodsGet(ctx echo.Context) error {
	var err error

	ctx.Set(CashierJWTtokenScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetGoodsApiV1GoodsGetParams
	// ------------- Optional query parameter "name" -------------

	err = runtime.BindQueryParameter("form", true, false, "name", ctx.QueryParams(), &params.Name)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter name: %s", err))
	}

	// ------------- Optional query parameter "barcode" -------------

	err = runtime.BindQueryParameter("form", true, false, "barcode", ctx.QueryParams(), &params.Barcode)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter barcode: %s", err))
	}

	// ------------- Optional query parameter "query" -------------

	err = runtime.BindQueryParameter("form", true, false, "query", ctx.QueryParams(), &params.Query)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter query: %s", err))
	}

	// ------------- Optional query parameter "order_by_name" -------------

	err = runtime.BindQueryParameter("form", true, false, "order_by_name", ctx.QueryParams(), &params.OrderByName)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter order_by_name: %s", err))
	}

	// ------------- Optional query parameter "order_by_code" -------------

	err = runtime.BindQueryParameter("form", true, false, "order_by_code", ctx.QueryParams(), &params.OrderByCode)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter order_by_code: %s", err))
	}

	// ------------- Optional query parameter "order_by_position" -------------

	err = runtime.BindQueryParameter("form", true, false, "order_by_position", ctx.QueryParams(), &params.OrderByPosition)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter order_by_position: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "offset" -------------

	err = runtime.BindQueryParameter("form", true, false, "offset", ctx.QueryParams(), &params.Offset)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter offset: %s", err))
	}

	headers := ctx.Request().Header
	// ------------- Optional header parameter "X-Client-Name" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Client-Name")]; found {
		var XClientName string
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for X-Client-Name, got %d", n))
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "X-Client-Name", runtime.ParamLocationHeader, valueList[0], &XClientName)
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter X-Client-Name: %s", err))
		}

		params.XClientName = &XClientName
	}
	// ------------- Optional header parameter "X-Client-Version" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Client-Version")]; found {
		var XClientVersion string
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for X-Client-Version, got %d", n))
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "X-Client-Version", runtime.ParamLocationHeader, valueList[0], &XClientVersion)
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter X-Client-Version: %s", err))
		}

		params.XClientVersion = &XClientVersion
	}
	// ------------- Optional header parameter "X-Access-Key" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Access-Key")]; found {
		var XAccessKey string
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for X-Access-Key, got %d", n))
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "X-Access-Key", runtime.ParamLocationHeader, valueList[0], &XAccessKey)
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter X-Access-Key: %s", err))
		}

		params.XAccessKey = &XAccessKey
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetGoodsApiV1GoodsGet(ctx, params)
	return err
}

// ExportGoodsFileApiV1GoodsExportFileTaskIdGet converts echo context to params.
func (w *ServerInterfaceWrapper) ExportGoodsFileApiV1GoodsExportFileTaskIdGet(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "task_id" -------------
	var taskId openapi_types.UUID

	err = runtime.BindStyledParameterWithLocation("simple", false, "task_id", runtime.ParamLocationPath, ctx.Param("task_id"), &taskId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter task_id: %s", err))
	}

	ctx.Set(CashierJWTtokenScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params ExportGoodsFileApiV1GoodsExportFileTaskIdGetParams
	// ------------- Optional query parameter "chunk_number" -------------

	err = runtime.BindQueryParameter("form", true, false, "chunk_number", ctx.QueryParams(), &params.ChunkNumber)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter chunk_number: %s", err))
	}

	headers := ctx.Request().Header
	// ------------- Optional header parameter "X-Client-Name" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Client-Name")]; found {
		var XClientName string
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for X-Client-Name, got %d", n))
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "X-Client-Name", runtime.ParamLocationHeader, valueList[0], &XClientName)
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter X-Client-Name: %s", err))
		}

		params.XClientName = &XClientName
	}
	// ------------- Optional header parameter "X-Client-Version" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Client-Version")]; found {
		var XClientVersion string
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for X-Client-Version, got %d", n))
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "X-Client-Version", runtime.ParamLocationHeader, valueList[0], &XClientVersion)
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter X-Client-Version: %s", err))
		}

		params.XClientVersion = &XClientVersion
	}
	// ------------- Optional header parameter "X-Access-Key" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Access-Key")]; found {
		var XAccessKey string
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for X-Access-Key, got %d", n))
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "X-Access-Key", runtime.ParamLocationHeader, valueList[0], &XAccessKey)
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter X-Access-Key: %s", err))
		}

		params.XAccessKey = &XAccessKey
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.ExportGoodsFileApiV1GoodsExportFileTaskIdGet(ctx, taskId, params)
	return err
}

// ExportGoodsTaskStatusApiV1GoodsExportTaskStatusTaskIdGet converts echo context to params.
func (w *ServerInterfaceWrapper) ExportGoodsTaskStatusApiV1GoodsExportTaskStatusTaskIdGet(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "task_id" -------------
	var taskId openapi_types.UUID

	err = runtime.BindStyledParameterWithLocation("simple", false, "task_id", runtime.ParamLocationPath, ctx.Param("task_id"), &taskId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter task_id: %s", err))
	}

	ctx.Set(CashierJWTtokenScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params ExportGoodsTaskStatusApiV1GoodsExportTaskStatusTaskIdGetParams

	headers := ctx.Request().Header
	// ------------- Optional header parameter "X-Client-Name" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Client-Name")]; found {
		var XClientName string
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for X-Client-Name, got %d", n))
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "X-Client-Name", runtime.ParamLocationHeader, valueList[0], &XClientName)
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter X-Client-Name: %s", err))
		}

		params.XClientName = &XClientName
	}
	// ------------- Optional header parameter "X-Client-Version" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Client-Version")]; found {
		var XClientVersion string
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for X-Client-Version, got %d", n))
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "X-Client-Version", runtime.ParamLocationHeader, valueList[0], &XClientVersion)
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter X-Client-Version: %s", err))
		}

		params.XClientVersion = &XClientVersion
	}
	// ------------- Optional header parameter "X-Access-Key" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Access-Key")]; found {
		var XAccessKey string
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for X-Access-Key, got %d", n))
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "X-Access-Key", runtime.ParamLocationHeader, valueList[0], &XAccessKey)
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter X-Access-Key: %s", err))
		}

		params.XAccessKey = &XAccessKey
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.ExportGoodsTaskStatusApiV1GoodsExportTaskStatusTaskIdGet(ctx, taskId, params)
	return err
}

// ExportGoodsApiV1GoodsExportExportExtensionGet converts echo context to params.
func (w *ServerInterfaceWrapper) ExportGoodsApiV1GoodsExportExportExtensionGet(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "export_extension" -------------
	var exportExtension ExportExtensionType

	err = runtime.BindStyledParameterWithLocation("simple", false, "export_extension", runtime.ParamLocationPath, ctx.Param("export_extension"), &exportExtension)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter export_extension: %s", err))
	}

	ctx.Set(CashierJWTtokenScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params ExportGoodsApiV1GoodsExportExportExtensionGetParams

	headers := ctx.Request().Header
	// ------------- Optional header parameter "X-Client-Name" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Client-Name")]; found {
		var XClientName string
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for X-Client-Name, got %d", n))
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "X-Client-Name", runtime.ParamLocationHeader, valueList[0], &XClientName)
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter X-Client-Name: %s", err))
		}

		params.XClientName = &XClientName
	}
	// ------------- Optional header parameter "X-Client-Version" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Client-Version")]; found {
		var XClientVersion string
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for X-Client-Version, got %d", n))
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "X-Client-Version", runtime.ParamLocationHeader, valueList[0], &XClientVersion)
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter X-Client-Version: %s", err))
		}

		params.XClientVersion = &XClientVersion
	}
	// ------------- Optional header parameter "X-Access-Key" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Access-Key")]; found {
		var XAccessKey string
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for X-Access-Key, got %d", n))
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "X-Access-Key", runtime.ParamLocationHeader, valueList[0], &XAccessKey)
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter X-Access-Key: %s", err))
		}

		params.XAccessKey = &XAccessKey
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.ExportGoodsApiV1GoodsExportExportExtensionGet(ctx, exportExtension, params)
	return err
}

// ImportGoodsApplyChangesApiV1GoodsImportApplyChangesTaskIdPost converts echo context to params.
func (w *ServerInterfaceWrapper) ImportGoodsApplyChangesApiV1GoodsImportApplyChangesTaskIdPost(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "task_id" -------------
	var taskId openapi_types.UUID

	err = runtime.BindStyledParameterWithLocation("simple", false, "task_id", runtime.ParamLocationPath, ctx.Param("task_id"), &taskId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter task_id: %s", err))
	}

	ctx.Set(CashierJWTtokenScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params ImportGoodsApplyChangesApiV1GoodsImportApplyChangesTaskIdPostParams

	headers := ctx.Request().Header
	// ------------- Optional header parameter "X-Client-Name" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Client-Name")]; found {
		var XClientName string
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for X-Client-Name, got %d", n))
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "X-Client-Name", runtime.ParamLocationHeader, valueList[0], &XClientName)
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter X-Client-Name: %s", err))
		}

		params.XClientName = &XClientName
	}
	// ------------- Optional header parameter "X-Client-Version" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Client-Version")]; found {
		var XClientVersion string
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for X-Client-Version, got %d", n))
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "X-Client-Version", runtime.ParamLocationHeader, valueList[0], &XClientVersion)
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter X-Client-Version: %s", err))
		}

		params.XClientVersion = &XClientVersion
	}
	// ------------- Optional header parameter "X-Access-Key" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Access-Key")]; found {
		var XAccessKey string
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for X-Access-Key, got %d", n))
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "X-Access-Key", runtime.ParamLocationHeader, valueList[0], &XAccessKey)
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter X-Access-Key: %s", err))
		}

		params.XAccessKey = &XAccessKey
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.ImportGoodsApplyChangesApiV1GoodsImportApplyChangesTaskIdPost(ctx, taskId, params)
	return err
}

// ImportGoodsTaskStatusApiV1GoodsImportTaskStatusTaskIdGet converts echo context to params.
func (w *ServerInterfaceWrapper) ImportGoodsTaskStatusApiV1GoodsImportTaskStatusTaskIdGet(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "task_id" -------------
	var taskId openapi_types.UUID

	err = runtime.BindStyledParameterWithLocation("simple", false, "task_id", runtime.ParamLocationPath, ctx.Param("task_id"), &taskId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter task_id: %s", err))
	}

	ctx.Set(CashierJWTtokenScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params ImportGoodsTaskStatusApiV1GoodsImportTaskStatusTaskIdGetParams

	headers := ctx.Request().Header
	// ------------- Optional header parameter "X-Client-Name" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Client-Name")]; found {
		var XClientName string
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for X-Client-Name, got %d", n))
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "X-Client-Name", runtime.ParamLocationHeader, valueList[0], &XClientName)
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter X-Client-Name: %s", err))
		}

		params.XClientName = &XClientName
	}
	// ------------- Optional header parameter "X-Client-Version" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Client-Version")]; found {
		var XClientVersion string
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for X-Client-Version, got %d", n))
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "X-Client-Version", runtime.ParamLocationHeader, valueList[0], &XClientVersion)
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter X-Client-Version: %s", err))
		}

		params.XClientVersion = &XClientVersion
	}
	// ------------- Optional header parameter "X-Access-Key" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Access-Key")]; found {
		var XAccessKey string
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for X-Access-Key, got %d", n))
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "X-Access-Key", runtime.ParamLocationHeader, valueList[0], &XAccessKey)
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter X-Access-Key: %s", err))
		}

		params.XAccessKey = &XAccessKey
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.ImportGoodsTaskStatusApiV1GoodsImportTaskStatusTaskIdGet(ctx, taskId, params)
	return err
}

// ImportGoodsFromFileApiV1GoodsImportUploadPost converts echo context to params.
func (w *ServerInterfaceWrapper) ImportGoodsFromFileApiV1GoodsImportUploadPost(ctx echo.Context) error {
	var err error

	ctx.Set(CashierJWTtokenScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params ImportGoodsFromFileApiV1GoodsImportUploadPostParams

	headers := ctx.Request().Header
	// ------------- Optional header parameter "X-Client-Name" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Client-Name")]; found {
		var XClientName string
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for X-Client-Name, got %d", n))
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "X-Client-Name", runtime.ParamLocationHeader, valueList[0], &XClientName)
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter X-Client-Name: %s", err))
		}

		params.XClientName = &XClientName
	}
	// ------------- Optional header parameter "X-Client-Version" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Client-Version")]; found {
		var XClientVersion string
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for X-Client-Version, got %d", n))
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "X-Client-Version", runtime.ParamLocationHeader, valueList[0], &XClientVersion)
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter X-Client-Version: %s", err))
		}

		params.XClientVersion = &XClientVersion
	}
	// ------------- Optional header parameter "X-Access-Key" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Access-Key")]; found {
		var XAccessKey string
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for X-Access-Key, got %d", n))
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "X-Access-Key", runtime.ParamLocationHeader, valueList[0], &XAccessKey)
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter X-Access-Key: %s", err))
		}

		params.XAccessKey = &XAccessKey
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.ImportGoodsFromFileApiV1GoodsImportUploadPost(ctx, params)
	return err
}

// GetGoodApiV1GoodsGoodIdGet converts echo context to params.
func (w *ServerInterfaceWrapper) GetGoodApiV1GoodsGoodIdGet(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "good_id" -------------
	var goodId openapi_types.UUID

	err = runtime.BindStyledParameterWithLocation("simple", false, "good_id", runtime.ParamLocationPath, ctx.Param("good_id"), &goodId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter good_id: %s", err))
	}

	ctx.Set(CashierJWTtokenScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetGoodApiV1GoodsGoodIdGetParams

	headers := ctx.Request().Header
	// ------------- Optional header parameter "X-Client-Name" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Client-Name")]; found {
		var XClientName string
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for X-Client-Name, got %d", n))
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "X-Client-Name", runtime.ParamLocationHeader, valueList[0], &XClientName)
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter X-Client-Name: %s", err))
		}

		params.XClientName = &XClientName
	}
	// ------------- Optional header parameter "X-Client-Version" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Client-Version")]; found {
		var XClientVersion string
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for X-Client-Version, got %d", n))
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "X-Client-Version", runtime.ParamLocationHeader, valueList[0], &XClientVersion)
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter X-Client-Version: %s", err))
		}

		params.XClientVersion = &XClientVersion
	}
	// ------------- Optional header parameter "X-Access-Key" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Access-Key")]; found {
		var XAccessKey string
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for X-Access-Key, got %d", n))
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "X-Access-Key", runtime.ParamLocationHeader, valueList[0], &XAccessKey)
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter X-Access-Key: %s", err))
		}

		params.XAccessKey = &XAccessKey
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetGoodApiV1GoodsGoodIdGet(ctx, goodId, params)
	return err
}

// GetOrdersApiV1OrdersGet converts echo context to params.
func (w *ServerInterfaceWrapper) GetOrdersApiV1OrdersGet(ctx echo.Context) error {
	var err error

	ctx.Set(CashierJWTtokenScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetOrdersApiV1OrdersGetParams
	// ------------- Optional query parameter "desc" -------------

	err = runtime.BindQueryParameter("form", true, false, "desc", ctx.QueryParams(), &params.Desc)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter desc: %s", err))
	}

	// ------------- Optional query parameter "status" -------------

	err = runtime.BindQueryParameter("form", true, false, "status", ctx.QueryParams(), &params.Status)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter status: %s", err))
	}

	// ------------- Optional query parameter "stock_code" -------------

	err = runtime.BindQueryParameter("form", true, false, "stock_code", ctx.QueryParams(), &params.StockCode)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter stock_code: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "offset" -------------

	err = runtime.BindQueryParameter("form", true, false, "offset", ctx.QueryParams(), &params.Offset)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter offset: %s", err))
	}

	headers := ctx.Request().Header
	// ------------- Optional header parameter "X-Client-Name" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Client-Name")]; found {
		var XClientName string
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for X-Client-Name, got %d", n))
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "X-Client-Name", runtime.ParamLocationHeader, valueList[0], &XClientName)
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter X-Client-Name: %s", err))
		}

		params.XClientName = &XClientName
	}
	// ------------- Optional header parameter "X-Client-Version" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Client-Version")]; found {
		var XClientVersion string
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for X-Client-Version, got %d", n))
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "X-Client-Version", runtime.ParamLocationHeader, valueList[0], &XClientVersion)
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter X-Client-Version: %s", err))
		}

		params.XClientVersion = &XClientVersion
	}
	// ------------- Optional header parameter "X-Access-Key" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Access-Key")]; found {
		var XAccessKey string
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for X-Access-Key, got %d", n))
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "X-Access-Key", runtime.ParamLocationHeader, valueList[0], &XAccessKey)
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter X-Access-Key: %s", err))
		}

		params.XAccessKey = &XAccessKey
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetOrdersApiV1OrdersGet(ctx, params)
	return err
}

// AddOrdersApiV1OrdersPost converts echo context to params.
func (w *ServerInterfaceWrapper) AddOrdersApiV1OrdersPost(ctx echo.Context) error {
	var err error

	ctx.Set(CashierJWTtokenScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AddOrdersApiV1OrdersPostParams

	headers := ctx.Request().Header
	// ------------- Optional header parameter "X-Client-Name" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Client-Name")]; found {
		var XClientName string
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for X-Client-Name, got %d", n))
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "X-Client-Name", runtime.ParamLocationHeader, valueList[0], &XClientName)
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter X-Client-Name: %s", err))
		}

		params.XClientName = &XClientName
	}
	// ------------- Optional header parameter "X-Client-Version" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Client-Version")]; found {
		var XClientVersion string
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for X-Client-Version, got %d", n))
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "X-Client-Version", runtime.ParamLocationHeader, valueList[0], &XClientVersion)
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter X-Client-Version: %s", err))
		}

		params.XClientVersion = &XClientVersion
	}
	// ------------- Optional header parameter "X-Access-Key" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Access-Key")]; found {
		var XAccessKey string
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for X-Access-Key, got %d", n))
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "X-Access-Key", runtime.ParamLocationHeader, valueList[0], &XAccessKey)
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter X-Access-Key: %s", err))
		}

		params.XAccessKey = &XAccessKey
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AddOrdersApiV1OrdersPost(ctx, params)
	return err
}

// CloseNotFiscalizeOrderApiV1OrdersClosePatch converts echo context to params.
func (w *ServerInterfaceWrapper) CloseNotFiscalizeOrderApiV1OrdersClosePatch(ctx echo.Context) error {
	var err error

	ctx.Set(CashierJWTtokenScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params CloseNotFiscalizeOrderApiV1OrdersClosePatchParams
	// ------------- Required query parameter "order_id" -------------

	err = runtime.BindQueryParameter("form", true, true, "order_id", ctx.QueryParams(), &params.OrderId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter order_id: %s", err))
	}

	headers := ctx.Request().Header
	// ------------- Optional header parameter "X-Client-Name" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Client-Name")]; found {
		var XClientName string
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for X-Client-Name, got %d", n))
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "X-Client-Name", runtime.ParamLocationHeader, valueList[0], &XClientName)
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter X-Client-Name: %s", err))
		}

		params.XClientName = &XClientName
	}
	// ------------- Optional header parameter "X-Client-Version" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Client-Version")]; found {
		var XClientVersion string
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for X-Client-Version, got %d", n))
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "X-Client-Version", runtime.ParamLocationHeader, valueList[0], &XClientVersion)
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter X-Client-Version: %s", err))
		}

		params.XClientVersion = &XClientVersion
	}
	// ------------- Optional header parameter "X-Access-Key" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Access-Key")]; found {
		var XAccessKey string
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for X-Access-Key, got %d", n))
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "X-Access-Key", runtime.ParamLocationHeader, valueList[0], &XAccessKey)
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter X-Access-Key: %s", err))
		}

		params.XAccessKey = &XAccessKey
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.CloseNotFiscalizeOrderApiV1OrdersClosePatch(ctx, params)
	return err
}

// UpdateCustomOrderStatusApiV1OrdersCustomStatusOrderIdPatch converts echo context to params.
func (w *ServerInterfaceWrapper) UpdateCustomOrderStatusApiV1OrdersCustomStatusOrderIdPatch(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "order_id" -------------
	var orderId openapi_types.UUID

	err = runtime.BindStyledParameterWithLocation("simple", false, "order_id", runtime.ParamLocationPath, ctx.Param("order_id"), &orderId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter order_id: %s", err))
	}

	ctx.Set(CashierJWTtokenScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params UpdateCustomOrderStatusApiV1OrdersCustomStatusOrderIdPatchParams
	// ------------- Required query parameter "new_status" -------------

	err = runtime.BindQueryParameter("form", true, true, "new_status", ctx.QueryParams(), &params.NewStatus)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter new_status: %s", err))
	}

	headers := ctx.Request().Header
	// ------------- Optional header parameter "X-Client-Name" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Client-Name")]; found {
		var XClientName string
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for X-Client-Name, got %d", n))
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "X-Client-Name", runtime.ParamLocationHeader, valueList[0], &XClientName)
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter X-Client-Name: %s", err))
		}

		params.XClientName = &XClientName
	}
	// ------------- Optional header parameter "X-Client-Version" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Client-Version")]; found {
		var XClientVersion string
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for X-Client-Version, got %d", n))
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "X-Client-Version", runtime.ParamLocationHeader, valueList[0], &XClientVersion)
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter X-Client-Version: %s", err))
		}

		params.XClientVersion = &XClientVersion
	}
	// ------------- Optional header parameter "X-Access-Key" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Access-Key")]; found {
		var XAccessKey string
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for X-Access-Key, got %d", n))
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "X-Access-Key", runtime.ParamLocationHeader, valueList[0], &XAccessKey)
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter X-Access-Key: %s", err))
		}

		params.XAccessKey = &XAccessKey
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.UpdateCustomOrderStatusApiV1OrdersCustomStatusOrderIdPatch(ctx, orderId, params)
	return err
}

// DeleteIntegrationApiV1OrdersIntegrationDelete converts echo context to params.
func (w *ServerInterfaceWrapper) DeleteIntegrationApiV1OrdersIntegrationDelete(ctx echo.Context) error {
	var err error

	ctx.Set(CashierJWTtokenScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params DeleteIntegrationApiV1OrdersIntegrationDeleteParams

	headers := ctx.Request().Header
	// ------------- Optional header parameter "X-Client-Name" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Client-Name")]; found {
		var XClientName string
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for X-Client-Name, got %d", n))
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "X-Client-Name", runtime.ParamLocationHeader, valueList[0], &XClientName)
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter X-Client-Name: %s", err))
		}

		params.XClientName = &XClientName
	}
	// ------------- Optional header parameter "X-Client-Version" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Client-Version")]; found {
		var XClientVersion string
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for X-Client-Version, got %d", n))
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "X-Client-Version", runtime.ParamLocationHeader, valueList[0], &XClientVersion)
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter X-Client-Version: %s", err))
		}

		params.XClientVersion = &XClientVersion
	}
	// ------------- Optional header parameter "X-Access-Key" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Access-Key")]; found {
		var XAccessKey string
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for X-Access-Key, got %d", n))
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "X-Access-Key", runtime.ParamLocationHeader, valueList[0], &XAccessKey)
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter X-Access-Key: %s", err))
		}

		params.XAccessKey = &XAccessKey
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.DeleteIntegrationApiV1OrdersIntegrationDelete(ctx, params)
	return err
}

// GetIntegrationApiV1OrdersIntegrationGet converts echo context to params.
func (w *ServerInterfaceWrapper) GetIntegrationApiV1OrdersIntegrationGet(ctx echo.Context) error {
	var err error

	ctx.Set(CashierJWTtokenScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetIntegrationApiV1OrdersIntegrationGetParams

	headers := ctx.Request().Header
	// ------------- Optional header parameter "X-Client-Name" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Client-Name")]; found {
		var XClientName string
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for X-Client-Name, got %d", n))
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "X-Client-Name", runtime.ParamLocationHeader, valueList[0], &XClientName)
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter X-Client-Name: %s", err))
		}

		params.XClientName = &XClientName
	}
	// ------------- Optional header parameter "X-Client-Version" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Client-Version")]; found {
		var XClientVersion string
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for X-Client-Version, got %d", n))
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "X-Client-Version", runtime.ParamLocationHeader, valueList[0], &XClientVersion)
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter X-Client-Version: %s", err))
		}

		params.XClientVersion = &XClientVersion
	}
	// ------------- Optional header parameter "X-Access-Key" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Access-Key")]; found {
		var XAccessKey string
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for X-Access-Key, got %d", n))
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "X-Access-Key", runtime.ParamLocationHeader, valueList[0], &XAccessKey)
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter X-Access-Key: %s", err))
		}

		params.XAccessKey = &XAccessKey
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetIntegrationApiV1OrdersIntegrationGet(ctx, params)
	return err
}

// SetIntegrationApiV1OrdersIntegrationPost converts echo context to params.
func (w *ServerInterfaceWrapper) SetIntegrationApiV1OrdersIntegrationPost(ctx echo.Context) error {
	var err error

	ctx.Set(CashierJWTtokenScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params SetIntegrationApiV1OrdersIntegrationPostParams

	headers := ctx.Request().Header
	// ------------- Optional header parameter "X-Client-Name" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Client-Name")]; found {
		var XClientName string
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for X-Client-Name, got %d", n))
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "X-Client-Name", runtime.ParamLocationHeader, valueList[0], &XClientName)
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter X-Client-Name: %s", err))
		}

		params.XClientName = &XClientName
	}
	// ------------- Optional header parameter "X-Client-Version" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Client-Version")]; found {
		var XClientVersion string
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for X-Client-Version, got %d", n))
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "X-Client-Version", runtime.ParamLocationHeader, valueList[0], &XClientVersion)
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter X-Client-Version: %s", err))
		}

		params.XClientVersion = &XClientVersion
	}
	// ------------- Optional header parameter "X-Access-Key" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Access-Key")]; found {
		var XAccessKey string
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for X-Access-Key, got %d", n))
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "X-Access-Key", runtime.ParamLocationHeader, valueList[0], &XAccessKey)
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter X-Access-Key: %s", err))
		}

		params.XAccessKey = &XAccessKey
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SetIntegrationApiV1OrdersIntegrationPost(ctx, params)
	return err
}

// EditOrderApiV1OrdersIntegrationEditOrderPost converts echo context to params.
func (w *ServerInterfaceWrapper) EditOrderApiV1OrdersIntegrationEditOrderPost(ctx echo.Context) error {
	var err error

	ctx.Set(CashierJWTtokenScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params EditOrderApiV1OrdersIntegrationEditOrderPostParams

	headers := ctx.Request().Header
	// ------------- Optional header parameter "X-Client-Name" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Client-Name")]; found {
		var XClientName string
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for X-Client-Name, got %d", n))
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "X-Client-Name", runtime.ParamLocationHeader, valueList[0], &XClientName)
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter X-Client-Name: %s", err))
		}

		params.XClientName = &XClientName
	}
	// ------------- Optional header parameter "X-Client-Version" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Client-Version")]; found {
		var XClientVersion string
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for X-Client-Version, got %d", n))
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "X-Client-Version", runtime.ParamLocationHeader, valueList[0], &XClientVersion)
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter X-Client-Version: %s", err))
		}

		params.XClientVersion = &XClientVersion
	}
	// ------------- Optional header parameter "X-Access-Key" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Access-Key")]; found {
		var XAccessKey string
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for X-Access-Key, got %d", n))
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "X-Access-Key", runtime.ParamLocationHeader, valueList[0], &XAccessKey)
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter X-Access-Key: %s", err))
		}

		params.XAccessKey = &XAccessKey
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.EditOrderApiV1OrdersIntegrationEditOrderPost(ctx, params)
	return err
}

// RunOrdersSynchronizationApiV1OrdersSyncPost converts echo context to params.
func (w *ServerInterfaceWrapper) RunOrdersSynchronizationApiV1OrdersSyncPost(ctx echo.Context) error {
	var err error

	ctx.Set(CashierJWTtokenScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params RunOrdersSynchronizationApiV1OrdersSyncPostParams

	headers := ctx.Request().Header
	// ------------- Optional header parameter "X-Client-Name" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Client-Name")]; found {
		var XClientName string
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for X-Client-Name, got %d", n))
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "X-Client-Name", runtime.ParamLocationHeader, valueList[0], &XClientName)
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter X-Client-Name: %s", err))
		}

		params.XClientName = &XClientName
	}
	// ------------- Optional header parameter "X-Client-Version" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Client-Version")]; found {
		var XClientVersion string
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for X-Client-Version, got %d", n))
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "X-Client-Version", runtime.ParamLocationHeader, valueList[0], &XClientVersion)
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter X-Client-Version: %s", err))
		}

		params.XClientVersion = &XClientVersion
	}
	// ------------- Optional header parameter "X-Access-Key" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Access-Key")]; found {
		var XAccessKey string
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for X-Access-Key, got %d", n))
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "X-Access-Key", runtime.ParamLocationHeader, valueList[0], &XAccessKey)
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter X-Access-Key: %s", err))
		}

		params.XAccessKey = &XAccessKey
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.RunOrdersSynchronizationApiV1OrdersSyncPost(ctx, params)
	return err
}

// GetOrderApiV1OrdersOrderIdGet converts echo context to params.
func (w *ServerInterfaceWrapper) GetOrderApiV1OrdersOrderIdGet(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "order_id" -------------
	var orderId openapi_types.UUID

	err = runtime.BindStyledParameterWithLocation("simple", false, "order_id", runtime.ParamLocationPath, ctx.Param("order_id"), &orderId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter order_id: %s", err))
	}

	ctx.Set(CashierJWTtokenScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetOrderApiV1OrdersOrderIdGetParams

	headers := ctx.Request().Header
	// ------------- Optional header parameter "X-Client-Name" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Client-Name")]; found {
		var XClientName string
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for X-Client-Name, got %d", n))
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "X-Client-Name", runtime.ParamLocationHeader, valueList[0], &XClientName)
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter X-Client-Name: %s", err))
		}

		params.XClientName = &XClientName
	}
	// ------------- Optional header parameter "X-Client-Version" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Client-Version")]; found {
		var XClientVersion string
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for X-Client-Version, got %d", n))
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "X-Client-Version", runtime.ParamLocationHeader, valueList[0], &XClientVersion)
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter X-Client-Version: %s", err))
		}

		params.XClientVersion = &XClientVersion
	}
	// ------------- Optional header parameter "X-Access-Key" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Access-Key")]; found {
		var XAccessKey string
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for X-Access-Key, got %d", n))
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "X-Access-Key", runtime.ParamLocationHeader, valueList[0], &XAccessKey)
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter X-Access-Key: %s", err))
		}

		params.XAccessKey = &XAccessKey
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetOrderApiV1OrdersOrderIdGet(ctx, orderId, params)
	return err
}

// CancelOrderApiV1OrdersOrderIdPatch converts echo context to params.
func (w *ServerInterfaceWrapper) CancelOrderApiV1OrdersOrderIdPatch(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "order_id" -------------
	var orderId openapi_types.UUID

	err = runtime.BindStyledParameterWithLocation("simple", false, "order_id", runtime.ParamLocationPath, ctx.Param("order_id"), &orderId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter order_id: %s", err))
	}

	ctx.Set(CashierJWTtokenScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params CancelOrderApiV1OrdersOrderIdPatchParams

	headers := ctx.Request().Header
	// ------------- Optional header parameter "X-Client-Name" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Client-Name")]; found {
		var XClientName string
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for X-Client-Name, got %d", n))
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "X-Client-Name", runtime.ParamLocationHeader, valueList[0], &XClientName)
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter X-Client-Name: %s", err))
		}

		params.XClientName = &XClientName
	}
	// ------------- Optional header parameter "X-Client-Version" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Client-Version")]; found {
		var XClientVersion string
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for X-Client-Version, got %d", n))
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "X-Client-Version", runtime.ParamLocationHeader, valueList[0], &XClientVersion)
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter X-Client-Version: %s", err))
		}

		params.XClientVersion = &XClientVersion
	}
	// ------------- Optional header parameter "X-Access-Key" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Access-Key")]; found {
		var XAccessKey string
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for X-Access-Key, got %d", n))
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "X-Access-Key", runtime.ParamLocationHeader, valueList[0], &XAccessKey)
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter X-Access-Key: %s", err))
		}

		params.XAccessKey = &XAccessKey
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.CancelOrderApiV1OrdersOrderIdPatch(ctx, orderId, params)
	return err
}

// GetCurrentOrganizationLogoApiV1OrganizationLogoPngGet converts echo context to params.
func (w *ServerInterfaceWrapper) GetCurrentOrganizationLogoApiV1OrganizationLogoPngGet(ctx echo.Context) error {
	var err error

	ctx.Set(CashierJWTtokenScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetCurrentOrganizationLogoApiV1OrganizationLogoPngGetParams

	headers := ctx.Request().Header
	// ------------- Optional header parameter "X-Client-Name" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Client-Name")]; found {
		var XClientName string
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for X-Client-Name, got %d", n))
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "X-Client-Name", runtime.ParamLocationHeader, valueList[0], &XClientName)
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter X-Client-Name: %s", err))
		}

		params.XClientName = &XClientName
	}
	// ------------- Optional header parameter "X-Client-Version" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Client-Version")]; found {
		var XClientVersion string
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for X-Client-Version, got %d", n))
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "X-Client-Version", runtime.ParamLocationHeader, valueList[0], &XClientVersion)
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter X-Client-Version: %s", err))
		}

		params.XClientVersion = &XClientVersion
	}
	// ------------- Optional header parameter "X-Access-Key" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Access-Key")]; found {
		var XAccessKey string
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for X-Access-Key, got %d", n))
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "X-Access-Key", runtime.ParamLocationHeader, valueList[0], &XAccessKey)
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter X-Access-Key: %s", err))
		}

		params.XAccessKey = &XAccessKey
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetCurrentOrganizationLogoApiV1OrganizationLogoPngGet(ctx, params)
	return err
}

// GetCurrentOrganizationReceiptSettingsApiV1OrganizationReceiptConfigGet converts echo context to params.
func (w *ServerInterfaceWrapper) GetCurrentOrganizationReceiptSettingsApiV1OrganizationReceiptConfigGet(ctx echo.Context) error {
	var err error

	ctx.Set(CashierJWTtokenScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetCurrentOrganizationReceiptSettingsApiV1OrganizationReceiptConfigGetParams

	headers := ctx.Request().Header
	// ------------- Optional header parameter "X-Client-Name" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Client-Name")]; found {
		var XClientName string
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for X-Client-Name, got %d", n))
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "X-Client-Name", runtime.ParamLocationHeader, valueList[0], &XClientName)
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter X-Client-Name: %s", err))
		}

		params.XClientName = &XClientName
	}
	// ------------- Optional header parameter "X-Client-Version" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Client-Version")]; found {
		var XClientVersion string
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for X-Client-Version, got %d", n))
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "X-Client-Version", runtime.ParamLocationHeader, valueList[0], &XClientVersion)
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter X-Client-Version: %s", err))
		}

		params.XClientVersion = &XClientVersion
	}
	// ------------- Optional header parameter "X-Access-Key" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Access-Key")]; found {
		var XAccessKey string
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for X-Access-Key, got %d", n))
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "X-Access-Key", runtime.ParamLocationHeader, valueList[0], &XAccessKey)
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter X-Access-Key: %s", err))
		}

		params.XAccessKey = &XAccessKey
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetCurrentOrganizationReceiptSettingsApiV1OrganizationReceiptConfigGet(ctx, params)
	return err
}

// GetCurrentOrganizationSmsBillingBalanceApiV1OrganizationSmsBillingGet converts echo context to params.
func (w *ServerInterfaceWrapper) GetCurrentOrganizationSmsBillingBalanceApiV1OrganizationSmsBillingGet(ctx echo.Context) error {
	var err error

	ctx.Set(CashierJWTtokenScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetCurrentOrganizationSmsBillingBalanceApiV1OrganizationSmsBillingGetParams

	headers := ctx.Request().Header
	// ------------- Optional header parameter "X-Client-Name" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Client-Name")]; found {
		var XClientName string
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for X-Client-Name, got %d", n))
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "X-Client-Name", runtime.ParamLocationHeader, valueList[0], &XClientName)
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter X-Client-Name: %s", err))
		}

		params.XClientName = &XClientName
	}
	// ------------- Optional header parameter "X-Client-Version" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Client-Version")]; found {
		var XClientVersion string
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for X-Client-Version, got %d", n))
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "X-Client-Version", runtime.ParamLocationHeader, valueList[0], &XClientVersion)
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter X-Client-Version: %s", err))
		}

		params.XClientVersion = &XClientVersion
	}
	// ------------- Optional header parameter "X-Access-Key" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Access-Key")]; found {
		var XAccessKey string
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for X-Access-Key, got %d", n))
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "X-Access-Key", runtime.ParamLocationHeader, valueList[0], &XAccessKey)
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter X-Access-Key: %s", err))
		}

		params.XAccessKey = &XAccessKey
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetCurrentOrganizationSmsBillingBalanceApiV1OrganizationSmsBillingGet(ctx, params)
	return err
}

// GetCurrentOrganizationTextLogoApiV1OrganizationTextLogoPngGet converts echo context to params.
func (w *ServerInterfaceWrapper) GetCurrentOrganizationTextLogoApiV1OrganizationTextLogoPngGet(ctx echo.Context) error {
	var err error

	ctx.Set(CashierJWTtokenScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetCurrentOrganizationTextLogoApiV1OrganizationTextLogoPngGetParams

	headers := ctx.Request().Header
	// ------------- Optional header parameter "X-Client-Name" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Client-Name")]; found {
		var XClientName string
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for X-Client-Name, got %d", n))
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "X-Client-Name", runtime.ParamLocationHeader, valueList[0], &XClientName)
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter X-Client-Name: %s", err))
		}

		params.XClientName = &XClientName
	}
	// ------------- Optional header parameter "X-Client-Version" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Client-Version")]; found {
		var XClientVersion string
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for X-Client-Version, got %d", n))
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "X-Client-Version", runtime.ParamLocationHeader, valueList[0], &XClientVersion)
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter X-Client-Version: %s", err))
		}

		params.XClientVersion = &XClientVersion
	}
	// ------------- Optional header parameter "X-Access-Key" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Access-Key")]; found {
		var XAccessKey string
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for X-Access-Key, got %d", n))
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "X-Access-Key", runtime.ParamLocationHeader, valueList[0], &XAccessKey)
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter X-Access-Key: %s", err))
		}

		params.XAccessKey = &XAccessKey
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetCurrentOrganizationTextLogoApiV1OrganizationTextLogoPngGet(ctx, params)
	return err
}

// GetReceiptsApiV1ReceiptsGet converts echo context to params.
func (w *ServerInterfaceWrapper) GetReceiptsApiV1ReceiptsGet(ctx echo.Context) error {
	var err error

	ctx.Set(CashierJWTtokenScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetReceiptsApiV1ReceiptsGetParams
	// ------------- Optional query parameter "fiscal_code" -------------

	err = runtime.BindQueryParameter("form", true, false, "fiscal_code", ctx.QueryParams(), &params.FiscalCode)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter fiscal_code: %s", err))
	}

	// ------------- Optional query parameter "serial" -------------

	err = runtime.BindQueryParameter("form", true, false, "serial", ctx.QueryParams(), &params.Serial)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter serial: %s", err))
	}

	// ------------- Optional query parameter "desc" -------------

	err = runtime.BindQueryParameter("form", true, false, "desc", ctx.QueryParams(), &params.Desc)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter desc: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "offset" -------------

	err = runtime.BindQueryParameter("form", true, false, "offset", ctx.QueryParams(), &params.Offset)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter offset: %s", err))
	}

	headers := ctx.Request().Header
	// ------------- Optional header parameter "X-Client-Name" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Client-Name")]; found {
		var XClientName string
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for X-Client-Name, got %d", n))
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "X-Client-Name", runtime.ParamLocationHeader, valueList[0], &XClientName)
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter X-Client-Name: %s", err))
		}

		params.XClientName = &XClientName
	}
	// ------------- Optional header parameter "X-Client-Version" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Client-Version")]; found {
		var XClientVersion string
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for X-Client-Version, got %d", n))
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "X-Client-Version", runtime.ParamLocationHeader, valueList[0], &XClientVersion)
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter X-Client-Version: %s", err))
		}

		params.XClientVersion = &XClientVersion
	}
	// ------------- Optional header parameter "X-Access-Key" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Access-Key")]; found {
		var XAccessKey string
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for X-Access-Key, got %d", n))
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "X-Access-Key", runtime.ParamLocationHeader, valueList[0], &XAccessKey)
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter X-Access-Key: %s", err))
		}

		params.XAccessKey = &XAccessKey
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetReceiptsApiV1ReceiptsGet(ctx, params)
	return err
}

// AddExternalReceiptApiV1ReceiptsAddExternalPost converts echo context to params.
func (w *ServerInterfaceWrapper) AddExternalReceiptApiV1ReceiptsAddExternalPost(ctx echo.Context) error {
	var err error

	ctx.Set(CashierJWTtokenScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AddExternalReceiptApiV1ReceiptsAddExternalPostParams

	headers := ctx.Request().Header
	// ------------- Optional header parameter "X-Client-Name" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Client-Name")]; found {
		var XClientName string
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for X-Client-Name, got %d", n))
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "X-Client-Name", runtime.ParamLocationHeader, valueList[0], &XClientName)
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter X-Client-Name: %s", err))
		}

		params.XClientName = &XClientName
	}
	// ------------- Optional header parameter "X-Client-Version" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Client-Version")]; found {
		var XClientVersion string
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for X-Client-Version, got %d", n))
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "X-Client-Version", runtime.ParamLocationHeader, valueList[0], &XClientVersion)
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter X-Client-Version: %s", err))
		}

		params.XClientVersion = &XClientVersion
	}
	// ------------- Optional header parameter "X-Access-Key" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Access-Key")]; found {
		var XAccessKey string
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for X-Access-Key, got %d", n))
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "X-Access-Key", runtime.ParamLocationHeader, valueList[0], &XAccessKey)
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter X-Access-Key: %s", err))
		}

		params.XAccessKey = &XAccessKey
	}
	// ------------- Optional header parameter "X-Device-ID" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Device-ID")]; found {
		var XDeviceID string
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for X-Device-ID, got %d", n))
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "X-Device-ID", runtime.ParamLocationHeader, valueList[0], &XDeviceID)
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter X-Device-ID: %s", err))
		}

		params.XDeviceID = &XDeviceID
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AddExternalReceiptApiV1ReceiptsAddExternalPost(ctx, params)
	return err
}

// CashWithdrawalApiV1ReceiptsCashWithdrawalPost converts echo context to params.
func (w *ServerInterfaceWrapper) CashWithdrawalApiV1ReceiptsCashWithdrawalPost(ctx echo.Context) error {
	var err error

	ctx.Set(CashierJWTtokenScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params CashWithdrawalApiV1ReceiptsCashWithdrawalPostParams

	headers := ctx.Request().Header
	// ------------- Optional header parameter "X-Client-Name" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Client-Name")]; found {
		var XClientName string
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for X-Client-Name, got %d", n))
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "X-Client-Name", runtime.ParamLocationHeader, valueList[0], &XClientName)
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter X-Client-Name: %s", err))
		}

		params.XClientName = &XClientName
	}
	// ------------- Optional header parameter "X-Client-Version" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Client-Version")]; found {
		var XClientVersion string
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for X-Client-Version, got %d", n))
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "X-Client-Version", runtime.ParamLocationHeader, valueList[0], &XClientVersion)
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter X-Client-Version: %s", err))
		}

		params.XClientVersion = &XClientVersion
	}
	// ------------- Optional header parameter "X-Access-Key" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Access-Key")]; found {
		var XAccessKey string
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for X-Access-Key, got %d", n))
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "X-Access-Key", runtime.ParamLocationHeader, valueList[0], &XAccessKey)
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter X-Access-Key: %s", err))
		}

		params.XAccessKey = &XAccessKey
	}
	// ------------- Optional header parameter "X-Device-ID" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Device-ID")]; found {
		var XDeviceID string
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for X-Device-ID, got %d", n))
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "X-Device-ID", runtime.ParamLocationHeader, valueList[0], &XDeviceID)
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter X-Device-ID: %s", err))
		}

		params.XDeviceID = &XDeviceID
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.CashWithdrawalApiV1ReceiptsCashWithdrawalPost(ctx, params)
	return err
}

// ExchangeApiV1ReceiptsCurrencyExchangePost converts echo context to params.
func (w *ServerInterfaceWrapper) ExchangeApiV1ReceiptsCurrencyExchangePost(ctx echo.Context) error {
	var err error

	ctx.Set(CashierJWTtokenScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params ExchangeApiV1ReceiptsCurrencyExchangePostParams

	headers := ctx.Request().Header
	// ------------- Optional header parameter "X-Client-Name" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Client-Name")]; found {
		var XClientName string
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for X-Client-Name, got %d", n))
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "X-Client-Name", runtime.ParamLocationHeader, valueList[0], &XClientName)
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter X-Client-Name: %s", err))
		}

		params.XClientName = &XClientName
	}
	// ------------- Optional header parameter "X-Client-Version" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Client-Version")]; found {
		var XClientVersion string
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for X-Client-Version, got %d", n))
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "X-Client-Version", runtime.ParamLocationHeader, valueList[0], &XClientVersion)
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter X-Client-Version: %s", err))
		}

		params.XClientVersion = &XClientVersion
	}
	// ------------- Optional header parameter "X-Access-Key" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Access-Key")]; found {
		var XAccessKey string
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for X-Access-Key, got %d", n))
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "X-Access-Key", runtime.ParamLocationHeader, valueList[0], &XAccessKey)
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter X-Access-Key: %s", err))
		}

		params.XAccessKey = &XAccessKey
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.ExchangeApiV1ReceiptsCurrencyExchangePost(ctx, params)
	return err
}

// GetReceiptsSearchApiV1ReceiptsSearchGet converts echo context to params.
func (w *ServerInterfaceWrapper) GetReceiptsSearchApiV1ReceiptsSearchGet(ctx echo.Context) error {
	var err error

	ctx.Set(CashierJWTtokenScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetReceiptsSearchApiV1ReceiptsSearchGetParams
	// ------------- Optional query parameter "fiscal_code" -------------

	err = runtime.BindQueryParameter("form", true, false, "fiscal_code", ctx.QueryParams(), &params.FiscalCode)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter fiscal_code: %s", err))
	}

	// ------------- Optional query parameter "barcode" -------------

	err = runtime.BindQueryParameter("form", true, false, "barcode", ctx.QueryParams(), &params.Barcode)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter barcode: %s", err))
	}

	// ------------- Optional query parameter "shift_id" -------------

	err = runtime.BindQueryParameter("form", true, false, "shift_id", ctx.QueryParams(), &params.ShiftId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter shift_id: %s", err))
	}

	// ------------- Optional query parameter "branch_id" -------------

	err = runtime.BindQueryParameter("form", true, false, "branch_id", ctx.QueryParams(), &params.BranchId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter branch_id: %s", err))
	}

	// ------------- Optional query parameter "cash_register_id" -------------

	err = runtime.BindQueryParameter("form", true, false, "cash_register_id", ctx.QueryParams(), &params.CashRegisterId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter cash_register_id: %s", err))
	}

	// ------------- Optional query parameter "from_date" -------------

	err = runtime.BindQueryParameter("form", true, false, "from_date", ctx.QueryParams(), &params.FromDate)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter from_date: %s", err))
	}

	// ------------- Optional query parameter "to_date" -------------

	err = runtime.BindQueryParameter("form", true, false, "to_date", ctx.QueryParams(), &params.ToDate)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter to_date: %s", err))
	}

	// ------------- Optional query parameter "desc" -------------

	err = runtime.BindQueryParameter("form", true, false, "desc", ctx.QueryParams(), &params.Desc)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter desc: %s", err))
	}

	// ------------- Optional query parameter "self_receipts" -------------

	err = runtime.BindQueryParameter("form", true, false, "self_receipts", ctx.QueryParams(), &params.SelfReceipts)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter self_receipts: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "offset" -------------

	err = runtime.BindQueryParameter("form", true, false, "offset", ctx.QueryParams(), &params.Offset)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter offset: %s", err))
	}

	headers := ctx.Request().Header
	// ------------- Optional header parameter "X-Client-Name" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Client-Name")]; found {
		var XClientName string
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for X-Client-Name, got %d", n))
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "X-Client-Name", runtime.ParamLocationHeader, valueList[0], &XClientName)
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter X-Client-Name: %s", err))
		}

		params.XClientName = &XClientName
	}
	// ------------- Optional header parameter "X-Client-Version" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Client-Version")]; found {
		var XClientVersion string
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for X-Client-Version, got %d", n))
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "X-Client-Version", runtime.ParamLocationHeader, valueList[0], &XClientVersion)
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter X-Client-Version: %s", err))
		}

		params.XClientVersion = &XClientVersion
	}
	// ------------- Optional header parameter "X-Access-Key" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Access-Key")]; found {
		var XAccessKey string
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for X-Access-Key, got %d", n))
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "X-Access-Key", runtime.ParamLocationHeader, valueList[0], &XAccessKey)
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter X-Access-Key: %s", err))
		}

		params.XAccessKey = &XAccessKey
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetReceiptsSearchApiV1ReceiptsSearchGet(ctx, params)
	return err
}

// CreateReceiptApiV1ReceiptsSellPost converts echo context to params.
func (w *ServerInterfaceWrapper) CreateReceiptApiV1ReceiptsSellPost(ctx echo.Context) error {
	var err error

	ctx.Set(CashierJWTtokenScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params CreateReceiptApiV1ReceiptsSellPostParams

	headers := ctx.Request().Header
	// ------------- Optional header parameter "X-Client-Name" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Client-Name")]; found {
		var XClientName string
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for X-Client-Name, got %d", n))
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "X-Client-Name", runtime.ParamLocationHeader, valueList[0], &XClientName)
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter X-Client-Name: %s", err))
		}

		params.XClientName = &XClientName
	}
	// ------------- Optional header parameter "X-Client-Version" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Client-Version")]; found {
		var XClientVersion string
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for X-Client-Version, got %d", n))
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "X-Client-Version", runtime.ParamLocationHeader, valueList[0], &XClientVersion)
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter X-Client-Version: %s", err))
		}

		params.XClientVersion = &XClientVersion
	}
	// ------------- Optional header parameter "X-Access-Key" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Access-Key")]; found {
		var XAccessKey string
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for X-Access-Key, got %d", n))
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "X-Access-Key", runtime.ParamLocationHeader, valueList[0], &XAccessKey)
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter X-Access-Key: %s", err))
		}

		params.XAccessKey = &XAccessKey
	}
	// ------------- Optional header parameter "X-Device-ID" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Device-ID")]; found {
		var XDeviceID string
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for X-Device-ID, got %d", n))
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "X-Device-ID", runtime.ParamLocationHeader, valueList[0], &XDeviceID)
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter X-Device-ID: %s", err))
		}

		params.XDeviceID = &XDeviceID
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.CreateReceiptApiV1ReceiptsSellPost(ctx, params)
	return err
}

// CreateOfflineReceiptApiV1ReceiptsSellOfflinePost converts echo context to params.
func (w *ServerInterfaceWrapper) CreateOfflineReceiptApiV1ReceiptsSellOfflinePost(ctx echo.Context) error {
	var err error

	ctx.Set(CashierJWTtokenScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params CreateOfflineReceiptApiV1ReceiptsSellOfflinePostParams

	headers := ctx.Request().Header
	// ------------- Optional header parameter "X-Client-Name" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Client-Name")]; found {
		var XClientName string
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for X-Client-Name, got %d", n))
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "X-Client-Name", runtime.ParamLocationHeader, valueList[0], &XClientName)
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter X-Client-Name: %s", err))
		}

		params.XClientName = &XClientName
	}
	// ------------- Optional header parameter "X-Client-Version" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Client-Version")]; found {
		var XClientVersion string
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for X-Client-Version, got %d", n))
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "X-Client-Version", runtime.ParamLocationHeader, valueList[0], &XClientVersion)
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter X-Client-Version: %s", err))
		}

		params.XClientVersion = &XClientVersion
	}
	// ------------- Optional header parameter "X-Access-Key" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Access-Key")]; found {
		var XAccessKey string
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for X-Access-Key, got %d", n))
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "X-Access-Key", runtime.ParamLocationHeader, valueList[0], &XAccessKey)
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter X-Access-Key: %s", err))
		}

		params.XAccessKey = &XAccessKey
	}
	// ------------- Optional header parameter "X-Device-ID" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Device-ID")]; found {
		var XDeviceID string
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for X-Device-ID, got %d", n))
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "X-Device-ID", runtime.ParamLocationHeader, valueList[0], &XDeviceID)
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter X-Device-ID: %s", err))
		}

		params.XDeviceID = &XDeviceID
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.CreateOfflineReceiptApiV1ReceiptsSellOfflinePost(ctx, params)
	return err
}

// CreateServiceReceiptApiV1ReceiptsServicePost converts echo context to params.
func (w *ServerInterfaceWrapper) CreateServiceReceiptApiV1ReceiptsServicePost(ctx echo.Context) error {
	var err error

	ctx.Set(CashierJWTtokenScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params CreateServiceReceiptApiV1ReceiptsServicePostParams

	headers := ctx.Request().Header
	// ------------- Optional header parameter "X-Client-Name" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Client-Name")]; found {
		var XClientName string
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for X-Client-Name, got %d", n))
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "X-Client-Name", runtime.ParamLocationHeader, valueList[0], &XClientName)
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter X-Client-Name: %s", err))
		}

		params.XClientName = &XClientName
	}
	// ------------- Optional header parameter "X-Client-Version" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Client-Version")]; found {
		var XClientVersion string
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for X-Client-Version, got %d", n))
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "X-Client-Version", runtime.ParamLocationHeader, valueList[0], &XClientVersion)
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter X-Client-Version: %s", err))
		}

		params.XClientVersion = &XClientVersion
	}
	// ------------- Optional header parameter "X-Access-Key" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Access-Key")]; found {
		var XAccessKey string
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for X-Access-Key, got %d", n))
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "X-Access-Key", runtime.ParamLocationHeader, valueList[0], &XAccessKey)
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter X-Access-Key: %s", err))
		}

		params.XAccessKey = &XAccessKey
	}
	// ------------- Optional header parameter "X-Device-ID" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Device-ID")]; found {
		var XDeviceID string
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for X-Device-ID, got %d", n))
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "X-Device-ID", runtime.ParamLocationHeader, valueList[0], &XDeviceID)
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter X-Device-ID: %s", err))
		}

		params.XDeviceID = &XDeviceID
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.CreateServiceReceiptApiV1ReceiptsServicePost(ctx, params)
	return err
}

// CreateServiceCurrencyReceiptApiV1ReceiptsServiceCurrencyPost converts echo context to params.
func (w *ServerInterfaceWrapper) CreateServiceCurrencyReceiptApiV1ReceiptsServiceCurrencyPost(ctx echo.Context) error {
	var err error

	ctx.Set(CashierJWTtokenScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params CreateServiceCurrencyReceiptApiV1ReceiptsServiceCurrencyPostParams

	headers := ctx.Request().Header
	// ------------- Optional header parameter "X-Client-Name" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Client-Name")]; found {
		var XClientName string
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for X-Client-Name, got %d", n))
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "X-Client-Name", runtime.ParamLocationHeader, valueList[0], &XClientName)
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter X-Client-Name: %s", err))
		}

		params.XClientName = &XClientName
	}
	// ------------- Optional header parameter "X-Client-Version" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Client-Version")]; found {
		var XClientVersion string
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for X-Client-Version, got %d", n))
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "X-Client-Version", runtime.ParamLocationHeader, valueList[0], &XClientVersion)
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter X-Client-Version: %s", err))
		}

		params.XClientVersion = &XClientVersion
	}
	// ------------- Optional header parameter "X-Access-Key" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Access-Key")]; found {
		var XAccessKey string
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for X-Access-Key, got %d", n))
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "X-Access-Key", runtime.ParamLocationHeader, valueList[0], &XAccessKey)
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter X-Access-Key: %s", err))
		}

		params.XAccessKey = &XAccessKey
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.CreateServiceCurrencyReceiptApiV1ReceiptsServiceCurrencyPost(ctx, params)
	return err
}

// GetReceiptApiV1ReceiptsReceiptIdGet converts echo context to params.
func (w *ServerInterfaceWrapper) GetReceiptApiV1ReceiptsReceiptIdGet(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "receipt_id" -------------
	var receiptId struct {
		union json.RawMessage
	}

	err = runtime.BindStyledParameterWithLocation("simple", false, "receipt_id", runtime.ParamLocationPath, ctx.Param("receipt_id"), &receiptId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter receipt_id: %s", err))
	}

	ctx.Set(CashierJWTtokenScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetReceiptApiV1ReceiptsReceiptIdGetParams

	headers := ctx.Request().Header
	// ------------- Optional header parameter "X-Client-Name" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Client-Name")]; found {
		var XClientName string
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for X-Client-Name, got %d", n))
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "X-Client-Name", runtime.ParamLocationHeader, valueList[0], &XClientName)
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter X-Client-Name: %s", err))
		}

		params.XClientName = &XClientName
	}
	// ------------- Optional header parameter "X-Client-Version" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Client-Version")]; found {
		var XClientVersion string
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for X-Client-Version, got %d", n))
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "X-Client-Version", runtime.ParamLocationHeader, valueList[0], &XClientVersion)
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter X-Client-Version: %s", err))
		}

		params.XClientVersion = &XClientVersion
	}
	// ------------- Optional header parameter "X-Access-Key" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Access-Key")]; found {
		var XAccessKey string
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for X-Access-Key, got %d", n))
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "X-Access-Key", runtime.ParamLocationHeader, valueList[0], &XAccessKey)
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter X-Access-Key: %s", err))
		}

		params.XAccessKey = &XAccessKey
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetReceiptApiV1ReceiptsReceiptIdGet(ctx, receiptId, params)
	return err
}

// SendReceiptToEmailApiV1ReceiptsReceiptIdEmailPost converts echo context to params.
func (w *ServerInterfaceWrapper) SendReceiptToEmailApiV1ReceiptsReceiptIdEmailPost(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "receipt_id" -------------
	var receiptId struct {
		union json.RawMessage
	}

	err = runtime.BindStyledParameterWithLocation("simple", false, "receipt_id", runtime.ParamLocationPath, ctx.Param("receipt_id"), &receiptId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter receipt_id: %s", err))
	}

	ctx.Set(CashierJWTtokenScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params SendReceiptToEmailApiV1ReceiptsReceiptIdEmailPostParams

	headers := ctx.Request().Header
	// ------------- Optional header parameter "X-Client-Name" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Client-Name")]; found {
		var XClientName string
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for X-Client-Name, got %d", n))
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "X-Client-Name", runtime.ParamLocationHeader, valueList[0], &XClientName)
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter X-Client-Name: %s", err))
		}

		params.XClientName = &XClientName
	}
	// ------------- Optional header parameter "X-Client-Version" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Client-Version")]; found {
		var XClientVersion string
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for X-Client-Version, got %d", n))
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "X-Client-Version", runtime.ParamLocationHeader, valueList[0], &XClientVersion)
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter X-Client-Version: %s", err))
		}

		params.XClientVersion = &XClientVersion
	}
	// ------------- Optional header parameter "X-Access-Key" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Access-Key")]; found {
		var XAccessKey string
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for X-Access-Key, got %d", n))
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "X-Access-Key", runtime.ParamLocationHeader, valueList[0], &XAccessKey)
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter X-Access-Key: %s", err))
		}

		params.XAccessKey = &XAccessKey
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SendReceiptToEmailApiV1ReceiptsReceiptIdEmailPost(ctx, receiptId, params)
	return err
}

// GetReceiptHtmlApiV1ReceiptsReceiptIdHtmlGet converts echo context to params.
func (w *ServerInterfaceWrapper) GetReceiptHtmlApiV1ReceiptsReceiptIdHtmlGet(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "receipt_id" -------------
	var receiptId struct {
		union json.RawMessage
	}

	err = runtime.BindStyledParameterWithLocation("simple", false, "receipt_id", runtime.ParamLocationPath, ctx.Param("receipt_id"), &receiptId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter receipt_id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params GetReceiptHtmlApiV1ReceiptsReceiptIdHtmlGetParams
	// ------------- Optional query parameter "simple" -------------

	err = runtime.BindQueryParameter("form", true, false, "simple", ctx.QueryParams(), &params.Simple)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter simple: %s", err))
	}

	headers := ctx.Request().Header
	// ------------- Optional header parameter "X-Client-Name" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Client-Name")]; found {
		var XClientName string
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for X-Client-Name, got %d", n))
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "X-Client-Name", runtime.ParamLocationHeader, valueList[0], &XClientName)
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter X-Client-Name: %s", err))
		}

		params.XClientName = &XClientName
	}
	// ------------- Optional header parameter "X-Client-Version" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Client-Version")]; found {
		var XClientVersion string
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for X-Client-Version, got %d", n))
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "X-Client-Version", runtime.ParamLocationHeader, valueList[0], &XClientVersion)
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter X-Client-Version: %s", err))
		}

		params.XClientVersion = &XClientVersion
	}
	// ------------- Optional header parameter "X-Access-Key" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Access-Key")]; found {
		var XAccessKey string
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for X-Access-Key, got %d", n))
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "X-Access-Key", runtime.ParamLocationHeader, valueList[0], &XAccessKey)
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter X-Access-Key: %s", err))
		}

		params.XAccessKey = &XAccessKey
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetReceiptHtmlApiV1ReceiptsReceiptIdHtmlGet(ctx, receiptId, params)
	return err
}

// GetReceiptPdfApiV1ReceiptsReceiptIdPdfGet converts echo context to params.
func (w *ServerInterfaceWrapper) GetReceiptPdfApiV1ReceiptsReceiptIdPdfGet(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "receipt_id" -------------
	var receiptId struct {
		union json.RawMessage
	}

	err = runtime.BindStyledParameterWithLocation("simple", false, "receipt_id", runtime.ParamLocationPath, ctx.Param("receipt_id"), &receiptId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter receipt_id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params GetReceiptPdfApiV1ReceiptsReceiptIdPdfGetParams

	headers := ctx.Request().Header
	// ------------- Optional header parameter "X-Client-Name" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Client-Name")]; found {
		var XClientName string
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for X-Client-Name, got %d", n))
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "X-Client-Name", runtime.ParamLocationHeader, valueList[0], &XClientName)
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter X-Client-Name: %s", err))
		}

		params.XClientName = &XClientName
	}
	// ------------- Optional header parameter "X-Client-Version" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Client-Version")]; found {
		var XClientVersion string
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for X-Client-Version, got %d", n))
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "X-Client-Version", runtime.ParamLocationHeader, valueList[0], &XClientVersion)
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter X-Client-Version: %s", err))
		}

		params.XClientVersion = &XClientVersion
	}
	// ------------- Optional header parameter "X-Access-Key" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Access-Key")]; found {
		var XAccessKey string
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for X-Access-Key, got %d", n))
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "X-Access-Key", runtime.ParamLocationHeader, valueList[0], &XAccessKey)
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter X-Access-Key: %s", err))
		}

		params.XAccessKey = &XAccessKey
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetReceiptPdfApiV1ReceiptsReceiptIdPdfGet(ctx, receiptId, params)
	return err
}

// GetReceiptPngApiV1ReceiptsReceiptIdPngGet converts echo context to params.
func (w *ServerInterfaceWrapper) GetReceiptPngApiV1ReceiptsReceiptIdPngGet(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "receipt_id" -------------
	var receiptId struct {
		union json.RawMessage
	}

	err = runtime.BindStyledParameterWithLocation("simple", false, "receipt_id", runtime.ParamLocationPath, ctx.Param("receipt_id"), &receiptId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter receipt_id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params GetReceiptPngApiV1ReceiptsReceiptIdPngGetParams
	// ------------- Optional query parameter "width" -------------

	err = runtime.BindQueryParameter("form", true, false, "width", ctx.QueryParams(), &params.Width)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter width: %s", err))
	}

	// ------------- Optional query parameter "paper_width" -------------

	err = runtime.BindQueryParameter("form", true, false, "paper_width", ctx.QueryParams(), &params.PaperWidth)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter paper_width: %s", err))
	}

	// ------------- Optional query parameter "qrcode_scale" -------------

	err = runtime.BindQueryParameter("form", true, false, "qrcode_scale", ctx.QueryParams(), &params.QrcodeScale)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter qrcode_scale: %s", err))
	}

	headers := ctx.Request().Header
	// ------------- Optional header parameter "X-Client-Name" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Client-Name")]; found {
		var XClientName string
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for X-Client-Name, got %d", n))
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "X-Client-Name", runtime.ParamLocationHeader, valueList[0], &XClientName)
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter X-Client-Name: %s", err))
		}

		params.XClientName = &XClientName
	}
	// ------------- Optional header parameter "X-Client-Version" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Client-Version")]; found {
		var XClientVersion string
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for X-Client-Version, got %d", n))
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "X-Client-Version", runtime.ParamLocationHeader, valueList[0], &XClientVersion)
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter X-Client-Version: %s", err))
		}

		params.XClientVersion = &XClientVersion
	}
	// ------------- Optional header parameter "X-Access-Key" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Access-Key")]; found {
		var XAccessKey string
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for X-Access-Key, got %d", n))
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "X-Access-Key", runtime.ParamLocationHeader, valueList[0], &XAccessKey)
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter X-Access-Key: %s", err))
		}

		params.XAccessKey = &XAccessKey
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetReceiptPngApiV1ReceiptsReceiptIdPngGet(ctx, receiptId, params)
	return err
}

// GetReceiptQrCodeImageApiV1ReceiptsReceiptIdQrcodeGet converts echo context to params.
func (w *ServerInterfaceWrapper) GetReceiptQrCodeImageApiV1ReceiptsReceiptIdQrcodeGet(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "receipt_id" -------------
	var receiptId struct {
		union json.RawMessage
	}

	err = runtime.BindStyledParameterWithLocation("simple", false, "receipt_id", runtime.ParamLocationPath, ctx.Param("receipt_id"), &receiptId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter receipt_id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params GetReceiptQrCodeImageApiV1ReceiptsReceiptIdQrcodeGetParams

	headers := ctx.Request().Header
	// ------------- Optional header parameter "X-Client-Name" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Client-Name")]; found {
		var XClientName string
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for X-Client-Name, got %d", n))
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "X-Client-Name", runtime.ParamLocationHeader, valueList[0], &XClientName)
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter X-Client-Name: %s", err))
		}

		params.XClientName = &XClientName
	}
	// ------------- Optional header parameter "X-Client-Version" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Client-Version")]; found {
		var XClientVersion string
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for X-Client-Version, got %d", n))
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "X-Client-Version", runtime.ParamLocationHeader, valueList[0], &XClientVersion)
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter X-Client-Version: %s", err))
		}

		params.XClientVersion = &XClientVersion
	}
	// ------------- Optional header parameter "X-Access-Key" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Access-Key")]; found {
		var XAccessKey string
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for X-Access-Key, got %d", n))
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "X-Access-Key", runtime.ParamLocationHeader, valueList[0], &XAccessKey)
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter X-Access-Key: %s", err))
		}

		params.XAccessKey = &XAccessKey
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetReceiptQrCodeImageApiV1ReceiptsReceiptIdQrcodeGet(ctx, receiptId, params)
	return err
}

// SendReceiptViaSmsApiV1ReceiptsReceiptIdSmsPost converts echo context to params.
func (w *ServerInterfaceWrapper) SendReceiptViaSmsApiV1ReceiptsReceiptIdSmsPost(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "receipt_id" -------------
	var receiptId struct {
		union json.RawMessage
	}

	err = runtime.BindStyledParameterWithLocation("simple", false, "receipt_id", runtime.ParamLocationPath, ctx.Param("receipt_id"), &receiptId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter receipt_id: %s", err))
	}

	ctx.Set(CashierJWTtokenScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params SendReceiptViaSmsApiV1ReceiptsReceiptIdSmsPostParams

	headers := ctx.Request().Header
	// ------------- Optional header parameter "X-Client-Name" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Client-Name")]; found {
		var XClientName string
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for X-Client-Name, got %d", n))
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "X-Client-Name", runtime.ParamLocationHeader, valueList[0], &XClientName)
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter X-Client-Name: %s", err))
		}

		params.XClientName = &XClientName
	}
	// ------------- Optional header parameter "X-Client-Version" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Client-Version")]; found {
		var XClientVersion string
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for X-Client-Version, got %d", n))
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "X-Client-Version", runtime.ParamLocationHeader, valueList[0], &XClientVersion)
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter X-Client-Version: %s", err))
		}

		params.XClientVersion = &XClientVersion
	}
	// ------------- Optional header parameter "X-Access-Key" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Access-Key")]; found {
		var XAccessKey string
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for X-Access-Key, got %d", n))
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "X-Access-Key", runtime.ParamLocationHeader, valueList[0], &XAccessKey)
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter X-Access-Key: %s", err))
		}

		params.XAccessKey = &XAccessKey
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SendReceiptViaSmsApiV1ReceiptsReceiptIdSmsPost(ctx, receiptId, params)
	return err
}

// GetReceiptTextApiV1ReceiptsReceiptIdTextGet converts echo context to params.
func (w *ServerInterfaceWrapper) GetReceiptTextApiV1ReceiptsReceiptIdTextGet(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "receipt_id" -------------
	var receiptId struct {
		union json.RawMessage
	}

	err = runtime.BindStyledParameterWithLocation("simple", false, "receipt_id", runtime.ParamLocationPath, ctx.Param("receipt_id"), &receiptId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter receipt_id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params GetReceiptTextApiV1ReceiptsReceiptIdTextGetParams
	// ------------- Optional query parameter "width" -------------

	err = runtime.BindQueryParameter("form", true, false, "width", ctx.QueryParams(), &params.Width)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter width: %s", err))
	}

	headers := ctx.Request().Header
	// ------------- Optional header parameter "X-Client-Name" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Client-Name")]; found {
		var XClientName string
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for X-Client-Name, got %d", n))
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "X-Client-Name", runtime.ParamLocationHeader, valueList[0], &XClientName)
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter X-Client-Name: %s", err))
		}

		params.XClientName = &XClientName
	}
	// ------------- Optional header parameter "X-Client-Version" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Client-Version")]; found {
		var XClientVersion string
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for X-Client-Version, got %d", n))
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "X-Client-Version", runtime.ParamLocationHeader, valueList[0], &XClientVersion)
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter X-Client-Version: %s", err))
		}

		params.XClientVersion = &XClientVersion
	}
	// ------------- Optional header parameter "X-Access-Key" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Access-Key")]; found {
		var XAccessKey string
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for X-Access-Key, got %d", n))
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "X-Access-Key", runtime.ParamLocationHeader, valueList[0], &XAccessKey)
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter X-Access-Key: %s", err))
		}

		params.XAccessKey = &XAccessKey
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetReceiptTextApiV1ReceiptsReceiptIdTextGet(ctx, receiptId, params)
	return err
}

// GetReceiptXmlApiV1ReceiptsReceiptIdXmlGet converts echo context to params.
func (w *ServerInterfaceWrapper) GetReceiptXmlApiV1ReceiptsReceiptIdXmlGet(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "receipt_id" -------------
	var receiptId struct {
		union json.RawMessage
	}

	err = runtime.BindStyledParameterWithLocation("simple", false, "receipt_id", runtime.ParamLocationPath, ctx.Param("receipt_id"), &receiptId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter receipt_id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params GetReceiptXmlApiV1ReceiptsReceiptIdXmlGetParams

	headers := ctx.Request().Header
	// ------------- Optional header parameter "X-Client-Name" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Client-Name")]; found {
		var XClientName string
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for X-Client-Name, got %d", n))
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "X-Client-Name", runtime.ParamLocationHeader, valueList[0], &XClientName)
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter X-Client-Name: %s", err))
		}

		params.XClientName = &XClientName
	}
	// ------------- Optional header parameter "X-Client-Version" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Client-Version")]; found {
		var XClientVersion string
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for X-Client-Version, got %d", n))
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "X-Client-Version", runtime.ParamLocationHeader, valueList[0], &XClientVersion)
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter X-Client-Version: %s", err))
		}

		params.XClientVersion = &XClientVersion
	}
	// ------------- Optional header parameter "X-Access-Key" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Access-Key")]; found {
		var XAccessKey string
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for X-Access-Key, got %d", n))
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "X-Access-Key", runtime.ParamLocationHeader, valueList[0], &XAccessKey)
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter X-Access-Key: %s", err))
		}

		params.XAccessKey = &XAccessKey
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetReceiptXmlApiV1ReceiptsReceiptIdXmlGet(ctx, receiptId, params)
	return err
}

// GetReportsApiV1ReportsGet converts echo context to params.
func (w *ServerInterfaceWrapper) GetReportsApiV1ReportsGet(ctx echo.Context) error {
	var err error

	ctx.Set(CashierJWTtokenScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetReportsApiV1ReportsGetParams
	// ------------- Optional query parameter "from_date" -------------

	err = runtime.BindQueryParameter("form", true, false, "from_date", ctx.QueryParams(), &params.FromDate)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter from_date: %s", err))
	}

	// ------------- Optional query parameter "to_date" -------------

	err = runtime.BindQueryParameter("form", true, false, "to_date", ctx.QueryParams(), &params.ToDate)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter to_date: %s", err))
	}

	// ------------- Optional query parameter "shift_id" -------------

	err = runtime.BindQueryParameter("form", true, false, "shift_id", ctx.QueryParams(), &params.ShiftId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter shift_id: %s", err))
	}

	// ------------- Optional query parameter "serial" -------------

	err = runtime.BindQueryParameter("form", true, false, "serial", ctx.QueryParams(), &params.Serial)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter serial: %s", err))
	}

	// ------------- Optional query parameter "is_z_report" -------------

	err = runtime.BindQueryParameter("form", true, false, "is_z_report", ctx.QueryParams(), &params.IsZReport)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter is_z_report: %s", err))
	}

	// ------------- Optional query parameter "desc" -------------

	err = runtime.BindQueryParameter("form", true, false, "desc", ctx.QueryParams(), &params.Desc)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter desc: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "offset" -------------

	err = runtime.BindQueryParameter("form", true, false, "offset", ctx.QueryParams(), &params.Offset)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter offset: %s", err))
	}

	headers := ctx.Request().Header
	// ------------- Optional header parameter "X-Client-Name" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Client-Name")]; found {
		var XClientName string
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for X-Client-Name, got %d", n))
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "X-Client-Name", runtime.ParamLocationHeader, valueList[0], &XClientName)
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter X-Client-Name: %s", err))
		}

		params.XClientName = &XClientName
	}
	// ------------- Optional header parameter "X-Client-Version" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Client-Version")]; found {
		var XClientVersion string
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for X-Client-Version, got %d", n))
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "X-Client-Version", runtime.ParamLocationHeader, valueList[0], &XClientVersion)
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter X-Client-Version: %s", err))
		}

		params.XClientVersion = &XClientVersion
	}
	// ------------- Optional header parameter "X-Access-Key" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Access-Key")]; found {
		var XAccessKey string
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for X-Access-Key, got %d", n))
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "X-Access-Key", runtime.ParamLocationHeader, valueList[0], &XAccessKey)
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter X-Access-Key: %s", err))
		}

		params.XAccessKey = &XAccessKey
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetReportsApiV1ReportsGet(ctx, params)
	return err
}

// CreateXReportApiV1ReportsPost converts echo context to params.
func (w *ServerInterfaceWrapper) CreateXReportApiV1ReportsPost(ctx echo.Context) error {
	var err error

	ctx.Set(CashierJWTtokenScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params CreateXReportApiV1ReportsPostParams

	headers := ctx.Request().Header
	// ------------- Optional header parameter "X-Client-Name" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Client-Name")]; found {
		var XClientName string
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for X-Client-Name, got %d", n))
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "X-Client-Name", runtime.ParamLocationHeader, valueList[0], &XClientName)
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter X-Client-Name: %s", err))
		}

		params.XClientName = &XClientName
	}
	// ------------- Optional header parameter "X-Client-Version" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Client-Version")]; found {
		var XClientVersion string
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for X-Client-Version, got %d", n))
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "X-Client-Version", runtime.ParamLocationHeader, valueList[0], &XClientVersion)
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter X-Client-Version: %s", err))
		}

		params.XClientVersion = &XClientVersion
	}
	// ------------- Optional header parameter "X-Access-Key" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Access-Key")]; found {
		var XAccessKey string
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for X-Access-Key, got %d", n))
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "X-Access-Key", runtime.ParamLocationHeader, valueList[0], &XAccessKey)
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter X-Access-Key: %s", err))
		}

		params.XAccessKey = &XAccessKey
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.CreateXReportApiV1ReportsPost(ctx, params)
	return err
}

// AddExternalReportApiV1ReportsAddExternalPost converts echo context to params.
func (w *ServerInterfaceWrapper) AddExternalReportApiV1ReportsAddExternalPost(ctx echo.Context) error {
	var err error

	ctx.Set(CashierJWTtokenScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AddExternalReportApiV1ReportsAddExternalPostParams

	headers := ctx.Request().Header
	// ------------- Optional header parameter "X-Client-Name" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Client-Name")]; found {
		var XClientName string
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for X-Client-Name, got %d", n))
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "X-Client-Name", runtime.ParamLocationHeader, valueList[0], &XClientName)
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter X-Client-Name: %s", err))
		}

		params.XClientName = &XClientName
	}
	// ------------- Optional header parameter "X-Client-Version" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Client-Version")]; found {
		var XClientVersion string
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for X-Client-Version, got %d", n))
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "X-Client-Version", runtime.ParamLocationHeader, valueList[0], &XClientVersion)
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter X-Client-Version: %s", err))
		}

		params.XClientVersion = &XClientVersion
	}
	// ------------- Optional header parameter "X-Access-Key" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Access-Key")]; found {
		var XAccessKey string
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for X-Access-Key, got %d", n))
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "X-Access-Key", runtime.ParamLocationHeader, valueList[0], &XAccessKey)
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter X-Access-Key: %s", err))
		}

		params.XAccessKey = &XAccessKey
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AddExternalReportApiV1ReportsAddExternalPost(ctx, params)
	return err
}

// GetPeriodicalReportApiV1ReportsPeriodicalGet converts echo context to params.
func (w *ServerInterfaceWrapper) GetPeriodicalReportApiV1ReportsPeriodicalGet(ctx echo.Context) error {
	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params GetPeriodicalReportApiV1ReportsPeriodicalGetParams
	// ------------- Required query parameter "from_date" -------------

	err = runtime.BindQueryParameter("form", true, true, "from_date", ctx.QueryParams(), &params.FromDate)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter from_date: %s", err))
	}

	// ------------- Required query parameter "to_date" -------------

	err = runtime.BindQueryParameter("form", true, true, "to_date", ctx.QueryParams(), &params.ToDate)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter to_date: %s", err))
	}

	// ------------- Optional query parameter "width" -------------

	err = runtime.BindQueryParameter("form", true, false, "width", ctx.QueryParams(), &params.Width)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter width: %s", err))
	}

	headers := ctx.Request().Header
	// ------------- Optional header parameter "X-Client-Name" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Client-Name")]; found {
		var XClientName string
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for X-Client-Name, got %d", n))
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "X-Client-Name", runtime.ParamLocationHeader, valueList[0], &XClientName)
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter X-Client-Name: %s", err))
		}

		params.XClientName = &XClientName
	}
	// ------------- Optional header parameter "X-Client-Version" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Client-Version")]; found {
		var XClientVersion string
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for X-Client-Version, got %d", n))
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "X-Client-Version", runtime.ParamLocationHeader, valueList[0], &XClientVersion)
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter X-Client-Version: %s", err))
		}

		params.XClientVersion = &XClientVersion
	}
	// ------------- Optional header parameter "X-Access-Key" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Access-Key")]; found {
		var XAccessKey string
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for X-Access-Key, got %d", n))
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "X-Access-Key", runtime.ParamLocationHeader, valueList[0], &XAccessKey)
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter X-Access-Key: %s", err))
		}

		params.XAccessKey = &XAccessKey
	}
	// ------------- Required header parameter "X-License-Key" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-License-Key")]; found {
		var XLicenseKey string
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for X-License-Key, got %d", n))
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "X-License-Key", runtime.ParamLocationHeader, valueList[0], &XLicenseKey)
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter X-License-Key: %s", err))
		}

		params.XLicenseKey = XLicenseKey
	} else {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Header parameter X-License-Key is required, but not found"))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetPeriodicalReportApiV1ReportsPeriodicalGet(ctx, params)
	return err
}

// GetSearchReportsApiV1ReportsSearchGet converts echo context to params.
func (w *ServerInterfaceWrapper) GetSearchReportsApiV1ReportsSearchGet(ctx echo.Context) error {
	var err error

	ctx.Set(CashierJWTtokenScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetSearchReportsApiV1ReportsSearchGetParams
	// ------------- Optional query parameter "from_date" -------------

	err = runtime.BindQueryParameter("form", true, false, "from_date", ctx.QueryParams(), &params.FromDate)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter from_date: %s", err))
	}

	// ------------- Optional query parameter "to_date" -------------

	err = runtime.BindQueryParameter("form", true, false, "to_date", ctx.QueryParams(), &params.ToDate)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter to_date: %s", err))
	}

	// ------------- Optional query parameter "shift_id" -------------

	err = runtime.BindQueryParameter("form", true, false, "shift_id", ctx.QueryParams(), &params.ShiftId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter shift_id: %s", err))
	}

	// ------------- Optional query parameter "serial" -------------

	err = runtime.BindQueryParameter("form", true, false, "serial", ctx.QueryParams(), &params.Serial)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter serial: %s", err))
	}

	// ------------- Optional query parameter "is_z_report" -------------

	err = runtime.BindQueryParameter("form", true, false, "is_z_report", ctx.QueryParams(), &params.IsZReport)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter is_z_report: %s", err))
	}

	// ------------- Optional query parameter "desc" -------------

	err = runtime.BindQueryParameter("form", true, false, "desc", ctx.QueryParams(), &params.Desc)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter desc: %s", err))
	}

	// ------------- Optional query parameter "cash_register_id" -------------

	err = runtime.BindQueryParameter("form", true, false, "cash_register_id", ctx.QueryParams(), &params.CashRegisterId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter cash_register_id: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "offset" -------------

	err = runtime.BindQueryParameter("form", true, false, "offset", ctx.QueryParams(), &params.Offset)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter offset: %s", err))
	}

	headers := ctx.Request().Header
	// ------------- Optional header parameter "X-Client-Name" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Client-Name")]; found {
		var XClientName string
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for X-Client-Name, got %d", n))
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "X-Client-Name", runtime.ParamLocationHeader, valueList[0], &XClientName)
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter X-Client-Name: %s", err))
		}

		params.XClientName = &XClientName
	}
	// ------------- Optional header parameter "X-Client-Version" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Client-Version")]; found {
		var XClientVersion string
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for X-Client-Version, got %d", n))
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "X-Client-Version", runtime.ParamLocationHeader, valueList[0], &XClientVersion)
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter X-Client-Version: %s", err))
		}

		params.XClientVersion = &XClientVersion
	}
	// ------------- Optional header parameter "X-Access-Key" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Access-Key")]; found {
		var XAccessKey string
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for X-Access-Key, got %d", n))
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "X-Access-Key", runtime.ParamLocationHeader, valueList[0], &XAccessKey)
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter X-Access-Key: %s", err))
		}

		params.XAccessKey = &XAccessKey
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetSearchReportsApiV1ReportsSearchGet(ctx, params)
	return err
}

// GetReportApiV1ReportsReportIdGet converts echo context to params.
func (w *ServerInterfaceWrapper) GetReportApiV1ReportsReportIdGet(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "report_id" -------------
	var reportId openapi_types.UUID

	err = runtime.BindStyledParameterWithLocation("simple", false, "report_id", runtime.ParamLocationPath, ctx.Param("report_id"), &reportId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter report_id: %s", err))
	}

	ctx.Set(CashierJWTtokenScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetReportApiV1ReportsReportIdGetParams

	headers := ctx.Request().Header
	// ------------- Optional header parameter "X-Client-Name" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Client-Name")]; found {
		var XClientName string
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for X-Client-Name, got %d", n))
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "X-Client-Name", runtime.ParamLocationHeader, valueList[0], &XClientName)
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter X-Client-Name: %s", err))
		}

		params.XClientName = &XClientName
	}
	// ------------- Optional header parameter "X-Client-Version" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Client-Version")]; found {
		var XClientVersion string
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for X-Client-Version, got %d", n))
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "X-Client-Version", runtime.ParamLocationHeader, valueList[0], &XClientVersion)
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter X-Client-Version: %s", err))
		}

		params.XClientVersion = &XClientVersion
	}
	// ------------- Optional header parameter "X-Access-Key" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Access-Key")]; found {
		var XAccessKey string
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for X-Access-Key, got %d", n))
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "X-Access-Key", runtime.ParamLocationHeader, valueList[0], &XAccessKey)
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter X-Access-Key: %s", err))
		}

		params.XAccessKey = &XAccessKey
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetReportApiV1ReportsReportIdGet(ctx, reportId, params)
	return err
}

// GetReportTextApiV1ReportsReportIdTextGet converts echo context to params.
func (w *ServerInterfaceWrapper) GetReportTextApiV1ReportsReportIdTextGet(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "report_id" -------------
	var reportId openapi_types.UUID

	err = runtime.BindStyledParameterWithLocation("simple", false, "report_id", runtime.ParamLocationPath, ctx.Param("report_id"), &reportId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter report_id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params GetReportTextApiV1ReportsReportIdTextGetParams
	// ------------- Optional query parameter "width" -------------

	err = runtime.BindQueryParameter("form", true, false, "width", ctx.QueryParams(), &params.Width)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter width: %s", err))
	}

	headers := ctx.Request().Header
	// ------------- Optional header parameter "X-Client-Name" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Client-Name")]; found {
		var XClientName string
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for X-Client-Name, got %d", n))
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "X-Client-Name", runtime.ParamLocationHeader, valueList[0], &XClientName)
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter X-Client-Name: %s", err))
		}

		params.XClientName = &XClientName
	}
	// ------------- Optional header parameter "X-Client-Version" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Client-Version")]; found {
		var XClientVersion string
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for X-Client-Version, got %d", n))
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "X-Client-Version", runtime.ParamLocationHeader, valueList[0], &XClientVersion)
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter X-Client-Version: %s", err))
		}

		params.XClientVersion = &XClientVersion
	}
	// ------------- Optional header parameter "X-Access-Key" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Access-Key")]; found {
		var XAccessKey string
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for X-Access-Key, got %d", n))
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "X-Access-Key", runtime.ParamLocationHeader, valueList[0], &XAccessKey)
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter X-Access-Key: %s", err))
		}

		params.XAccessKey = &XAccessKey
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetReportTextApiV1ReportsReportIdTextGet(ctx, reportId, params)
	return err
}

// GetShiftsApiV1ShiftsGet converts echo context to params.
func (w *ServerInterfaceWrapper) GetShiftsApiV1ShiftsGet(ctx echo.Context) error {
	var err error

	ctx.Set(CashierJWTtokenScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetShiftsApiV1ShiftsGetParams
	// ------------- Optional query parameter "statuses" -------------

	err = runtime.BindQueryParameter("form", true, false, "statuses", ctx.QueryParams(), &params.Statuses)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter statuses: %s", err))
	}

	// ------------- Optional query parameter "desc" -------------

	err = runtime.BindQueryParameter("form", true, false, "desc", ctx.QueryParams(), &params.Desc)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter desc: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "offset" -------------

	err = runtime.BindQueryParameter("form", true, false, "offset", ctx.QueryParams(), &params.Offset)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter offset: %s", err))
	}

	headers := ctx.Request().Header
	// ------------- Optional header parameter "X-Client-Name" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Client-Name")]; found {
		var XClientName string
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for X-Client-Name, got %d", n))
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "X-Client-Name", runtime.ParamLocationHeader, valueList[0], &XClientName)
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter X-Client-Name: %s", err))
		}

		params.XClientName = &XClientName
	}
	// ------------- Optional header parameter "X-Client-Version" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Client-Version")]; found {
		var XClientVersion string
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for X-Client-Version, got %d", n))
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "X-Client-Version", runtime.ParamLocationHeader, valueList[0], &XClientVersion)
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter X-Client-Version: %s", err))
		}

		params.XClientVersion = &XClientVersion
	}
	// ------------- Optional header parameter "X-Access-Key" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Access-Key")]; found {
		var XAccessKey string
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for X-Access-Key, got %d", n))
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "X-Access-Key", runtime.ParamLocationHeader, valueList[0], &XAccessKey)
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter X-Access-Key: %s", err))
		}

		params.XAccessKey = &XAccessKey
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetShiftsApiV1ShiftsGet(ctx, params)
	return err
}

// CreateShiftApiV1ShiftsPost converts echo context to params.
func (w *ServerInterfaceWrapper) CreateShiftApiV1ShiftsPost(ctx echo.Context) error {
	var err error

	ctx.Set(CashierJWTtokenScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params CreateShiftApiV1ShiftsPostParams

	headers := ctx.Request().Header
	// ------------- Optional header parameter "X-Client-Name" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Client-Name")]; found {
		var XClientName string
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for X-Client-Name, got %d", n))
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "X-Client-Name", runtime.ParamLocationHeader, valueList[0], &XClientName)
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter X-Client-Name: %s", err))
		}

		params.XClientName = &XClientName
	}
	// ------------- Optional header parameter "X-Client-Version" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Client-Version")]; found {
		var XClientVersion string
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for X-Client-Version, got %d", n))
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "X-Client-Version", runtime.ParamLocationHeader, valueList[0], &XClientVersion)
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter X-Client-Version: %s", err))
		}

		params.XClientVersion = &XClientVersion
	}
	// ------------- Optional header parameter "X-Access-Key" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Access-Key")]; found {
		var XAccessKey string
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for X-Access-Key, got %d", n))
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "X-Access-Key", runtime.ParamLocationHeader, valueList[0], &XAccessKey)
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter X-Access-Key: %s", err))
		}

		params.XAccessKey = &XAccessKey
	}
	// ------------- Optional header parameter "X-Device-ID" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Device-ID")]; found {
		var XDeviceID string
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for X-Device-ID, got %d", n))
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "X-Device-ID", runtime.ParamLocationHeader, valueList[0], &XDeviceID)
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter X-Device-ID: %s", err))
		}

		params.XDeviceID = &XDeviceID
	}
	// ------------- Required header parameter "X-License-Key" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-License-Key")]; found {
		var XLicenseKey string
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for X-License-Key, got %d", n))
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "X-License-Key", runtime.ParamLocationHeader, valueList[0], &XLicenseKey)
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter X-License-Key: %s", err))
		}

		params.XLicenseKey = XLicenseKey
	} else {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Header parameter X-License-Key is required, but not found"))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.CreateShiftApiV1ShiftsPost(ctx, params)
	return err
}

// CloseShiftApiV1ShiftsClosePost converts echo context to params.
func (w *ServerInterfaceWrapper) CloseShiftApiV1ShiftsClosePost(ctx echo.Context) error {
	var err error

	ctx.Set(CashierJWTtokenScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params CloseShiftApiV1ShiftsClosePostParams

	headers := ctx.Request().Header
	// ------------- Optional header parameter "X-Client-Name" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Client-Name")]; found {
		var XClientName string
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for X-Client-Name, got %d", n))
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "X-Client-Name", runtime.ParamLocationHeader, valueList[0], &XClientName)
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter X-Client-Name: %s", err))
		}

		params.XClientName = &XClientName
	}
	// ------------- Optional header parameter "X-Client-Version" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Client-Version")]; found {
		var XClientVersion string
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for X-Client-Version, got %d", n))
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "X-Client-Version", runtime.ParamLocationHeader, valueList[0], &XClientVersion)
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter X-Client-Version: %s", err))
		}

		params.XClientVersion = &XClientVersion
	}
	// ------------- Optional header parameter "X-Access-Key" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Access-Key")]; found {
		var XAccessKey string
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for X-Access-Key, got %d", n))
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "X-Access-Key", runtime.ParamLocationHeader, valueList[0], &XAccessKey)
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter X-Access-Key: %s", err))
		}

		params.XAccessKey = &XAccessKey
	}
	// ------------- Optional header parameter "X-Device-ID" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Device-ID")]; found {
		var XDeviceID string
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for X-Device-ID, got %d", n))
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "X-Device-ID", runtime.ParamLocationHeader, valueList[0], &XDeviceID)
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter X-Device-ID: %s", err))
		}

		params.XDeviceID = &XDeviceID
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.CloseShiftApiV1ShiftsClosePost(ctx, params)
	return err
}

// GetShiftApiV1ShiftsShiftIdGet converts echo context to params.
func (w *ServerInterfaceWrapper) GetShiftApiV1ShiftsShiftIdGet(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "shift_id" -------------
	var shiftId openapi_types.UUID

	err = runtime.BindStyledParameterWithLocation("simple", false, "shift_id", runtime.ParamLocationPath, ctx.Param("shift_id"), &shiftId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter shift_id: %s", err))
	}

	ctx.Set(CashierJWTtokenScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetShiftApiV1ShiftsShiftIdGetParams

	headers := ctx.Request().Header
	// ------------- Optional header parameter "X-Client-Name" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Client-Name")]; found {
		var XClientName string
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for X-Client-Name, got %d", n))
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "X-Client-Name", runtime.ParamLocationHeader, valueList[0], &XClientName)
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter X-Client-Name: %s", err))
		}

		params.XClientName = &XClientName
	}
	// ------------- Optional header parameter "X-Client-Version" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Client-Version")]; found {
		var XClientVersion string
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for X-Client-Version, got %d", n))
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "X-Client-Version", runtime.ParamLocationHeader, valueList[0], &XClientVersion)
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter X-Client-Version: %s", err))
		}

		params.XClientVersion = &XClientVersion
	}
	// ------------- Optional header parameter "X-Access-Key" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Access-Key")]; found {
		var XAccessKey string
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for X-Access-Key, got %d", n))
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "X-Access-Key", runtime.ParamLocationHeader, valueList[0], &XAccessKey)
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter X-Access-Key: %s", err))
		}

		params.XAccessKey = &XAccessKey
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetShiftApiV1ShiftsShiftIdGet(ctx, shiftId, params)
	return err
}

// CloseShiftBySeniorCashierApiV1ShiftsShiftIdClosePost converts echo context to params.
func (w *ServerInterfaceWrapper) CloseShiftBySeniorCashierApiV1ShiftsShiftIdClosePost(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "shift_id" -------------
	var shiftId openapi_types.UUID

	err = runtime.BindStyledParameterWithLocation("simple", false, "shift_id", runtime.ParamLocationPath, ctx.Param("shift_id"), &shiftId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter shift_id: %s", err))
	}

	ctx.Set(CashierJWTtokenScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params CloseShiftBySeniorCashierApiV1ShiftsShiftIdClosePostParams

	headers := ctx.Request().Header
	// ------------- Optional header parameter "X-Client-Name" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Client-Name")]; found {
		var XClientName string
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for X-Client-Name, got %d", n))
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "X-Client-Name", runtime.ParamLocationHeader, valueList[0], &XClientName)
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter X-Client-Name: %s", err))
		}

		params.XClientName = &XClientName
	}
	// ------------- Optional header parameter "X-Client-Version" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Client-Version")]; found {
		var XClientVersion string
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for X-Client-Version, got %d", n))
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "X-Client-Version", runtime.ParamLocationHeader, valueList[0], &XClientVersion)
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter X-Client-Version: %s", err))
		}

		params.XClientVersion = &XClientVersion
	}
	// ------------- Optional header parameter "X-Access-Key" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Access-Key")]; found {
		var XAccessKey string
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for X-Access-Key, got %d", n))
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "X-Access-Key", runtime.ParamLocationHeader, valueList[0], &XAccessKey)
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter X-Access-Key: %s", err))
		}

		params.XAccessKey = &XAccessKey
	}
	// ------------- Required header parameter "X-License-Key" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-License-Key")]; found {
		var XLicenseKey string
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for X-License-Key, got %d", n))
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "X-License-Key", runtime.ParamLocationHeader, valueList[0], &XLicenseKey)
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter X-License-Key: %s", err))
		}

		params.XLicenseKey = XLicenseKey
	} else {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Header parameter X-License-Key is required, but not found"))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.CloseShiftBySeniorCashierApiV1ShiftsShiftIdClosePost(ctx, shiftId, params)
	return err
}

// GetAllTaxesApiV1TaxGet converts echo context to params.
func (w *ServerInterfaceWrapper) GetAllTaxesApiV1TaxGet(ctx echo.Context) error {
	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params GetAllTaxesApiV1TaxGetParams

	headers := ctx.Request().Header
	// ------------- Optional header parameter "X-Client-Name" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Client-Name")]; found {
		var XClientName string
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for X-Client-Name, got %d", n))
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "X-Client-Name", runtime.ParamLocationHeader, valueList[0], &XClientName)
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter X-Client-Name: %s", err))
		}

		params.XClientName = &XClientName
	}
	// ------------- Optional header parameter "X-Client-Version" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Client-Version")]; found {
		var XClientVersion string
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for X-Client-Version, got %d", n))
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "X-Client-Version", runtime.ParamLocationHeader, valueList[0], &XClientVersion)
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter X-Client-Version: %s", err))
		}

		params.XClientVersion = &XClientVersion
	}
	// ------------- Optional header parameter "X-Access-Key" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Access-Key")]; found {
		var XAccessKey string
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for X-Access-Key, got %d", n))
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "X-Access-Key", runtime.ParamLocationHeader, valueList[0], &XAccessKey)
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter X-Access-Key: %s", err))
		}

		params.XAccessKey = &XAccessKey
	}
	// ------------- Required header parameter "X-License-Key" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-License-Key")]; found {
		var XLicenseKey string
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for X-License-Key, got %d", n))
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "X-License-Key", runtime.ParamLocationHeader, valueList[0], &XLicenseKey)
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter X-License-Key: %s", err))
		}

		params.XLicenseKey = XLicenseKey
	} else {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Header parameter X-License-Key is required, but not found"))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetAllTaxesApiV1TaxGet(ctx, params)
	return err
}

// GetTransactionsApiV1TransactionsGet converts echo context to params.
func (w *ServerInterfaceWrapper) GetTransactionsApiV1TransactionsGet(ctx echo.Context) error {
	var err error

	ctx.Set(CashierJWTtokenScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetTransactionsApiV1TransactionsGetParams
	// ------------- Optional query parameter "status" -------------

	err = runtime.BindQueryParameter("form", true, false, "status", ctx.QueryParams(), &params.Status)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter status: %s", err))
	}

	// ------------- Optional query parameter "type" -------------

	err = runtime.BindQueryParameter("form", true, false, "type", ctx.QueryParams(), &params.Type)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter type: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "offset" -------------

	err = runtime.BindQueryParameter("form", true, false, "offset", ctx.QueryParams(), &params.Offset)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter offset: %s", err))
	}

	headers := ctx.Request().Header
	// ------------- Optional header parameter "X-Client-Name" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Client-Name")]; found {
		var XClientName string
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for X-Client-Name, got %d", n))
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "X-Client-Name", runtime.ParamLocationHeader, valueList[0], &XClientName)
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter X-Client-Name: %s", err))
		}

		params.XClientName = &XClientName
	}
	// ------------- Optional header parameter "X-Client-Version" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Client-Version")]; found {
		var XClientVersion string
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for X-Client-Version, got %d", n))
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "X-Client-Version", runtime.ParamLocationHeader, valueList[0], &XClientVersion)
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter X-Client-Version: %s", err))
		}

		params.XClientVersion = &XClientVersion
	}
	// ------------- Optional header parameter "X-Access-Key" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Access-Key")]; found {
		var XAccessKey string
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for X-Access-Key, got %d", n))
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "X-Access-Key", runtime.ParamLocationHeader, valueList[0], &XAccessKey)
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter X-Access-Key: %s", err))
		}

		params.XAccessKey = &XAccessKey
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetTransactionsApiV1TransactionsGet(ctx, params)
	return err
}

// GetTransactionApiV1TransactionsTransactionIdGet converts echo context to params.
func (w *ServerInterfaceWrapper) GetTransactionApiV1TransactionsTransactionIdGet(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "transaction_id" -------------
	var transactionId openapi_types.UUID

	err = runtime.BindStyledParameterWithLocation("simple", false, "transaction_id", runtime.ParamLocationPath, ctx.Param("transaction_id"), &transactionId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter transaction_id: %s", err))
	}

	ctx.Set(CashierJWTtokenScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetTransactionApiV1TransactionsTransactionIdGetParams

	headers := ctx.Request().Header
	// ------------- Optional header parameter "X-Client-Name" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Client-Name")]; found {
		var XClientName string
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for X-Client-Name, got %d", n))
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "X-Client-Name", runtime.ParamLocationHeader, valueList[0], &XClientName)
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter X-Client-Name: %s", err))
		}

		params.XClientName = &XClientName
	}
	// ------------- Optional header parameter "X-Client-Version" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Client-Version")]; found {
		var XClientVersion string
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for X-Client-Version, got %d", n))
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "X-Client-Version", runtime.ParamLocationHeader, valueList[0], &XClientVersion)
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter X-Client-Version: %s", err))
		}

		params.XClientVersion = &XClientVersion
	}
	// ------------- Optional header parameter "X-Access-Key" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Access-Key")]; found {
		var XAccessKey string
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for X-Access-Key, got %d", n))
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "X-Access-Key", runtime.ParamLocationHeader, valueList[0], &XAccessKey)
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter X-Access-Key: %s", err))
		}

		params.XAccessKey = &XAccessKey
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetTransactionApiV1TransactionsTransactionIdGet(ctx, transactionId, params)
	return err
}

// UpdateTransactionApiV1TransactionsTransactionIdPatch converts echo context to params.
func (w *ServerInterfaceWrapper) UpdateTransactionApiV1TransactionsTransactionIdPatch(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "transaction_id" -------------
	var transactionId openapi_types.UUID

	err = runtime.BindStyledParameterWithLocation("simple", false, "transaction_id", runtime.ParamLocationPath, ctx.Param("transaction_id"), &transactionId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter transaction_id: %s", err))
	}

	ctx.Set(CashierJWTtokenScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params UpdateTransactionApiV1TransactionsTransactionIdPatchParams

	headers := ctx.Request().Header
	// ------------- Optional header parameter "X-Client-Name" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Client-Name")]; found {
		var XClientName string
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for X-Client-Name, got %d", n))
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "X-Client-Name", runtime.ParamLocationHeader, valueList[0], &XClientName)
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter X-Client-Name: %s", err))
		}

		params.XClientName = &XClientName
	}
	// ------------- Optional header parameter "X-Client-Version" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Client-Version")]; found {
		var XClientVersion string
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for X-Client-Version, got %d", n))
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "X-Client-Version", runtime.ParamLocationHeader, valueList[0], &XClientVersion)
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter X-Client-Version: %s", err))
		}

		params.XClientVersion = &XClientVersion
	}
	// ------------- Optional header parameter "X-Access-Key" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Access-Key")]; found {
		var XAccessKey string
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for X-Access-Key, got %d", n))
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "X-Access-Key", runtime.ParamLocationHeader, valueList[0], &XAccessKey)
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter X-Access-Key: %s", err))
		}

		params.XAccessKey = &XAccessKey
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.UpdateTransactionApiV1TransactionsTransactionIdPatch(ctx, transactionId, params)
	return err
}

// DeleteWebhookApiV1WebhookDelete converts echo context to params.
func (w *ServerInterfaceWrapper) DeleteWebhookApiV1WebhookDelete(ctx echo.Context) error {
	var err error

	ctx.Set(CashierJWTtokenScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params DeleteWebhookApiV1WebhookDeleteParams

	headers := ctx.Request().Header
	// ------------- Optional header parameter "X-Client-Name" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Client-Name")]; found {
		var XClientName string
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for X-Client-Name, got %d", n))
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "X-Client-Name", runtime.ParamLocationHeader, valueList[0], &XClientName)
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter X-Client-Name: %s", err))
		}

		params.XClientName = &XClientName
	}
	// ------------- Optional header parameter "X-Client-Version" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Client-Version")]; found {
		var XClientVersion string
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for X-Client-Version, got %d", n))
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "X-Client-Version", runtime.ParamLocationHeader, valueList[0], &XClientVersion)
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter X-Client-Version: %s", err))
		}

		params.XClientVersion = &XClientVersion
	}
	// ------------- Optional header parameter "X-Access-Key" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Access-Key")]; found {
		var XAccessKey string
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for X-Access-Key, got %d", n))
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "X-Access-Key", runtime.ParamLocationHeader, valueList[0], &XAccessKey)
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter X-Access-Key: %s", err))
		}

		params.XAccessKey = &XAccessKey
	}
	// ------------- Required header parameter "X-License-Key" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-License-Key")]; found {
		var XLicenseKey string
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for X-License-Key, got %d", n))
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "X-License-Key", runtime.ParamLocationHeader, valueList[0], &XLicenseKey)
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter X-License-Key: %s", err))
		}

		params.XLicenseKey = XLicenseKey
	} else {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Header parameter X-License-Key is required, but not found"))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.DeleteWebhookApiV1WebhookDelete(ctx, params)
	return err
}

// GetWebhookInfoApiV1WebhookGet converts echo context to params.
func (w *ServerInterfaceWrapper) GetWebhookInfoApiV1WebhookGet(ctx echo.Context) error {
	var err error

	ctx.Set(CashierJWTtokenScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetWebhookInfoApiV1WebhookGetParams

	headers := ctx.Request().Header
	// ------------- Optional header parameter "X-Client-Name" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Client-Name")]; found {
		var XClientName string
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for X-Client-Name, got %d", n))
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "X-Client-Name", runtime.ParamLocationHeader, valueList[0], &XClientName)
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter X-Client-Name: %s", err))
		}

		params.XClientName = &XClientName
	}
	// ------------- Optional header parameter "X-Client-Version" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Client-Version")]; found {
		var XClientVersion string
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for X-Client-Version, got %d", n))
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "X-Client-Version", runtime.ParamLocationHeader, valueList[0], &XClientVersion)
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter X-Client-Version: %s", err))
		}

		params.XClientVersion = &XClientVersion
	}
	// ------------- Optional header parameter "X-Access-Key" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Access-Key")]; found {
		var XAccessKey string
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for X-Access-Key, got %d", n))
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "X-Access-Key", runtime.ParamLocationHeader, valueList[0], &XAccessKey)
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter X-Access-Key: %s", err))
		}

		params.XAccessKey = &XAccessKey
	}
	// ------------- Required header parameter "X-License-Key" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-License-Key")]; found {
		var XLicenseKey string
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for X-License-Key, got %d", n))
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "X-License-Key", runtime.ParamLocationHeader, valueList[0], &XLicenseKey)
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter X-License-Key: %s", err))
		}

		params.XLicenseKey = XLicenseKey
	} else {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Header parameter X-License-Key is required, but not found"))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetWebhookInfoApiV1WebhookGet(ctx, params)
	return err
}

// SetWebhookApiV1WebhookPost converts echo context to params.
func (w *ServerInterfaceWrapper) SetWebhookApiV1WebhookPost(ctx echo.Context) error {
	var err error

	ctx.Set(CashierJWTtokenScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params SetWebhookApiV1WebhookPostParams

	headers := ctx.Request().Header
	// ------------- Optional header parameter "X-Client-Name" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Client-Name")]; found {
		var XClientName string
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for X-Client-Name, got %d", n))
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "X-Client-Name", runtime.ParamLocationHeader, valueList[0], &XClientName)
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter X-Client-Name: %s", err))
		}

		params.XClientName = &XClientName
	}
	// ------------- Optional header parameter "X-Client-Version" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Client-Version")]; found {
		var XClientVersion string
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for X-Client-Version, got %d", n))
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "X-Client-Version", runtime.ParamLocationHeader, valueList[0], &XClientVersion)
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter X-Client-Version: %s", err))
		}

		params.XClientVersion = &XClientVersion
	}
	// ------------- Optional header parameter "X-Access-Key" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Access-Key")]; found {
		var XAccessKey string
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for X-Access-Key, got %d", n))
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "X-Access-Key", runtime.ParamLocationHeader, valueList[0], &XAccessKey)
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter X-Access-Key: %s", err))
		}

		params.XAccessKey = &XAccessKey
	}
	// ------------- Required header parameter "X-License-Key" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-License-Key")]; found {
		var XLicenseKey string
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for X-License-Key, got %d", n))
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "X-License-Key", runtime.ParamLocationHeader, valueList[0], &XLicenseKey)
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter X-License-Key: %s", err))
		}

		params.XLicenseKey = XLicenseKey
	} else {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Header parameter X-License-Key is required, but not found"))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SetWebhookApiV1WebhookPost(ctx, params)
	return err
}

// This is a simple interface which specifies echo.Route addition functions which
// are present on both echo.Echo and echo.Group, since we want to allow using
// either of them for path registration
type EchoRouter interface {
	CONNECT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	DELETE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	GET(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	HEAD(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	OPTIONS(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PATCH(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	POST(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PUT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	TRACE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router EchoRouter, si ServerInterface) {
	RegisterHandlersWithBaseURL(router, si, "")
}

// Registers handlers, and prepends BaseURL to the paths, so that the paths
// can be served under a prefix.
func RegisterHandlersWithBaseURL(router EchoRouter, si ServerInterface, baseURL string) {

	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	router.GET(baseURL+"/api/v1/cash-registers", wrapper.GetCashRegistersApiV1CashRegistersGet)
	router.GET(baseURL+"/api/v1/cash-registers/ask-offline-codes", wrapper.AskOfflineCodesApiV1CashRegistersAskOfflineCodesGet)
	router.GET(baseURL+"/api/v1/cash-registers/get-offline-codes", wrapper.GetOfflineCodesApiV1CashRegistersGetOfflineCodesGet)
	router.GET(baseURL+"/api/v1/cash-registers/get-offline-codes-count", wrapper.GetOfflineCodesCountApiV1CashRegistersGetOfflineCodesCountGet)
	router.GET(baseURL+"/api/v1/cash-registers/get-offline-time", wrapper.GetOfflineTimeApiV1CashRegistersGetOfflineTimeGet)
	router.POST(baseURL+"/api/v1/cash-registers/go-offline", wrapper.GoOfflineActionApiV1CashRegistersGoOfflinePost)
	router.POST(baseURL+"/api/v1/cash-registers/go-online", wrapper.GoOnlineActionApiV1CashRegistersGoOnlinePost)
	router.GET(baseURL+"/api/v1/cash-registers/info", wrapper.GetCashRegisterInfoApiV1CashRegistersInfoGet)
	router.POST(baseURL+"/api/v1/cash-registers/ping-tax-service", wrapper.PingTaxServiceActionApiV1CashRegistersPingTaxServicePost)
	router.GET(baseURL+"/api/v1/cash-registers/:cash_register_id", wrapper.GetCashRegisterApiV1CashRegistersCashRegisterIdGet)
	router.GET(baseURL+"/api/v1/cashier/check-signature", wrapper.CheckSignatureApiV1CashierCheckSignatureGet)
	router.GET(baseURL+"/api/v1/cashier/me", wrapper.GetCashierProfileApiV1CashierMeGet)
	router.GET(baseURL+"/api/v1/cashier/shift", wrapper.GetCashierShiftApiV1CashierShiftGet)
	router.POST(baseURL+"/api/v1/cashier/signin", wrapper.SignInCashierApiV1CashierSigninPost)
	router.POST(baseURL+"/api/v1/cashier/signinPinCode", wrapper.SignInCashierViaPinCodeApiV1CashierSigninPinCodePost)
	router.POST(baseURL+"/api/v1/cashier/signout", wrapper.SignOutCashierApiV1CashierSignoutPost)
	router.GET(baseURL+"/api/v1/currency/rate", wrapper.GetCurrencyRatesApiV1CurrencyRateGet)
	router.POST(baseURL+"/api/v1/currency/rate/setup", wrapper.SetupCurrencyRatesApiV1CurrencyRateSetupPost)
	router.GET(baseURL+"/api/v1/currency/rate/:currency_code", wrapper.GetCurrencyRateApiV1CurrencyRateCurrencyCodeGet)
	router.POST(baseURL+"/api/v1/extended-reports/goods", wrapper.GoodsReportApiV1ExtendedReportsGoodsPost)
	router.GET(baseURL+"/api/v1/extended-reports/:report_task_id", wrapper.GetReportTaskByIdApiV1ExtendedReportsReportTaskIdGet)
	router.GET(baseURL+"/api/v1/extended-reports/:report_task_id/report.xlsx", wrapper.GetReportXlsxByIdApiV1ExtendedReportsReportTaskIdReportXlsxGet)
	router.GET(baseURL+"/api/v1/goods", wrapper.GetGoodsApiV1GoodsGet)
	router.GET(baseURL+"/api/v1/goods/export/file/:task_id", wrapper.ExportGoodsFileApiV1GoodsExportFileTaskIdGet)
	router.GET(baseURL+"/api/v1/goods/export/task_status/:task_id", wrapper.ExportGoodsTaskStatusApiV1GoodsExportTaskStatusTaskIdGet)
	router.GET(baseURL+"/api/v1/goods/export/:export_extension", wrapper.ExportGoodsApiV1GoodsExportExportExtensionGet)
	router.POST(baseURL+"/api/v1/goods/import/apply_changes/:task_id", wrapper.ImportGoodsApplyChangesApiV1GoodsImportApplyChangesTaskIdPost)
	router.GET(baseURL+"/api/v1/goods/import/task_status/:task_id", wrapper.ImportGoodsTaskStatusApiV1GoodsImportTaskStatusTaskIdGet)
	router.POST(baseURL+"/api/v1/goods/import/upload", wrapper.ImportGoodsFromFileApiV1GoodsImportUploadPost)
	router.GET(baseURL+"/api/v1/goods/:good_id", wrapper.GetGoodApiV1GoodsGoodIdGet)
	router.GET(baseURL+"/api/v1/orders", wrapper.GetOrdersApiV1OrdersGet)
	router.POST(baseURL+"/api/v1/orders", wrapper.AddOrdersApiV1OrdersPost)
	router.PATCH(baseURL+"/api/v1/orders/close", wrapper.CloseNotFiscalizeOrderApiV1OrdersClosePatch)
	router.PATCH(baseURL+"/api/v1/orders/custom_status/:order_id", wrapper.UpdateCustomOrderStatusApiV1OrdersCustomStatusOrderIdPatch)
	router.DELETE(baseURL+"/api/v1/orders/integration", wrapper.DeleteIntegrationApiV1OrdersIntegrationDelete)
	router.GET(baseURL+"/api/v1/orders/integration", wrapper.GetIntegrationApiV1OrdersIntegrationGet)
	router.POST(baseURL+"/api/v1/orders/integration", wrapper.SetIntegrationApiV1OrdersIntegrationPost)
	router.POST(baseURL+"/api/v1/orders/integration/edit-order", wrapper.EditOrderApiV1OrdersIntegrationEditOrderPost)
	router.POST(baseURL+"/api/v1/orders/sync", wrapper.RunOrdersSynchronizationApiV1OrdersSyncPost)
	router.GET(baseURL+"/api/v1/orders/:order_id", wrapper.GetOrderApiV1OrdersOrderIdGet)
	router.PATCH(baseURL+"/api/v1/orders/:order_id", wrapper.CancelOrderApiV1OrdersOrderIdPatch)
	router.GET(baseURL+"/api/v1/organization/logo.png", wrapper.GetCurrentOrganizationLogoApiV1OrganizationLogoPngGet)
	router.GET(baseURL+"/api/v1/organization/receipt-config", wrapper.GetCurrentOrganizationReceiptSettingsApiV1OrganizationReceiptConfigGet)
	router.GET(baseURL+"/api/v1/organization/sms-billing", wrapper.GetCurrentOrganizationSmsBillingBalanceApiV1OrganizationSmsBillingGet)
	router.GET(baseURL+"/api/v1/organization/text_logo.png", wrapper.GetCurrentOrganizationTextLogoApiV1OrganizationTextLogoPngGet)
	router.GET(baseURL+"/api/v1/receipts", wrapper.GetReceiptsApiV1ReceiptsGet)
	router.POST(baseURL+"/api/v1/receipts/add-external", wrapper.AddExternalReceiptApiV1ReceiptsAddExternalPost)
	router.POST(baseURL+"/api/v1/receipts/cash-withdrawal", wrapper.CashWithdrawalApiV1ReceiptsCashWithdrawalPost)
	router.POST(baseURL+"/api/v1/receipts/currency-exchange", wrapper.ExchangeApiV1ReceiptsCurrencyExchangePost)
	router.GET(baseURL+"/api/v1/receipts/search", wrapper.GetReceiptsSearchApiV1ReceiptsSearchGet)
	router.POST(baseURL+"/api/v1/receipts/sell", wrapper.CreateReceiptApiV1ReceiptsSellPost)
	router.POST(baseURL+"/api/v1/receipts/sell-offline", wrapper.CreateOfflineReceiptApiV1ReceiptsSellOfflinePost)
	router.POST(baseURL+"/api/v1/receipts/service", wrapper.CreateServiceReceiptApiV1ReceiptsServicePost)
	router.POST(baseURL+"/api/v1/receipts/service-currency", wrapper.CreateServiceCurrencyReceiptApiV1ReceiptsServiceCurrencyPost)
	router.GET(baseURL+"/api/v1/receipts/:receipt_id", wrapper.GetReceiptApiV1ReceiptsReceiptIdGet)
	router.POST(baseURL+"/api/v1/receipts/:receipt_id/email", wrapper.SendReceiptToEmailApiV1ReceiptsReceiptIdEmailPost)
	router.GET(baseURL+"/api/v1/receipts/:receipt_id/html", wrapper.GetReceiptHtmlApiV1ReceiptsReceiptIdHtmlGet)
	router.GET(baseURL+"/api/v1/receipts/:receipt_id/pdf", wrapper.GetReceiptPdfApiV1ReceiptsReceiptIdPdfGet)
	router.GET(baseURL+"/api/v1/receipts/:receipt_id/png", wrapper.GetReceiptPngApiV1ReceiptsReceiptIdPngGet)
	router.GET(baseURL+"/api/v1/receipts/:receipt_id/qrcode", wrapper.GetReceiptQrCodeImageApiV1ReceiptsReceiptIdQrcodeGet)
	router.POST(baseURL+"/api/v1/receipts/:receipt_id/sms", wrapper.SendReceiptViaSmsApiV1ReceiptsReceiptIdSmsPost)
	router.GET(baseURL+"/api/v1/receipts/:receipt_id/text", wrapper.GetReceiptTextApiV1ReceiptsReceiptIdTextGet)
	router.GET(baseURL+"/api/v1/receipts/:receipt_id/xml", wrapper.GetReceiptXmlApiV1ReceiptsReceiptIdXmlGet)
	router.GET(baseURL+"/api/v1/reports", wrapper.GetReportsApiV1ReportsGet)
	router.POST(baseURL+"/api/v1/reports", wrapper.CreateXReportApiV1ReportsPost)
	router.POST(baseURL+"/api/v1/reports/add-external", wrapper.AddExternalReportApiV1ReportsAddExternalPost)
	router.GET(baseURL+"/api/v1/reports/periodical", wrapper.GetPeriodicalReportApiV1ReportsPeriodicalGet)
	router.GET(baseURL+"/api/v1/reports/search", wrapper.GetSearchReportsApiV1ReportsSearchGet)
	router.GET(baseURL+"/api/v1/reports/:report_id", wrapper.GetReportApiV1ReportsReportIdGet)
	router.GET(baseURL+"/api/v1/reports/:report_id/text", wrapper.GetReportTextApiV1ReportsReportIdTextGet)
	router.GET(baseURL+"/api/v1/shifts", wrapper.GetShiftsApiV1ShiftsGet)
	router.POST(baseURL+"/api/v1/shifts", wrapper.CreateShiftApiV1ShiftsPost)
	router.POST(baseURL+"/api/v1/shifts/close", wrapper.CloseShiftApiV1ShiftsClosePost)
	router.GET(baseURL+"/api/v1/shifts/:shift_id", wrapper.GetShiftApiV1ShiftsShiftIdGet)
	router.POST(baseURL+"/api/v1/shifts/:shift_id/close", wrapper.CloseShiftBySeniorCashierApiV1ShiftsShiftIdClosePost)
	router.GET(baseURL+"/api/v1/tax", wrapper.GetAllTaxesApiV1TaxGet)
	router.GET(baseURL+"/api/v1/transactions", wrapper.GetTransactionsApiV1TransactionsGet)
	router.GET(baseURL+"/api/v1/transactions/:transaction_id", wrapper.GetTransactionApiV1TransactionsTransactionIdGet)
	router.PATCH(baseURL+"/api/v1/transactions/:transaction_id", wrapper.UpdateTransactionApiV1TransactionsTransactionIdPatch)
	router.DELETE(baseURL+"/api/v1/webhook", wrapper.DeleteWebhookApiV1WebhookDelete)
	router.GET(baseURL+"/api/v1/webhook", wrapper.GetWebhookInfoApiV1WebhookGet)
	router.POST(baseURL+"/api/v1/webhook", wrapper.SetWebhookApiV1WebhookPost)

}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"H4sIAAAAAAAC/+y9e3PbSJYn+lWyuRPRdl3qYddjqiti/pAl2ta2y1KLsqu2S14WREISViTABkCX1A5H",
	"WFL5MbEOu6dHQ2/UTJe7ujfu3D9uxFKyZMmyHl8h8RXuJ7mRJzOBTCABghJly1Z2dJRFAPnOPL9zTp7H",
	"vULVaTQd27R9r/DVvYJXXTAbBvw5Uqu5pud97dTMOvnddJ2m6fqWCW8N+rbiLzdN8vsfXHOu8FXhvwxF",
	"9Q2xyoZYTdPLTbNktxqF+8WC0TRcv2HafsVuNWZNl1ThW37dLHxVGOHv0E36rligrRQ837XseVLerJt3",
	"Dd+RypX4s/D7Wcepm4YNBWzfNeyqKRXgz8IClu2b86ZLCszVHbn6q/BA9Sn50606DfHrcf5M1RnPd03T",
	"Fz8v0yeJkd4vFlzzDy3LNWuFr76TZz2s504xmjtx0cLanNn/YVZ90nJ8Kb66V6iZXtW1mr7l2KQCG5l2",
	"q2G6BnkwWCAzR777rjBXN0gHF5yWR9p25uasqqloO6xbsWxXjDqZ8JQ9NUvfivPCCiinvWq4tYpr+i3X",
	"9sQyo4ZbQ1PseWpBz6ibyWJleKou5C2oW/MWurTmLaha8xYyWqtZXtVp2b5X8VrSvhrjL1BZnGKhqLnk",
	"u0alumC482a8dIm8Q6PwLrUCy7Z8y6jLu5k+Un3ume5dq2pWLFva0PQpGrczCzktX1VqouUri7WaNcM3",
	"axUDSs05boP8VSAPB3yrAfuEVXWLfopGup8qKxzdbLjdhFWTNkxsI8R2oTQb8iiFgyKdAsUhveLUlitW",
	"o+m4fmXecWpeZc51GpU5q25WjKZVuXuJPWbftJp1x6hVmo7nJw8VKSVN1qxlG+6yMFNXyRfd5giqEcdw",
	"gj6qhkwI8UI21kgYwR4paEzVNfPukVH6qXKPFAtWTaqg1bJqQtnxmqqMbTQk+nXTaJiq7xx33rCtPxqU",
	"6mbD54TwLZ2h0zsJZFA27bMRTrHUWWmCxQ0hrKBigUeNerVVJ+U4BZs0lsmWSC53w6nBHBr1+sRc4avv",
	"smeHV0daLtwXOoT/irfxa7yL91HwAB/ineAB7gQPgzV8gPeCNTSAcAdvBCv4EL8NngWr+ADv4jcoeIx3",
	"Ed4M2niLvAtW8R4+xJvkXS8LHCO80JmdYA2/DZ4Gq8Fa8Cx4jDsoWAnW8D7uRDUwduh+seAbS5Uqnwp7",
	"mU1Fgibei7ctTMG0sYRGYV6i6jy5Pss3G/RkJYgte2K4rrEMDcW/jUYrf6rogRd91evCEn5CXtgXZI3w",
	"a7xHZhCW6wB38BbewB28SZ6Sxu4a9Za0UvgF+Sx4jLfxAT4InifnPHYYGJMF25HXRxdW6Ez6vs48BNcc",
	"pzZm+oZV91LPwazh8vWPkIM+UpG92KejKd+ZS1XLMytC5Q1j6YZpz/sLha8+G/7NF9HYxkqTU6XRkenS",
	"2K8Q/jPeJScheIB3g5VglZyJYA2/CVbxNpLr9Lo3C+PL2E58yf5vvBv8CKd3E28jvCOvIAqeBKvQoYdw",
	"SLeCNXKm94JHeBe+PQxeIHK8ggd4D+8WElu6MOc4vix8XKVPFCNYMI2a/O11+uQEMNB0LZnfnYQHStZn",
	"0f+jWRO/vUWfdKPpbMMwqk5bVG5gxZ7suofHfbORuoFDJlZa7awzn36ahF0RssCKBSU8R/5GFCNmdVSy",
	"wZ8URGoOwPIYN0hlqzmjVfcLX80Zdc8UmAePiQxK8dDyKj9Ytm3Z816laSzHeORxD33D3qJJ+lZVyR9a",
	"hu1b/rJY9Hf8mZIllxErTTrwjSXzOAtKpmzaWFKs5zTUGF/L2C6GhaWdFMbGu5O6n8X92XUzC91L7OVs",
	"8iqKe/1iP6kc5xq+mZTgpshTBc9AyySgjxa6zRAsUcqyq/VWTSYu4/yZam/VjVlTkg9vwAPFIOLdT+u4",
	"t9yYdaQqy/SJos7E8FIGpqaDddZVj9fv0i5xfBenUJiaNLY3dQdl7rYps2paTb9s1uv9gn/DW7BMtxJH",
	"nlH6HKUhUNWxfXPJZ2KWRVh8oz4pi19x5jMsncWOhmt7L7GB7giHf5S1r5iuasvzqVIti8KwqRx17Dlr",
	"XqAuNbNu3TXd5W7lx9h3UtGm4fpGw7QlwjsmPFbMpIR2IeH/7k7xHUHfnOVVjXolvmeuwmOUxg6yUjV2",
	"TjPpFatqTDrDQlU9MFOgGzgmiog0/b6Myap56YVvO47Ib3kVz6zXpVX33ZaM9uSkK0lp01humHEWKTpx",
	"2bPiLUzS4tF0dCvi1nosMjHrOXXTN1VFxYM8yQeSXAHXadm1uCpyijyUdZCS7HssJoMRg174jGLBN6sL",
	"tkVOQXfGbZp/m8W/+Y5v1CtsZcUxT5MXiM2UctxQ0jU9RbEp08soE5tdWkQ5uwnFXkQ2ZHIQH4jYlNRV",
	"fpyF3ZzJmCnQLw9anlv27DhE6fRYOtup3DWk/XnTQbcNtRSSl/9jCvQK+a9zl5Lr8AwOR6NlFy1omn+n",
	"4iWNutm9Jrh7ya7nw+dJkydHedASlD2pgq9Cp92KQSi5Wa/HrmzZazRCaDp9rZglWgv5IevlOqBR6gQP",
	"gjZ+i7cRPsKH5I8iAsVrmtpJ1SlVqy1/IcEWjbT8hVSmaNawFxOc9BXDXkxnow23VmkY3mJMoXbpN0X5",
	"gvFr8k2G+s5cqtZbnnXX/NpYshqEqMu8BP4LPsT7eDt4gPAhPsJvcSdYFXVbIq1zGg3L89gVQ0Qaw6eq",
	"QiEhCA9NAf8Ea7MKqtWiNLzLXxYLDcsOfxe70w/nB1shp0yQp6nT2zR+sL0Fp1mRtCsR60Hfomy1CgOn",
	"irfs+WZDrgDeoDJ9o5Jj6UGq2I5EzehTdNNRlpF7OSV2S7gosOZtw2+5ZiUiDALF4W/RFH+r5DhMt2HZ",
	"8p3tNH9WTNPX59XEs+kJFfHRzhgdKV+/USqXBTzC/4K38Q5+hQ+D1aAN+vhDvIk7KPgRjvE+7kg7F13g",
	"lVyUCGmD7//fXL786af/eHn40y++/Pyzf/zHL4aHBSoeI7PhPo7RWVrrHfksxmiekjImOOwEZVSdl38V",
	"Bt+HE9OX3X+yJQ9X9197W9d3u6aJ1UpZ0ylz3vJ80x0z71qp1ijv6da55lRbwENXPJ8xT5nqC/55mXwd",
	"Xg+bDdOdN+3qcj7JvsQ/TxXuhQqpwlxiYKPi7GW6piFp78XUCunGXguGV/EWrDmJ6bxueKgMD5Uq9OPc",
	"3Sd6lt4lZ26ubtlmpRFjKyboc/S1xFlIpl/GcoWVlg3AjGXESqvPL/1QoO/wr6Jvp2gaIK+htOtFgwGf",
	"dU2apdjYxWVN7vrYsVYd2C5nO+1UV33rrswJ0ieqOe/boT7+3j/tjfwON4vBJzpNaokvXpcVZqdl2qKc",
	"pLzOngksbi9KJGXNZVqPqEcq86qTqiSyeVvHbooWvn9fPSficPPPDO9/8nK25YbWR+GykxUfqJl13xDW",
	"fYx/qbQ2tGvd0cVWblPPN9zuu64MX6k2XJdJ4iPvYa7C1Yspl1quyzR5oiYhe9ZGWSHlHarjG/XeqgOF",
	"npop6jYPdFQp0/CN5S/UXOMHo86EGX0flXYf9c5vlD6oG53TvmYR1Ok933AUmq5513JaRHyicjztgWz6",
	"btWo4ukIbwcP8DbewgfBU3xIRFkU/Bi0gxUizuG3wVN8wB8/xttgTHhBragK1oPV4GmwEjwH2Sh4FLTx",
	"IVirsVoQ3sJvyVsiTR2ANROYI0JPghX8NmjjLRC0DshvInpdLBRTp26SjRNxzcR4d/sgPrExKE4lDCmE",
	"xDLdkWrV9LxpZ9G0p0yv6dheqmwFX1Z88qm4Zf7rN9OIPlQpLciL0OFEVOSZtm9VAaMQM9pL1XjwYt9F",
	"xm13UK464q4Y4hBic5c1F+nTl+YVUXeqi7JW6Ap7pKKfpOAcGYlZyYPNo9H3KAWn+8cFt+r1BCBcbdXr",
	"qWhwHEKxaC6z482/+625nGKsZctOCzct5cZrmi7TmOZi7SzTnYxKhCJ5pOjL4zMVKv6oCuZ0GfVwXeiM",
	"hHOY6HQW7251YdtV05LY7I5bM10v6wZ2gn6RFNfuJ7qTaC69Z2S6xxVcct2Zp1tErbLj3Az9TIlanveD",
	"49bSq5g0XY/wOIhxTCgs0m3teKNhgeSCsGF1G/ekZY8yJkMeftOyE+wHH/Pk+M0BNfcXBxheSVr/ePPZ",
	"3YRtmMaiO3ZcoTJhp6pSQOlQcZqmXWk6nmfNWvWYoSQoltBE07TRpPBFll61h8Mcmx9H6mlq99SzJ86K",
	"av4WzOoifc1hqAydUkg5Cy170auAfZG03vAcjcJzpQjouo6bX9CeaDLnwhIpF5LHUFiktWXJ1oJoKA1b",
	"QHvDW+xiwjtteIt52CNeVdgBcR1SZ1e1FHXHM2FjpYpYKQw//jn4Eb/FHfwGHyQ50V38BgFDCreCJ5UI",
	"8H/iTrCC8KHQJN4Bq3rC2a4Gq4Rb3cH7QZu0jS4EbfwKmNMHMrt7RDhXwiBDdRk14E0EPHE4wAfcb4fy",
	"uoq7uKZDFQf57jKm4PvIaCka7O8H8Au8GbSDVRSshPcYcK0RTSx46azCO8Kitwmv/jZoB+uEX6e+Jt6i",
	"1axU6xb4MxsNs1IlGyMLxcqLVhONQglgfhBspS6olthAql0G+AwgmQKxXDKXeSRO1dV8EjXFrORUb8HH",
	"0AWu0oqEZ/H6INvprWa6XJJmtwohrTiWUtTxK/QgWH+UfTMcH10NX6hIPDAlsfmC/qFMUbXSMP2F7u4I",
	"UBMTWbl7PBdTa64x5+eqgAlpEbfpO9XFBCUpk6cpmoMY3ZO7cCfO4ws7LHUXfpjEDlz/TkjuMuvomeBl",
	"b3erJlW+A9UdgA6jR0qWqWRNrqhq3UHpWV0uLVUXDHveTFcmtpa7kxFal6DGYSTWsuckMwxGR8fJY6VK",
	"Ma8ZTGT7dQJdn9baSVh913S9mLI7hoVT/Bslr85Mq3vcKXm48vhmVTLnUNGduFo/ucNzHIY0xruHs8Cq",
	"eKdHoeo6shXEKDxQGnG+w8WOpuKdrXUGb6+qvofYKldu/bdCsVAu3bhRKBZGJ27eLk1NZ/VkOkXLGT8J",
	"KVdZVUnY5YX6adfKq1SMIceJmQpNWXLc3+M/4b1gNVjjPALhGAguI7wXrAUPgpVgDZH/P8AdvE9YieCh",
	"AJjKfchOZNjCT7Qiej2wF6zhI9mfODoCs61lboqvMjrGv1B/f8RqeQtQDW7Km9D/ZxnGnDE+6Sd8iLek",
	"cugCXod7B8J8ENTfQ1PDnw4j/Bf8L/jvF0+o2+XM0iY11gUubJON4ACuMPh05/GIxn/BHbwDBmTqoYsY",
	"Mt+qx4M9hWsC7M4riKzwnDE3ynAKnLYoFhX4oS3cwa/FvstF861qVFXOVaUW30km+BfCDuJNuAwK+d69",
	"xIq/O4sOpukT+xv6lHvUuYmcGnG14uZB9OQqKEJ03LvQhG7s5DEOrD5W7+9YyXtfMJL9VDKR/bTYh3OR",
	"sp3VOzdlj+ZArlTlao+46+Yw/Uwenz4ANmtaMQNZ3E9c4dMD63Oz9E2hWBi/WflmYuq3hWJhZHJyauJ2",
	"aaxQLExPjdwsXy1NTZXGKtMTlW++LheKhcmp0uTI1PjNa4ViYax0Y/x2Sf4BJccmbpYIJzVyc7R0g9ZV",
	"Ksc4qnifFaswZtZN3xwn5Jp2PG15nUVJN5SiyJOU/otib9IaUkw2/fQbc3bBcRZPtz9yI+q+SNJvoh9m",
	"w7DqEgmkT6KW4DfCHbxFKE6wgjtFyhxt4V2EN+CPbYS3qPUDBPhhTBMzvgDVC1hKPJfVRW28gzvBo6Ad",
	"vBhE+AXh/kLWMHgUWnZQXyNCaLNcjbhHEoL+qiPcNLheM7wGSY46LdJNYhp2T2Ea4pcqxULLtv7QMsdp",
	"f323Zd4vFpoLDr1Jaxq+b7rk9P73T78cnpmp3fvN/X8QkSvUwyEyR6RDwY+gWVo7hc7DEqDy12UI20WK",
	"rqHb1qzpogv47/jP+E/4X/GffoXwyxCqSecEHA37AcGiaHsUbxF4NBBA2cO7KHiO94J/Fkxz/ow7wRPK",
	"zpHN8YoUknumwu5D2tBbUhjEE6qKo2GLCE7hnWCNawqPQDrZhPZhq8VGEDz91cVM9Vz8JCoPq29YdbPW",
	"byPp3vwkZiFMXDdoE4PJnQ877LhDQar5Q1cHA+4okXkhTT76xvIXJMMNhXtC6v1VN3eFs2NXnr7vuxwS",
	"bZJ1dk2yThw/U9t0KW26YjObcoysHCeIEQdKWEedmplxHV1x2bnsYrPBYi3Tb9OuqvuMFT3e43imaxn1",
	"2G4vw0Opw2lejXI4jqi2YnKiuhG8lBVQrZkYQ7UH2W2yNDVaujldKBZuj9y4VZI6IVapEq2E9/XzEQM2",
	"I6KeDvR65gO9yhs24xB93HGN9WY9g5tVsU2zBEFxCD1Q+7Hx8ujELSD3pW+np0Yqo9dHpq4pqX7a/aTK",
	"W10RUcHzQ0edOPzeMDw/9G5JjfLEqoDI8yk1kHddKvhjZhW/71JJ3Fo7MSpFN5UNi/OrmD/FCpeWSOnS",
	"km/ahF/tdaGr3l0IOlQ162LjqlqhMd+0a2aNzsZVq+6bbkZQa5DsGX+UVJRxhi9NT0YVAxInFRoIqzjJ",
	"3ltI5zGjSIuu08hpqeM6jVQ7Hd/JV8m0k1JFnHUMuxXVLS1fxjopNtE1hzGQPVvwrVNF3kqwijdBZRbG",
	"617Bb4M1/BpvAPQIClilxo454gUPeWzvzZip3jp+iX+hrnKrEDxqgxRGTIu7jfci9OvdkHDe4YqQnMaE",
	"6xD4pIPof5glYMoYolEMIvwf+BC/xttkeo4gtMoRAAcNo4J3EPv7kLoFbgcPgid87qSqIndEproE/eR6",
	"8EKwdyhy9SneCNZoA/ugYXxCA6x3ENgOvhhE+Ge47jykI6EazSPGMhyANWFUxQbVnwqVQJdJTw5D3Sh4",
	"U4IWVTR+XAXV5wGzEKfq+kxVZ2JfKvduT+H1UyPgx9FZiDg/wEPOZ0XzEiq+/PkXaYF/2J0zvXKAUFtr",
	"OnJ/7sj9YnCl4cufCX34G5yGlWAVRT69lCvbAcL0rOuUR+aRp9kK571Tdkd4pZ8rgwBcVzwIViMzqE16",
	"Q05Iy5vI/qmDeBR19E/o0vDwcJpsmpszbxhL7Cbpck9sekY5kb9+ySb3bdDGeyi8STqE6yNqaUCEGkJA",
	"BxH+C720457cHcFWO7zgidYFiB4K1glt2vh1sA7IcYj3aUSrqG7hFmdQTsog7I8vPkscbfx3/BP+G8Iv",
	"8L/h9ZNmbMiXp4FHSk5hsnvPzSALwH3Mx+C5nlOp0F+VkEUOH5CBhG32MTdDvlwMZyONAost37esCdFE",
	"KAL1yjsnY2vlS/zReyj0jADoAMhUyt4FRmuIszOysL2bsRfzCfqq3CAQ+1CUofAjfBDFvwPu5TmzfBKo",
	"S2xz5tzH+BHeAs5sFaC0DaQbLLEkQEFBm7CIjJXFB3iPRuAL1gi+ip+28eaxE5ZwJgIfxNxeKMAHDwgB",
	"5diuhLvc+U3w3/Aj/O/4/8U/4f9FWPx/x/8H4Z/wn/AL/L/wX/DPvyKcKfAToGoBfjSKOgg/X4FK7ElK",
	"86ojjX/iFgAhbl4A4CVruUvnFG99hS4B58IQs4guD17+nKDrK/RP6PLlz4cvdtcDsCMZdkJx8LpQdTiX",
	"VwzPfFcpoz6IjHo9pFLqjfZOG0sJyEsLJZ8/SdOpXv6pGAg+7LRbI3lnpWy9acoOxgNl3jXsqllLxlhm",
	"L1Ivy85y1PZERtV8YdvFPKofbdz2hAF7viDpfdrx3Y1c02iveDjSYq6ro6urY7HHjg85HSkHxxNsO8Ho",
	"lAVBz6uSNbxqgTIf8UaVNSvm7Pr09CTEVlBcTJmeZ8wrVMT8JhlBiAfEv4s68HX0JJMq8ZJC36P+KKaM",
	"vLxt1K1aFChCwWVC73LT8Xh99+M35gp6/t5mJt5ZxRwJ616qWb7oBZ5mFhxF1Kv0loAHKpflgvtS4m9W",
	"LUpLwvNuggd+aDmfjpvp6dQSLWWv8/vKsHTM+AsZi/KRJVjq7QqbJwVJhvMHB1SVwEIahYUKl0KgV90J",
	"UTb1GrfnnK7BifrFAC6ayzE7RNVXcAsLpD3f3Q9cCAOlTr3tE6oUUEVRQSpy9JGBarkSy3bLrXcFqhZ8",
	"I7FEZC7V+0CxpN33wKmvvV7V7quavp7p63jTYfbKlmOn6gRP6pKkakTRlwxqqpMa6aRGOqmRTmrUPanR",
	"1FhBdZeOjpPbaGrsXebAySB/KmJJDSnAFBLiO6YKjncNq27M1s14CITYdcg6C1K9ho+ohcheXK0uTOxI",
	"WKnqyIatZDaYVNsze4I23kTUi28Hd/ARxOGSbi46eJPe8dKlCh5TT8AVuMzYZOGz9mlcvivOkrghWHdU",
	"vW5YttVIxvaP9fo/gja4EO6H5kiqqRKHQu8huA/lc4hBRu9b2nCfzaNNKC9pDqmtBTTHTKuop+Ju8FBo",
	"RNResGGohtjyzNoJVqXIloVafO0HbWoVErSTsEhDl+3j3UGE/x0+3A2tt/bIwu7h3djdPp+n+JDb6iEP",
	"iryVZ9ayEyykHZf0k6XzfOs8333S+Xy82b3PZk5vzp1l3YqPe4izaV0Dh6Z1QCuyhHXVeTpiDDpk8Y3N",
	"RlqlU/TrbnU6LbsW3j6lBOnj36jZ8r6mS0/RNqanJb+TAOR8+cTDuONXDM88tWDoZzBKedbAs+ZJiM9+",
	"wuSYJr/Ak4K8dx2Uyb7ijanGJHRSNZbUKNJZI8oicmyU4d3IrLMUu5m44iypPX3DoJ1VpxHnOVjczlH2",
	"RsXAReHFFQVT2T5aCmK6KMJesNKT5HVG8IsweLfPcu1lMhJ8vpGcqk7Y9wum2yDH2Wyads20ZbudafoW",
	"jUVvu1KNKPUkWw95vtTzEB9XYn2UPb0Tg27l7krbioJRYVpoCe2VoL0SzpZXQr7dor0UtJdCgjgm6F0W",
	"YczrrfCBGpSrJ0TblPfHpvz9GnWrrLkV+zpt96eFxunXxfdHkL4FNDIyow3aF0t9d3Tusr3kWdnYmvae",
	"IuZUjdY9LifzpY5PTJqdQnYqmsSE92B1OzoyNVYZuTpdmqqMlMulr6/coKFmR0fK1ysTNyss5Ox/Y49u",
	"lMpl6XG8k2I3FJObXFptwaktOM+aBae2ruy/dWWcUEhEII2o9R5re7J0c4xSsPLIbfbHrdHRUrkcBsu+",
	"URpL9CZdgwmvKaFPDUXtsp3Vddey3Rq3AoPy8S5JbSonKIpieMWq1y17PuqgPF1cI4oapH0057jIa3gD",
	"s7QUMu1a07GAeMQ1NXWDqa5USSGusNcqeZXVXTFtY7YeiyPKmi2xVyoOpWrYFc+0axWvISfmMWxUNu0a",
	"Kje87jozqZZkn6QZT5vMLjOfGvLxWP2HS+yq49YqYVZe4XaZvEA30vLw8pKtWNZDVu6WdbqxJM2a23Ra",
	"kgacPulbmi2gFx54ttWthuUnry4YTfHAzw2+ybjGUFRI3rp3ZXMsRZ3j/DO1c/xsePQq5lIzMa3CSMvC",
	"t6i01EyLRpfUak8bSxnKbPaV8Dn8+26ZXZ+1aYbbIBpJOp8bP1ldjp9kMpFGnyHyfMVr0RrEHQoh6cvs",
	"hUoN6TfqlVmntlzx/GV5Sq/7jTq64tSWURlepZWerzuzRr2SZIeggmvwFmVkrxPqULAwQh3p7AzUUbfm",
	"F/wKhHVOGcwN8gWCKM9dxsSFFnU9/HK2Sx2tuumm1UDedSmf2ONQMnWj9xJNubzguL4ypLJvLvnpKzpt",
	"LvndV1SsI7miYh1pK5pgH9ThjLudE8XRmjTmLZucyynTa9X9Smpg8UqSycAvcQe/ghBcYlJO0PvuQJad",
	"p2AsvppgMxqmb/Ri1Qp9JMtCykmq6XWauABBeDHaF54YAiaNDKqHcDCpYdXvS/l6jvAuxCLdUwxWVh+q",
	"Q5jA+KPu3RFZdmk9vkvt0Z08qxn6v5+L1ZNj7oDmWB1w572sZNiDXCsXCQ/nYulEWek9rU/UhVwLJEqz",
	"52KJ4urZ97JIYidyLlPTcc/VKoXjfY+LFPYh1xpJiVvOH9ORPvz3toLpXcq5oI7rT7uG7RlVkIrPxzLK",
	"g36Piyd3JGvJ+Lwk45VbDUuOYPYfYDW0wvxPMjx81OOTc/WDr9CjoK1UqDhzc57pd7n0Zqk4j4K14J/h",
	"Rn03eJjaNPjlULPmx9yeJEd0c5iDsD/JKeezp5zfyBOvp8u58nVQW4O3Hr9/k5uOKlbImpOt2bpVpRR4",
	"2vAWT93//HixLyI5tasnQfRpyl11vntiOiXRRXGe3EZsGk8/sVF8Qoo8I0J4f6zWnqWstmI/Kj2NErtC",
	"a7/OovbrzOigYhpyeTOlbzp+r11upAcuz52gE8y6u54qWt2dRJcVXUnvd3dr5lzxKG3fdVTpGUfpmwyt",
	"fh9tpWi644q5VF0w7PncaZhL7HtGWPrl2JhvTGP845RRvaNwz+fAS/HMRMWyvArf9DkSdo57iO/7rLSd",
	"llfxTNuv1Jpel9rKpu2jsaZ36o6PH6tZyak591ViIcjBmw+lBSLny52HyvA1TyEyNFthMvGhut3j5Kkd",
	"sSXtfi8sLXURjHhaY6kSi5c0bSwhZcykU4vW3ndnymLBd3yjXmHnRxodeYHYflR7UUBR1/R8hQ7i2PGM",
	"fh1V+2spqZEPA/Gy+uKpzDVP3BWv1Uj2JDVOv6ClOI5WI5foJFiMna7VAZOU+KkMRSbuddsUyFW4Aqq/",
	"m9E+inZN7IcUK44Hn6bHPsltpho06BAaOoTGWTe61REsdAQLHcFCR7BQW3TnC08RfuXetarpORc/WhB6",
	"76qD41BZgc/+YOhYgowlNYLsuWoPS7szYxv37JswOlUamS6NFYqFsYmbpUKxUJqampiK/BJGpscnbqa5",
	"KSTEO5Gn7qET4KJRLEyVpm9NkcbKpanb46Olyrj4Y+LWtPBr9NbUVOnmKPiAsT8rpW9Hr4/cvEZGMTny",
	"zc3y9YlJ7jX2zfj09bGpkW9Gbij6z0UA9jPbsYKR1FxSiWyQEltuXlGyP928LEQLCgVTHvpH5PGJgOy9",
	"P1j+Qs01fjDCiwRVDB7DW0DfhF+i0Ag93Zy9b9rhkHONK1lCxjNVkqSJQ6oLhjtvxkvTVDKj8C61guPl",
	"k7H8mE5mnD1SNuGFuadjnrY823VWENpeTW84G5VQqWZqzQgKZ+wOCtN5NoVn1rO2GcHrfNX0oPXqTZHE",
	"byuXTC93CipQWMyZrmJE0/xVxmii4rEtGhVO25+n6RvMZ1TcoLK6gusXFIuatmu6Ep3kbMYnqBiSueis",
	"pd1Ai9QylZhm6DgS5BT/C2HvwTJnBUEoh5W0oNldiavKhU1hSsLEEGopwqKvPg7aSIqJDHFqiWTzGgxI",
	"toncgfcR/jf8Er84KX3G/wmJtRXZxfEO3gzawao6nE0q5ca/BGs0cvMOCwVyiPd6puBRLWLckLSaskk5",
	"EQ8zx6Kg6sq9QA2JBFueQxo3l+UCTwmV7vk5xTXSz1h67zwibO4Ln/wIogrskhFGJYzQvY1fi4ZV+VGm",
	"y9FQhDBJcbMj7XgVem9Tc36wU8+isEs7ZB2DB8EafkXT5ZPW13gi96fBk2AttB6j4VXIa9o/GljpeP1r",
	"NU/SuzBHfN965xl18z3MHbzYwh38WmkZJ/frnc1Z915lszvddnSO+uN8EH4J9ovP8RYLlL+L34RRhYIH",
	"SiLXD16pd2oQxs5SxHlSC8fH5zkiNoFDeoJHyJSvk5yzwsFagvsM4SkXt5CSciMmhnVJwZE71+dxxJz8",
	"WTDZqsSvyKnQkH5HXq/Hi4B4kF4A9CQV2UudaU/QuJ1ZKJYPmZeaaKVw7DmuGKVkFxk3g2FSTD5gacKk",
	"ccn9TWyaQuY2Uu14YUN33ffp6tHkzs+mvf1kYjOPTXY3CH3cB8LbDl4g4B4PQN1PiFN/exk7hzz2n8gS",
	"raEL0ALAAW0Drg42lOlPdoOHF7Oz7iSDRMbay39SoymLcQk0tUiuoyvUkQfVFCc5rAEuTtbwa7wRZZfY",
	"JB0KVjI7pTzpXWrdJQ9ZtoynmaTgeBlwhNihu/govkKJiNMnpBipJKAr+J0k7o2kW050IT3QTUIT80Fn",
	"wT5diO1jounwUup4uM3FF/Jf56583U6Lemiav0vn5FXFy+RNl8K9cw1+q5nvLqtMPk29ysqflPsYCbJT",
	"T7o8V4rZj5kECcNNnEThpKXSAYnXP8XzGCGkEGI3Q0EU39L4FxYEeI9AzpYgbByCiugVzVK1AcLSmmrz",
	"i1nhQz4ilkLvZxrNmjayyYObgvzMrvNTR5CVTl6GbGXxPp18eZpS2upGECJoP848Z9EL/DMtSZgfhDfz",
	"Kyyi6tOpSWblah5FqDabxek2kT1QHbwOFZENFqr9yMjfRjrYA6qGhEjqLA41eCB22zpJkoV/Af9JsnJv",
	"8wajTqNZwsE8GQHrSrO6ci+9Xklfm5gYKxeKhd9XpkqTE1PTZbifHi2NT8Kf5evjV6cr5emR6VvlUlnR",
	"qRTnRyZVcucV0XotKVSxjyQmhT9T1B3mOkzJZsj3XnwNoyoTeQ0zuquY6djX3QZm9aBmyuiIaCUTVZxU",
	"Lh+H+8oj5LOuhalRlNI+Y9uFkafPcvcZltvqYVePjN0euTlagr08fvPqxNRo6evSzelCsTA6ceNGaRSM",
	"PZI9k9tL39a5DCi4NNI3Q4p4hcn+57SrKJu+kHw5dfsy/4VoJ7mWnMn28vCXn6YlbMibHVoahKpb6v5/",
	"Y84uOM7iWep7rEvqfreaRAJJZysJhuSnFvwkkToVZAKa6qZwpi3eifH+Ui9VQ1mw5nJY5mR1nlnrhJYH",
	"1brj5ZQ+4cs0B8u641n2fOWEnhX9i83ZMN158PiEAcohENkrBCNSsrGx4mKA/JRqEIuH3zdTb3qhcNIJ",
	"dZqmnW8+J+DLvjiB5XLegr0suW6ZPYaMmTaWchvQ9C0dv2hJlTsOUab1iyrEAZ8PkUBEZz+NMpzEPnNi",
	"snSTatPIX/Bo9MZEmYXGvzFRlm0zY6snr8cHrUZTi/vUlk/WY53Yii+S/yMzPvYslxj/LpR1ScWbQt92",
	"inq6hHruFFR6uRVrp2oO10XataKtISvc2KS44VJ0F3njBzk8uWmUpQvPndvrN4XFjrsPJttM65g6bFjf",
	"mCPDW6i43C/5q+5eAInoZZq90uyVZq/OKnsVP+FxEqSmLt1okSKkwRkiSLSDecpamo5pOqbp2AdIx6Jj",
	"nkbRFDQqB1nrP3elSZEmRZoUfXSkqAvpyeCjHNeH3QlF0hX24Yjy5m8TLbBFu7jfD+AX1GAdBSuhMbkY",
	"klmK2wt2+m2E9/DboB2sQ9LdDmyhRatZEdLTV6oLZnUxKwhBedFqIiHTPxqFEspQBNFEKucnbSZzpO06",
	"7SRWp5nMqdccTHdiE5kr91LyhvCkkYp0UEsd1FIHtdRBLXVQyw8kqKUORqmDUepglB9GMMo4j9ctEmVi",
	"Ss9YpgiKgBU5wy3DxTRI4tHqFgxvQSwWhne7Tl4ovbP+0DJ5pIC7+cY8RctQcn83dfC8as+at3uruAwl",
	"UquleZ4rpus6bqVhep4xL19n80zQJfIF+pp9kVWXPNlhBWnB8FipCCYSJdNdkE4BiITN3Fu2D6Hg+6MU",
	"8fMrHk3V8bXmbcNvuWbPtqrXqGXqrd+W/luhWBgrTU6Ux6fL49cgKNjXI1P879EbE7fGKuTHyPStqVLy",
	"SeVyoViYLpWnFa8+lcYj9fV+saANZj5ug5kP2bDkjsRZpsKncDzTwhacP/isGTSjWNjX2WVfhWxjhpg7",
	"653DMNCiPP0MCdf7APbuk8lANn02hZryDlyos9vwzwwDYtV6HN14LefYNGvTZ9YmQTazSetJDHsjN3nC",
	"ltBYrKUb47dLUxlxWWVjX+W0x6e0l4Cs4N42MVki/NW3zAVO8IYjvaZdZj5xhWLhxkh5uhL9vDZRmbh6",
	"9cY4dH6k/Fv+qzI6MVYqsw9usvdjpRuVWHnqW1eZmpooFAvjN69OwJ/qMfMdQ7eB8CLjeqq/VDYR2zVe",
	"/Z34ZlX0UrHFbht1qwbLA7RJkQXTqUo6qbSrmsINp2rIPHqogGp48yIRyKB//CSHPCQQTLVXWDxVpVMt",
	"0KbYl8KMxEepmAjmRTRuzzmcsp164shFU/K9/K25rI7Q4PkMW3LdOtwwPJ8hTdrNg1ClAq6ECjKWqm+3",
	"0zENaV4nsJjuh8ylsOLpy5m99qe+5no1u6+meh3T189zPadSoUhfqcw7Ti36dc1xan3KYpglVp/C5e5x",
	"pJ147pu0nDdN15Jjzk7CA7UTB736CW8ge0/sEq7BFcMzJUdJdlGUdi3Z25VIT7Y1i/4fZT3CLfrkvQjm",
	"Nl2mJl8EbkejPBLRju56FPh13fs7DeZS1fLMCqvcy8dKlKAQusILnSznTy9326dwfvLvNHXsC2lv5NsG",
	"IHpVW67lLwPRpPPOLK/+6zfTvrNowjUHbAvQbZmGK87Igu83C/fvg8ptzkly9qOOa6KRyXHkzKGyM+f/",
	"YLgmonakruHCU9P362bDtH0Uevd7wkkB46hZZ4nUUigW7poujahXGB68NPiPv/m/LpnmJfOLLw1uEGg0",
	"rcJXhU8Hhwcvwx2SvwCDGjKa1tDdS0NVw1sY4Nav8GbeVF0x/gwZcmgCdxbahGfreRu0aWi+LRZZZw0f",
	"saTq+Aj/Ff8V/1yAvtDBjNfIIpi+aEHrjTSt25ekJ9dMGtHcNRom7dp39woW6csfWqa7zBeYbJlKCyw7",
	"vZAFEWJj77IM7vgQbwQPcIcFBtylUWbfkJHQWEA8RPQF322ZaADJAf+kj4sILn8TH22yHwfkE3xA7z55",
	"RqOOkJFogAaMaV9Umqyph8kzykejDPHk8ucQKcBqEBnx0vCwEFHxBiuVTFevboXlq1c2MwzhB2grQhMT",
	"vIiqjdguosGTOpIRINk5HbyBD1GwArO1CXEf11Dwz+RZGwwFt/Gr4IGc1WmHnIAijbBzBHuTxXhCv/56",
	"GY2CWRYqj/3216CoJWeTUy821m8HqAnhACNW4pDPRK/5DMc7miB/ih6HMYUhDhOPowkDYN0/fkfvXhq8",
	"PPh593m9zWhT5tS+m44mpjLqW/fZ/Am/DZ4FjyUCR/oldInFUH6REii0gzeZEewu3olMZIOHgAXJivCb",
	"i+mzO1Ktmp43QKXe1Jl9X52OZlrqZ3yW70Q6UkCdy8PDYTovlkCq2axbVDUy9D88J8Jdo3t033nLJgzg",
	"lOm16n6FWuubtYRXV4VCtTxz5Rb0e64FFjDQQ4Kln12+3LcOXp+enoyrVhQ9iT5B/JuIQQE8TLAm390h",
	"M+u1Gg3DXaY4iyAwdYirwCbPEzgthOh8h1Ss5giGDG9xgN0FDYSsqJpH+BMBUHwQPKTG3twIPCSTyXcX",
	"8B6ceulAH+EOIDWhCzQt3z7ylu0qgU2I6UdjvgITchWA+ALDqIu8sWm3ZV6csQG2j/BusMoyPxwmArQF",
	"K/DBCnAwiUQNwMOEAdpp5Hd2Og6DH4HMvMEHCCD+NeGOKBsEH0DgPugBT/jAeIwo+h4pF6zD6XxA81GQ",
	"fwdn7Oj0EsB5BL3dgaOqLpLGaJD+kh68AhMs0jAZ5rcDN6yqaXsmOZuktT/TEewEaxBdf5VUTHiiTUZM",
	"d+nskBPfBpLxTCLA0STv0IQfbL5gDYGeRChJlxvhdfwS/zKIZL6StBmV3qXRCenEv8Kd4Jk0rg0yu0F7",
	"xqZTQWYId/AepUTRnEO4QDKFdAPiV8FaEQVtxKzUoM4E68r7zVY6wfrC1oQQfmRzzpu+fEQGEf4zsJpk",
	"6jbxIdm5Qph/tlasB+szdhQwkc49mMc9l+YMGqKzBikvNxkrG63DTCFhX0f9MPZnChcR6UrwBFhS2ON0",
	"iwJnfATTF0bPPuTNhCk28Q4KHpGKxNU5xPuD5MtDBDPxKiyXGM46gh0spzo4ogu8hw/xa/qcNCRtOLIz",
	"/xIH9SLCO9D6Bpna4Emsz3RuyWPSXuz4Xxoejp3morS6wTrex4fRZzzSNGfr4Wd+GjFj8wkGQ0fy10H2",
	"wUf4T9RkMjHEaNGCR2FeGWF8wT+TYmSQl/MPEjbaQ7LN4KAmx0GWb8aGutmkdOICHjvxcGKAlEQriMAb",
	"6DV1AmLjoaIX34v0DIG0tAcUalekkWQJVRPFUeAhHMBdiSgQAq+gyu3BhAQ64i0yY4ZRcmSTAmjsA6U8",
	"KgMgdcshQjxQAeQ7hDRwRi4mafH0FwpB69Lnw8W8VUtynyihCeHhUgvnlQoJ+qq7GnfMoh+qZFotCWpJ",
	"UEuCWhLsPsvjY2hqagKNzJu2z48WQMlGCMQCb7fLwOEweCYo8fA6z9DxFlJJsdDLlHvbCtbIi6AN30Pq",
	"joxJHjPvWlVzYHwsY47fV5ejKea9rKlnOGVsghxQEJXoNJZ6UqEaL5FTqv+IBewRb5H72oFhcc/ydUJ4",
	"SJevf4lJ0Nsq2UQSaFUq+VA8TcoKUL4PMvCMHVGOPcLy0Sz6PQnBKEIEQonCgQZrohy4w+RAvIuOIwY+",
	"x3uAKdCZA6iE8MIoWGdi8SNyRKmkuRZ9BRkkaXNHZJxcitzMJUcL0mMHJdQrVOoRsDAp6aXJeWlTAJJb",
	"YgJIG+IUyFuJp6fMEv7+BgRulaeM4xgBYnwomrCsmzO2So6ObauNYI1QOjqZCZkYbluYtEI1BR2WJWBX",
	"HMd+0MavUSTFwzkhNb+lHY30JI9JdWFOv0HVJVW2iBD7IIeI8DVh1406sk9PVOjaRB6RoWsl+rJHs/ia",
	"xdcsfl4WPxcD2jeGMzcTmS9KBrs/YrSeRqcgFD9hNRXa9l8zfZktRCNNC92+FLuMUXx3TSSvPAL+x39J",
	"1V8eeiBM55vbmmUvPBRheiiRvQUF5RbhE7qxCaOk6a68AnyVg2HQKKpRVKOoRtGzoMbpC6wkiCAPpXXe",
	"QA6NMrHu2FAHNtQRxqWh0rTVMLPwiLzPg0T/iTvBSgwVj/Bh8Bj0CR1ydEJzS8Sy2+2miLRzrtOgfhwZ",
	"5/G4DWbHFnOdRopHiIKOqbpAlSvkLD8GZdTj8A46e8y+c6wR52kuc8TTTv7xam5Dcxua29DcxsfCbYiQ",
	"J8Ddh8htKDmJaUbqe2IhnAEhlmTTUYaU+yuk1pd8GDZBbb4duX8cwu57DBmVX0Q3mWCHEyHYIMIvBZMz",
	"2aRQMGYKb0UI5WbmYZLBEdnAMZs1sqsFFT5cfnFTI6HjQTt4QE4OWIRu/jp4jne4YRu3G2NXKviA3ruG",
	"NnjR9QG/mBgIz1/KxEjzINojsUzBCZu7t2D7+Ch4hl9DsmdhQPymKWjjDbiVoV3B2zO2OJXcpyWcQ0QW",
	"2WYRQGOMocM2zwj4uCs4Q/7BpONp/YTmGDTHoDkGbcjzIRnyHJMHg9AoV5zact8YnghKeNzk+/fvn4zd",
	"++j1RE7I3I2EsRt7Ze/sU+buIq5mEOFHoltIgsFhVkgRowV48FBpqwLNgl6Dc3vQatAuUneNTSBd29wo",
	"ifKZAqc5Y+OXzP4fjuQRsyM/oN4/G4SDU1oKUfcJ7pfxkCqU4tXPFICqxou+oMzjBt4Fqik7qZBpfBA8",
	"x1uU3ZUHcRA8p7b5+DXeRsELUhXV6XQosxg8JsOfsZPlpLEF7WhsgJlvCADjA3CD2Me7FwcR/gmWL3IU",
	"Eq3nE5yq2lkE1uUt3Q0KLjZrYQdVXKjdhQm1NQ+qeVDNg2oeVPOg54cH1YxhFmNon4Av5AFp8lrEwEnk",
	"Wb34kabqtTCuC4oA7BlorfYTHstgyL0Nu/ch94EUaMErYFQA96DGwW6hYsbtOSfJLpCn2ppGcwqaU9Cc",
	"wnm936KozbNQftj3W5KZLCLUvVe4a1r2/IBvLA14pnuXBZ1L0Ya8jN0TdVDKNRFcZYUXU8+pVxO3FpWL",
	"JEIgrDB3oLVgBbHI0TLOTVr2/LSxVKbdTZOL5a+0dKwxT2OexryPDfM+dlmOUHE0bSwhRsePKdLdk3LX",
	"V6za/X4LeN2ksSRASbJaLT2KZ9PwFwQXx9hAMjdhWmjnGNNQ0xaPGh01Omp0PAMhKVNDUJ6/CJS5QM4y",
	"3SGIdD0gJYJRejpA8v8wBUyISJbpym+0flCjgUYDjQbvHw0YeQopE08N9pFDAZBjOVkXBwJqnrIbPFBD",
	"geTndlLBRjBs4hGJwlA6zPr7Me5AbGLWKdy5mCYIWaY76TpzVl0Cnq812Giw0WCjwUabrZwRs5V3JdxZ",
	"502us0wXMQTsAdC9BWvO7xumC1EG4boOYsDBnyeE9jLppgjs8EBju8Z2je0a2zW2f/zYDgT/G8tfOL+a",
	"W4LwMA294Ls1b1t2hs3Nn7mXTR6EZmamW/gQ7Gr26WYju4tspVfkgHKXGZY96JDQhASwl615e9xmY5Jg",
	"HbqrrWk0sGtg18Cugf0sAXv/vZIFoj9uF+7L+YN9t2XeP33dP91Z0wR5OafQM1cx/GlfuYpUXmLcvku4",
	"CVR1zZpp+5ZR986m5TBZUTRuc66lZ35l0rJHWX7u02VbjgjpGWAxZdcyXWSEfFjBQ2WyBJ6qaxeo40xh",
	"5Frp5vRMIZv7uW0ZbLQKPoi+0OyQZoc0O6TZoTNnXKwZr4+B8eJgq/mvj5X/QrctA01aNsQ77pEZc1p+",
	"Bhv2AsKO0EgvQibn7QhscnFnsjUIzaBEThLUCQl3JVKr5KgmWn6KQslp+ZqF0iyUZqE0C6U1Smf2quhz",
	"7ZcWA/CJlt+LBqXluqZdXR5yDT/DSnM9TFIYS54vJAmX0pRDMLO9YI2QPwgvBgkpnwWrNNIYTXpIzt9b",
	"iCDSFqLyxiLXMXMQCJSfNPRg3Z8yfJ7hT3iS7r4Wi+1vVH3rrqnO0UfFHL4/8Z9BxUPOwwPI7BhGdOMB",
	"1C5AUu2L4ehpIGBh/DBXNJ/javAc71DvczbIYgjBEvkCE5lgTcrqeYH07KLO162ZFM2kaCblXTlG5Eq5",
	"JxLh7Cx7/EsEFDxMsyc+Pa859eSpkbBcgasZsD7kmX6rmSGP/yxiMU/t2yGHOXjCRXB8EDxNx7Su4D1j",
	"z9j4JcFOIRO0mBM5yRSQjgxBYNNY37ZYfH2e7+9hrF+H9A6Ghl8lfyUlfzIh2bwDfKIVABpbNbZqbO0F",
	"W/uvdwdSBFRKiMPeb6V7H3Ed+psL2emXjMqeK4BXzdFJIP4e/1mpOjWzp0AySuzlvpUMV9eEbnSXxBNg",
	"yv8edWpm7pgy4oByXTyGs8kvLHT0GA3dGro1dL/veAFJ1Dxv4mtv0GYu+aZdM2sDrtl0XN8bmnecmicK",
	"sPFsFE7Nm4JvAXpKrDx95MFrLcppPNB4oPHg/YpyMmW6atUhKPDpSXVZfZlszdatKu3JtOEtnpdM7gQN",
	"EB22CEt/xYd4J3gC5kXsSnIHqCYReLLh6R79o+Ib3mIsjGdCTorm+8ryeE0FV9EX+QNwyh04VvhN2iwi",
	"7ergmxouNVxquDwb4tN5xSnTRyJNvrLMyPIpANYQ/T24VPeWuoPXt3VvKQ94RV9rGNMwpmFMw5iGsfMM",
	"YwQJTgJjoRZQfbPF8wC9IhsFbyHqBAK3WXD2IHvPA0ggTPcN9b1VXWaBjAjwBn+lRAxrumbV8CNwSvTn",
	"MHgSrOE95kh8AAR7E4ylL+B/CdbwFt6m2Ydpal64dyvSJ4ILDOlssIbfkH3NA6R0qBlu8ACBJWt4LmN2",
	"rXYXDHnHXeSnMAsxeptUsE8inXhIvbHBJvkdTe6s4bKrybzz+656y+f5StjD7nASdTVxPFSD5z9zDD1R",
	"H+/e71gd3Tv3CzjKr8qeBJBsnO3YoJ3ST8etmW5ldrmSOApGvT4xByc5OwW+U/PGbd+cpxRigtQH3bxT",
	"PE4vexsdizDQbWyJbfgux8b72NvIjgjVx7sU6ruNr+l4lh/n2d7lGOXeRs7SsQ7XrYblq70ILn9eLDSM",
	"JavRahS+ujQ8PBwdgxusFDsGFums6aa34szNeWZKM8PFQsOyaStCExO8iKoNLQ1paUhLQ1oaerfSkDFv",
	"2YTPmzK9Vt2vEDoNthGVcyERASyJUtBflLJKJ848JeWhIXOJCFdDc1bdHLqnuIFKt/8DJ73gR9zBb/Bb",
	"BEb1K2DC/4Ce6WwxqQTtwkCu8vwJ8Iu+IM96u8M6idavN3Ufp2fUQwBiLx2QQ5U9A+iC/AEK1hDZY2ny",
	"QXWhZS9W7FZjFmhDDvrav/6EJpGkD+gm74OGfw3/Gv41/L8L+P/YYZzCHEVydDWWP+HEcA5g6EFiqWOh",
	"upivnFBGvIU7weOgzQTa42M9qK6hX3HEj96cVdzXyKaRTSObRrZTNfaHpKVABjnGnZObPgkQgTCzxIj9",
	"xMV79N8KmLSQQ5QBiv8mS0ey8AR76xX4tbcJgeU5iTaRuVQ165zAVr27WWgYx0D+X9a5PKmG/oZ38VEo",
	"hhPSHgPnr0gneH+gc/x4yjgan5lMQM2nPY8NZ5qcI4Xi/DhD0AitEVojtEbod4/QE5yYXzE88xxjdH9w",
	"2WoALpPBL1eqC4Y9b8Yk1vQgsNSkgdBFaANixh3CKSU75infVFKAtG6i6nhDAOdmfXmUdikCavqB+I6K",
	"q2oHQS2vajTUaKjRUKPhR4iGFAqYxAqIgBgk9BUbz5YuVwBIlS6Xvta6XI2NGhs1Nmpd7vnU5UrI2Hdd",
	"LsPFVhPCHqSLiI/wfqr6dkdUKYLfYgbQXXWdhmykRF/egh7o0DAacTTiaMTpR2iYRqvuW03D9YcImztQ",
	"M3wjP30n9VUocawApazMuU6jMmfVzYrRtCp3L7HH7BtKQCtAPd9x8BgtNnLLH9dp9NH85x75J1s+jPs5",
	"CpXCIdlJ9XxMc3UUPB0dp5Zf2mN9PZa0R1rS0p7GXo29GnvPhrTnuZ5TqdBfFQDa6FfonnJuvFNOCmfg",
	"vOllBZMBV0yqeaR/5k7XRAadK1mT0qNzk6YAPwizcpO9zrWsD+iTHXCrjvJTPU1Js6Tqnccl5R6Dq8Mk",
	"MDH7fiIcempjTnUx6QDMZ6BMXmfEw9ZerJpl0CyDZhk0y9AXL1Yg4efIjZXitsgqvJCBkyBu4c79YpqG",
	"988Z8U2CR3gbvxESTsL5xBuw0eAOFAyGdpItFmnEBnrOCaqvI7gh3Q1W8CHeQ598Et+GUB/dc598ooD/",
	"orIdSjDwJn6Nt+EDIpcH6zwpamS9tIkg9+YKbON98mQjWMNbwRohLjwZZBu/grRVQskZe8b+nobBsGrf",
	"owGEH+H9XwMtUo06eI73II5MLEdlR8q0Jc7fniIt9kitlmDNtIpcY67GXI25px893bCXmWNCvoxUrmn4",
	"ZoS7Scmp2GsFdwSJA4gfEiT//mrYexzsCYaZMsAwZ9dIrcbQnGfqYr8mw8uFj5iXiUbfnZdJ6DiGqnXH",
	"g9zZTcOvLhybyzmEA7dVDNmcI6boJ7RzJcUULM6R4B30ySeTpZtj4zevEU5mE33ySfnW6GipXP7kk0HI",
	"wvkfIT8Vmlo/IxySRCV2lNXjfdKJ53iPsDAHNAYdZP0O2niDMC8o+JEgJd6DxC5tvBOZdg8i/HeCA1uU",
	"N4NUoE8ZIxQxLdCjKAtZyiAhhXYHbwG/tRKsQaS8PQrk+IAQwrVUfoxgEs1nto03gofBGkQw2wzagwlO",
	"aJQs7E3Hv2p5VaNu/ZGSCYEtgg8mYdVzKa44K3esGxNoUl+ZaF5M82KaFzsjxuMCV/GRswhA6tFNx0ch",
	"GlCW4VgcA1Cf0Cacw8J9iYmQsehWswaJNElB4aZABCN4Rx/Dk/FaFjTJV/nvEpng3gW/6c7NpEU1Nn+o",
	"hJcsJ3VxTsyoysG5lz5rNNZorNFYo7FG41NEY4qGnG5Q/ElaqOeFYyuKD013VN30TcXeEiRntlfkiO1w",
	"JaDYaAnBcgxaEMJSCzAuPKWfab27RheNLhpd3jO6JGjWObH2puNGwsDz3HerTbeTAHIYOfuKAPIj7JD9",
	"KCwVXBGr9tkzlVF3V2TJE5hKw4qGFQ0rGlZOF1YEojRuzznnKCtaj4jCLaiqRr0+a1QXYSXMmuVXqO6O",
	"PyeP7/1Dy63fHyJvB+Ct6GQro4Wihkql5dYrFeFNk5r/nEZGdGEWSjWLGoVPmVXTavriXnh3nm05O/Rh",
	"bc4oAFjNYmZ7aJRvmPuKavA6JSB4XzDAg3xleJPqQJkBPSFcEYG/NXVDuJgFGIb73V3KwewiuNAmEvMr",
	"wSi/nXLNG94NH0Cd7WAFwOIAH6LJifI0LXWEd5khYHiHzO+XwZzumYqjWg+e0cvwv4Dw3oHMbJKXwA7e",
	"AIxr41e4EzyLIIwR3D18iF/DHLyiWbA6YOL3gIz5EO/BOPfxIW3l79HlNHkPJnjCVXQ4DDIT0uwdMcXz",
	"AS1IIfNNGBomOQvg/wd32rw9MgPc6I8sBjhygBKb4kmwEjykfQ2ezdjkRdx6Mm55MEBzfqHLw8NFRGDq",
	"AWksaFPLgH+OnCmkr8PVnGkND39q/hP6bHg4ZMsg8QXhhh8Hbehl3F9DMBpoz9h4g0Jg8ARvo8+Bq4NS",
	"B3gLrv7jRZ5m7CU23H28i9+SaaMr9hKcRHi/YlteMkSIb5/gachlwn/JmYFAElecJYRfQdntGF/EBvAA",
	"DtoBXDQAV0V4AtWKCCXXZuzkDDELCWbTKhnRFlmqR7Id6LhhB5NjQkPuse0MjZMP99lG7wgGKUEbbFlg",
	"YzwGLoRwFMFKZLIB+5F0jZq+4IPEeMMJ6oBVCZ8i5fTzSoRNwVjHXbLukjEHhIegPJLUGbJRH+Lt4EmM",
	"I1VPBqzrK2azs0qO6Vcz9vfffz9jm3bVqZlXDM/84rMLMzZCCF1vGNXy9ZHLn3/BHpD/zZv+lWXf9G5N",
	"Xx34UnhO/seAtDLr1JajNxejPz2z6pp+ZdFkry/O2BdZ+wPoe7EL36MBFPwIe38PTvTzcJ2CVUjl+UAk",
	"qG0yicEDxhtGVs+ERNAKkUAqV9F3P1iL1p0LC77f9L4aGnJbg+RB06xZxqDjzg+RX0O04MUidC6aDLlr",
	"eBcWPtEpviiEutFtvAuyGevbQfA/g4f5unH965FR1glp8hX9SJ2i4EHwHG8ROgBEU5ywbUp/t/EWowYi",
	"JbhAvmapEAVcg/Yv5us+/Zb2X9wg0H3VfoaTspNMEhoekugUUyLCy67IR2CL1/sKH5JG8CYcqu+XBlg3",
	"Bjxr3jb8lmt+X6QQQWQPvA+Hn8IYpTgsoOcDOPBtRAluqOJIHDw6kK4kJqIuILaDybywcXfo+IBVAUP8",
	"2NEl3UvadpVzaEm01btWk2g1iVaTnL7Ve5bgJ1OqSWMZoma9P6l43J5zzlnEl3Kv6prMO+YUvUy3uwKl",
	"6Pw8w0I6hsa5bqZDlYcaEcPXGho1NGpo1ND4fqFRK4/PXoaJUMF8HJT0lu1q+l3FVIvm7/fKy3Z1wXVs",
	"649x6Y280diksUljk8Ymnee2HwR9qmVzX+AY2T0OgZd9XTJDgwlUnbmz5I1Lqd0sNYpoFNEooh07Ptyo",
	"UrlMok4UbyG8EO93vIXRkZujpRs3SmOffJIMKWDYVbOegm9n011TI5xGOI1wGuE0wvUnkAAgwLFUZPMG",
	"F72G6s68M9i057OkqNGW65q2PyGUu+HMOwx35IeT9rz2CdFooNFAo4HWmvVJjmH0F4m0FhFiK5L9lxD3",
	"7TB4TO3fyGq9osFfIYAZWHRm4IBLL5cGqo49Z/WKBvxmyvR9y573EsDA3o9C3RoeNDxoeNDwcBaEhRQS",
	"dY6cB5XYwiYDcYLeR5zxGt7ArFWvWz2LHOWGd4UWvGLUieyTgJnoC40xGmM0xmiMOVsYw4jTeUeXcsND",
	"bCoQI+V9BBjfXPIrx9RqTZtLvlKzxV9o7ZaGFg0tGlq0duuUMYIQ3D6ouJhWy0tPgvxzMm4Wz/C0R/bR",
	"Y3Cob+NNSL5Encz3cCd4yFIWsO4cktO8g/fBzXeX00xKTo/A77dDLQVCP/XgRxZ6gGY92KTu6vgweBKs",
	"4b2w6GHoSEwDOOxTF1wpPcJTHmDjgJMZ1gbE2jiALna4U/0BjdGAX4PTOwQjpq7y/4fHXFiLRaGgJTrB",
	"OhnWHnjIbiqGrPbQhyGIQ1Kt2nrwrDhj82P7JMqssEsmj4we3LqjmlLaYujVCVaCFXwYPBtUxTRjwi3V",
	"UvIfeVD9fyem/I0w5SkxpucgyHcysWavdXN6Q4OGZ2TiTCT5ju+gHJ32TNcy6ln97VptmDiUV9W9qy+Y",
	"Cz05VWR3vBH3/yHeQ7CosTSsKSNIz+w6Z9Q9s9ivtvkwx2h7eVO76tSomsvVXK7mcjWX23NqVIbY5yg5",
	"KudRRFb4PwlbinfV3O6QUasNmEu+6dpGPcMzfJ2lK418wBm7u1aMB9hh4Zw2Eds8B0E7eMKQMp6SdJMw",
	"eT/CsX2DD6i7+WuI29IuIs66r9AYWOR7GpKKMpSZQWuhc4MzNn4h9eG51ANS/QY1wOXe63ibPKHRt9oI",
	"/Nh3YJ8/pLF88C66gHeA63pNfsHo10hVLAEsy3GKdwcHBy8OIvw34LAPwJB3j54WzrPRFKyPwPKXMMav",
	"4hHg1oGBj4Jt8TxlwXPyCobIIums45f4FxgM3kE0xBjPhcbi8NDMrId4A/qmSsBaYruA7SGJ5xVea09H",
	"jfca7zXe58T7xCyPj6GpqQk0Mm/afqj82Af61GYSLUOQI+5MAXTyWahqQBfwOu35BoQOi8Vu3ArWyIug",
	"Dd+TAW9mTPKYedeqmgPjYxlz/L66HE0x72Xt3cU5GDXq1VadclPMZKte7ykS0KW+9UVk5M5FYlgOtpyh",
	"y8/PVQ1vYeAHy1+oucYPmSzdL8lAhMBSQBhCmmMmeEyYrlcQTq8N6U53ESSQZ7H1IM/qYxo6D+F/wy/x",
	"C0VGU8Nb+CbskMRWyK80Z6E5C81ZaM5CcxYfO2chUn2GBe8pxuC54izIByia+R6YCrh3rS4PmEvVBcOe",
	"N4/BVhC4O8Qb9BKQXtl1gMCsFiUKQ1O6q6jJS/xX/Ff8szLkPhwSuG88CtaSPEiJ9VvmPtio+EvNf2j+",
	"Q/Mfmv94v/EFE1RJA+PpBxDksJYbET3TcGkckBPbCvVg+JNlo1KGHkkARx+d3F4lVAycpuGK2MhJLFgE",
	"AyJIkULY5oc0TQIkDeDcSMpYZg232zh6bIUP5kpYc/eB/G9h3WOBl5kRVZo5zoI159MgLVnrkKNy32x4",
	"yogucucF8x3StBTixXBdY7mn8TFq/QpoNVzyUau5vdQBz7qGXV045oi7NNfzFFyBzpxwDrhklzLgquEt",
	"VFxz3vJ8Ho6n95UWmuh5kCBFTLEO5BwrI6bUUoom8OhAmhCaQ4temqaNeM51GpWa4WceytwthOMkNQ74",
	"FuVHOcFxnQYao011P6W8TXrFC1fM2/ymtcPNHrPH5ju5R5azlczxTTv5R/eR2tgliTlNXMa02RCCS+Il",
	"NyHb1gqNZ/+YcQVpxpD1uYob2WDkHu+xexHZTtbnJOsPbV2oZXItk2uZXFsXauvCflsXIipY9iIt1+vH",
	"VBmDkRyYHr4O1oainJTgagIfFxF+wxXAoquL4OnDbODYngUjuj0F5T3Ch8hsGFZdcYntmoZvqkzjwCxC",
	"a441SmmU0iilb64/6ptrbQn3bu+rAXR7t4Ej7MaAMzdXt2zzrPk0bJLtDoI+wn/DL0OCw3wHWIZx0OnI",
	"Vv9UC8BM/dMYlAk66DQ+hb3W7IpmVzS7otkVza583OyKjAaaa3mnXAub/ONwLy7ZKb3pSwRgi8zhQiXK",
	"Jj7A2+DcyHYrOwCbcE8mvdmDy+3VMMwI3fNhVdzbUVn2iMV3OKCemxvBGs2lv0nvNqhfIsI7hEvaARDY",
	"o3n8mU1gsFJEVE8D5yzR62TBI6CcK2nsUJlOpZodgleaFdKskGaFNCukWaFzormhVF+zQe+KDWIzfmw2",
	"aID7Hrx/fojGPnvJKMsBc31MdVeAw5Lm89CFY+FGwBmcC/9EczCag9EcjOZg3q/XQpwoaYB91wDLp753",
	"pL3H/oplyO7u0dA9AFOGw4KEaezf/Om2oy5npiM17OWJOaijm3nzPdKAb7qkqf/+3czMDwN37l26dP8f",
	"kp/eic4aT34xXtN2iRp1Nepq1H0PdonnCvQEM8TjAdwQGPiJwqQMUGXT5gGPpp0S+VYNVPBKLXtpuNJw",
	"peFKw9W5FBKT/oSU4CocChuWPU6/vhT1DOiql/Qp7Lfz+8cOlATHwuR80w4q8VU4BmQu+I16L4Lh9emv",
	"b1BBcBtvhRb3bxXW/Tv4FY/ggmZaw8OfVg204Jpz/zRTWPD9pvfV0NAfjUXHHnSNmjE479wdbBlDdeMH",
	"b8hbcH4Y+uPwl59eHrh86b9Mm0v+TAFqMNn9MLWx+/9+bH96+TfMlg4Nfzk4/MXg5eHLl2hjQwYtkiWn",
	"XvcbKSwAefNhy6tKH0ar0aybmc6LvDr8Z1i8PUrMBOU7o0yH8KAdPKSPdgE2NkMStgVeycxJvrunpmZP",
	"NHui2RPNnuSRpn1zyQ9hKxpmvKIPjgVQycGI4NAxkb1Zm+sF2CfHrn40uD5Zm1PD+mRtTmuhNW5q3NS4",
	"eT5w8yOAwMna3HERUMr82xUB2cz/GLRpLsfIUC4LEiOjZrJ6cF96yM7NAX3yoYCmPZ8CminZjj9U0PyJ",
	"n01AmNXgKbj54X28iQ+ZGEsONstrmBpN7gerBkNXyNKfDhf70KgYoEcIpHP5siClH6PaHEF3/h/I+blL",
	"TfqPCA6wfUy28j402Y7CGQYPU2aoaTRNt5IxT59/WexD0+E8fSlO02dCwKHj1NrjNP1uaoCGCGSVwjmE",
	"SFarPFEsPZrgK/EqDJQIkemehBXtSt1Lmdc/QLDBilc10pQ5//h58X10Vt6xytk/raZ1KCnNLGtmWTPL",
	"551ZtuePySxTUOmJX94JI1W+Dpliib4znVEW1/k7d9SpmeMNIxbAP+Q+fwf90lobDUQaiDQQaSD6QIDo",
	"dy6EdkdA2Y8JSR61NknxDCP0aAucwN7yqLo0bW6whm5bs6bLSVP56zKLxB8GpKdx3Mm6vcXbwY/4EB8E",
	"a8wHDLISvw3WiPARz17TibmDHdH26T7Zg3vwzchcfgeOM94YYAGOV0GaUcChYJh42zLKDU8NheWGp60S",
	"NRBqINRAqK0Se7GfHzPr1l3TXSYE9NRS7pwrq8PbloHKDe+YwO6bS35P3mirIEiC7Rlots/XzQypWs0R",
	"kDcfk2g86Vq2jwzXNBBcGyDLRtUFwzWqMLKeL2I+u1zstYVQh335c/E64ZKg0I7XodXPmtnRzI5mdvps",
	"49isG5Z9HowcCYodk5NY6s174dt8zguDCK9Lcj+ks2PJ/A5ZIjH2dIuUDp5m4fe3aV4G337oTgYa4jTE",
	"aYjTEHeOFNvf5jLIbzqu7/V4mUpIDAQjQxe+pVltfn8xiTpUZqVRx9phdDNWGjIikgJhCkHyOSQQBCsZ",
	"BUJBTxk8wd/piJQrd2NmjkL8Iupnt2SOioObN8ti3j7kTLuYsyfK/Ky95+DMkcMVXWDbgt5kQLL8x+K3",
	"NH5uxKl0itQMEFQSbTn3sNTEEdlMdL+00QD7vQlk+2HUgU7w8KIyNag6caJrGXVpUsKhvgwTP+6x+MJS",
	"2uDwUKzlXwXLq/yxQg9gapvZ+Rh/PyBskQuEw0IDsS+KCNwl48+/BZzaRtQujTCZdDuRmYRJRHBFdIR3",
	"L/aQx7Frgk1xZx8vtabOKKmZVM2kaiZVM6mnl1GSINK5SihJeWCBVw5RtXDnfjHNrONfQRuzHe6M5+hb",
	"mQ9Qhdb9lrYmsrE6dq7GAo0FGguOjQX9DF0b0v7zErn2W0b/08h/UlkyZNRqA+aSb7q2Ue8ps1+EDqBB",
	"kLP4PaWeQ0IePxDpZRAZqdVKrOUkkAgvNaZoTNGYojHlfRu1Ebr03sKwnx8sG6nVECf9veNZ03Qtp2ZV",
	"DfGGOqGAnwy/Uogw4btj6eTTb4kz9eNXXaeBxmgVPevgj9nmtNNji11svni932jzLA3bGrY1bPeYCC5l",
	"eDesqml7JiuXTuuihuQS2hBMfbceAV3vMOuZhltd6MtVO1x2RrfAu3ifp8Xr4H3V7XkZ2lbcodMX+ib9",
	"rN6kH1GbCWZFoa+yz99VdtXwFiquOW95vunGt1rYq+/uFI+z71TrIpjoRBMdtENIE+hO8JDRndwbU1/M",
	"aw5cc+CaA9cX8/pivtvFPOVNu93PKzjte/SPXlMJZlzehwaoIu9M/+klXSDrVT71Ewfv0KOBlEbKfNUa",
	"ojREaYjSEPXus/6dnzuWyFTseEjUcywB0VpgMxlZYJ+mct/Fr8gmwlugHUhBLcEvX0Ku3rzy3xl6aed6",
	"DcwamDUwa+f68+FcD9AQ961PQVbQuPfqsAjqc9nRjIXmobcmu2QBlfcm0BpAJ/1TiZaxLvwSrFI/xmBF",
	"cIVLgS3PN/wW2QEZGzm9Qq7xzVop6HgZmgHdb0JPG2vtuArtY6nR+9Q2P3JjtD3tJqY5Cs1RaI5CcxSn",
	"po0GVPnG8heI4DzFrifPk3Ka8iESw8KBOcNpjCWrJesfrAarZEscUIEe4vCGfvMCY3KI92nA33UaInAl",
	"WGUouZ30t8cHeBtuaB+GsQLxJr3i5de7e3wTE7r7CCrZ4QTiEB9A57YJ/obhC/Ff8V/xzwj6sgO8yJNw",
	"67JvNuld8RuEX+NtxLb4K/D3J08p20U2dJGSHrxDvfPBR2I3IjzhsOmQf+FjDZ6J5OkQb/w6WMd7wao0",
	"9k3EQiUdBG00UxidKo1Ml8ZmCtRwhqbMIaOFEMjUZY8GO5QXRIxecIQP8Vu8jWYKlm35llGv+K5he0aV",
	"LOhM4aK4MqEFwiZYIahWh/eQMXMTk6WbpTHVopFJwhspfd4I1gg1hqjOeAsf4V2w/IGcQTssFjT0fJ8u",
	"T/AM4Z/wv+GXdCI49RJiSnVI1/A6fol/Kc7YZFeg4Dneo4EbOqBmekt6RXnrTdwJ1mlAqb2QxnUAtPFe",
	"sIYP8BYLUR1GnVbv2g70HXBftW9Zxp23LMEz2UyC+ciKkiumgweSu0m5fjAOCd9D6ikYMZ98ynGM3pgo",
	"l8aiXaeqmUznazZbmX1LW4VrpenYsI/IrD4hUxQ8DNaQLOUM3eP2RfeLMzaZbxQ9QQMI2t4GyNiFSBl7",
	"0P4hteJh3R6csfGfYIi88iqlb7QRGPDfw4gbRVh3fkRZEI1oZ78hfSVLvSbPP5090qVHdLbJ4X5MZzs6",
	"8WF1sCR0NrdhO9NZk84i7gzCydpm0cjbQMHYCQCehJmShQX3qTlT2Dlxu7WlhUwhPpuInvegjWKn3fId",
	"O7GlVxnxg5MCxHEDqJwQ92aNHlaycmSeIAz7E2F3h4M9FHdX8IKCQSd8vRsxxhFFjI4CjSK7O5jidAxY",
	"JQix2jtMixVarNBiRX4zc7nD42NoamoCjcybth8G9toH+G7zLHhR5GvwZwWdzrOQv0MXOM+0QRgL4BoE",
	"q9etYI284IgWtPFmxiSPmXetqjkwPpYxx++ry9EU817W3r8hf/89/QScEdz9ku59/ZP2JPnTMt0RuyZK",
	"oufFfR2mIU0KTajNh6p1xzMzfNZ/SXDpkWE2oUirTMSQBSZJr56QYw/DA0UZZMKs7KMLsoR7UeC8CdMu",
	"ykxcqAO69laSBIH1mikQ9nP85rVQ0ltRio1qYSoxGrX4R2bOsuf7Kv4xrvlMiX8fpwQkMe5ZS06WiHDf",
	"MO/7PNErAwnqMyIIL29BGD6MmHyQlPdolqZoLrYIcg8KGwX2/Bbs5yghYShBhK4yq8GDoI036I6IJBom",
	"EBzQKReEDTrQn/ERQPwhsFkM24RzrJC8gpXgR6h6P+IdqFcIO0xwJ0PFKIGxBqWKKB5uRUU3ufNAGwWP",
	"gqccXYWlJ52lqSVmWTKKv0Pbr3DnVyzlBHuB8EsybMQ7KSBvWzKT6dJfut3YIQ3awQOaemOPEbw9qvQC",
	"UtWesZm6C9Isg1Jjj5SnSwQ3VDRpNSM4axDJki1sB79mOg1pR0S06FdJSY1Q5rigBg+1tKalNS2taWlN",
	"S2tnRFo7LRkqRAAtQr0bEYpMeK8SVMR+9pQXjJxpzmKFaTeBXRD4t1QLJIElgP/m9zkRHJR7N9qFtrTH",
	"ieZANAeiOZCzYYZy3jErND05DmJ1Vf+9SFeMMMXVg+CJGG6Eae8ypNkry2XTthyXr1cCyTJkXI1nGs80",
	"nmk8O19htvovWZYXHNfPKV5qqD4F8RJdWUYUBhErlgO+fWOpJzcX0PbjTvAk8o4InlKLJhrXai9o402V",
	"jDlSr08bSyb1c5k2lvI4uWh41PCo4VHD49mKQpmNC7nc5aaNJRbQQPRep60iIn6N1OsIyCUaaVro9iXy",
	"A10TvbW4b92H7ZcZjlPEqpcRmiTwKrKM8LICSU8L31HEER7kjkRJ/SbVcRczlzdqLMsnUhl2knx1kgan",
	"SQX3dag8zSZoNkGzCVorfIrOiY4r4sz5cEkUcVTE7L8ljAhfpCP30D3hV+yaMwvKE0gu/J3/ulJu+1hK",
	"XqFdrerVIKVBSoPU2QApgTCdn4h5wqC7QxJBCJ+mSKiZTdesEkjnlD+RXS80Nd4HH9FDvJW0iKfGXlGw",
	"8qQhN5TgylTxCBcTmtJbzZrhm7kxbxLGolFPo55GPY165zD9X4Je9pQJ8LIG3uMCL5343rBXEAd/MGcX",
	"HGeR7uO66ZuKHf0fEeZu4l2A2LfB82BdeQ1JYXgTb4OP21rKReQYtPUNbRyglf1NX+gbSY1nGs80nn1U",
	"N5JZeCHRwzIt8rEjFx0zYoMWUevPEXqApKg2i1mP8uGFUiGhApLnsuwCuitEk6LhopRmNN3Q65rps16P",
	"23OOCF/amkZjl8YujV3nCbsEUnhOkOua6XPYQmTYWdjFvS+qRr0+a1QXYfodt2a6FdvxrTk2VvL03j+0",
	"3Pr9DJeNv0AsDh7hk4ac6+AtiOG5IsafAzqwRYNgsAyZkxNlMRoHgcE23lE5K64HzwR3xZiTCPlwC4hU",
	"0oMxOapKpeXWK5Um9fg4Db3DBGmTysDi5uumcOjf7r8pDFfSeXyg1mAwoUgcFZ/Rqmk1/bOxaX+Er/bC",
	"WJFRIJP9KERih/xIbFLVOE5/m07RVvVG7d9GZVOq2Kqe6d61qmblTG3ZFfw2WMOvCbcMWrSuGzVrFKe/",
	"Ycu0db1v+75v2cyijP0Lfo8fAHegiKfN4nekR91K7vPEaN/B7iZt6k3dx00Nnk/xrXy/mF9nkxX579bU",
	"DWErgxICtvIuiwmTZAi4UEcpbNDGm8Xkdm0rYxxG0aNnbBb0DGJ6vU7Q8OAhOW8H0CcW2C14yOqEKOrB",
	"GrTP3/R2APEO7/ERC60P4QKDZymnkgaE+0vajcwO3gC2vY1f4U7wLFIdMEF3j+nMDqnmgQbWgWA6D/A2",
	"3seHtP6/R/SFRRJkKfhpjsIo5Fs7tmJHDPcOmF4OJOo3MAAy2jQCtCa0BzF/NlnQ92CN7CAamY4v9krw",
	"kPY1eDZj82h1h0ypsqqIJT8Aw95Cl4eHixBKnEVGjwKjq74O15FGrPsn9NnwcKgIe0ymDkFs8HY8ElFs",
	"OYP2jC1ZqVwaluLqC/Mh7B1anMZAEgKDByvgAMii1T2HfAz76LMBsu9e0eDnEGsT0dSSUM0BTCBoLdip",
	"5AqN4AH0+y2pZMa+QARXZ25uwDV9d7kImynqtjQ6dEkaAovRjz4dRsFDllpgFx9c5FEa8VY4YzECENWr",
	"VtJyjSP8lwx1dMGsLl5xlshwt+FUyjoy1i2e7wKsiXh6DNVeEUquzdjJtaMRCMUwiCFFK6aGxBTDI7LG",
	"yYfdFNaPWWRJ/CZYoRHlw51BuqaKOihPELCY4RQNqqafVyJe4lI14i6NhhjTirOYj7FAj2SZt4MnMe1k",
	"SqBSsq6vwjCX+8HaVzP2999/P2ObdtWpmVcMz/ziswszNkIIXW8Y1fL1kcuff8EekP95ZtU1/cqiuVyM",
	"Hs6b/pVl3/RuTV8d+FL4mPyPMROVWae2HL25SP+8OGNfZB0YQN+LffgeDRCMoYEheVoCulDJVBcbNPNB",
	"8IAbogk2aZuIVogE+r2KvvvBWrTuXFjw/ab31dCQ2xokD5pmzTIGHXd+iPwaogUvFs9+56KlkruGd9XJ",
	"QfiWkUz6yM8tthf/Z/AwXzeufz0yyjoh7QJFP1KniCWg22PwJk7YNiWw23grFlOXlLtAvgaAkEKWQvsX",
	"83Wffkv7L+5U6L7qtMGX0SGA79LJHJz6nfCo82h60YGPKFLEGLHFEI/zFu/FK4iYTIgmIRDfLw2wTg94",
	"1rxt+C3X/L5IgRjvUXihWTyA4VPFbwWAO1RZaEpY2IVcRpQSrqMgCYywzXfo+IAJhci4MTIESZgSYko5",
	"vPMT7/t0vFZ94acv/PSF37mJLhNSwZ7sO0/lspFrRM7JpWM5unRMv2+8f//+/x8AAP//7DE+TR/yAwA=",
}

// GetSwagger returns the content of the embedded swagger specification file
// or error if failed to decode
func decodeSpec() ([]byte, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %s", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}

	return buf.Bytes(), nil
}

var rawSpec = decodeSpecCached()

// a naive cached of a decoded swagger spec
func decodeSpecCached() func() ([]byte, error) {
	data, err := decodeSpec()
	return func() ([]byte, error) {
		return data, err
	}
}

// Constructs a synthetic filesystem for resolving external references when loading openapi specifications.
func PathToRawSpec(pathToFile string) map[string]func() ([]byte, error) {
	var res = make(map[string]func() ([]byte, error))
	if len(pathToFile) > 0 {
		res[pathToFile] = rawSpec
	}

	return res
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file. The external references of Swagger specification are resolved.
// The logic of resolving external references is tightly connected to "import-mapping" feature.
// Externally referenced files must be embedded in the corresponding golang packages.
// Urls can be supported but this task was out of the scope.
func GetSwagger() (swagger *openapi3.T, err error) {
	var resolvePath = PathToRawSpec("")

	loader := openapi3.NewLoader()
	loader.IsExternalRefsAllowed = true
	loader.ReadFromURIFunc = func(loader *openapi3.Loader, url *url.URL) ([]byte, error) {
		var pathToFile = url.String()
		pathToFile = path.Clean(pathToFile)
		getSpec, ok := resolvePath[pathToFile]
		if !ok {
			err1 := fmt.Errorf("path not found: %s", pathToFile)
			return nil, err1
		}
		return getSpec()
	}
	var specData []byte
	specData, err = rawSpec()
	if err != nil {
		return
	}
	swagger, err = loader.LoadFromData(specData)
	if err != nil {
		return
	}
	return
}
